<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dig, Dig, Dig!</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0f1a12;
        color: #e8eaf6;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          Noto Sans,
          Helvetica,
          Arial,
          'Apple Color Emoji',
          'Segoe UI Emoji';
      }
      .wrap {
        display: grid;
        grid-template-rows: 1fr;
        min-height: 100%;
      }
      main {
        display: grid;
        place-items: center;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        background: #1c7f2d;
        border: 1px solid #2b2f55;
        box-shadow:
          0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        max-width: 100%;
        height: 100%;
        width: auto;
      }
      .hint {
        opacity: 0.8;
        font-size: 11px;
      }
      kbd {
        background: #202659;
        border: 1px solid #303776;
        border-bottom-width: 2px;
        border-radius: 4px;
        padding: 1px 6px;
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono',
          monospace;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <main>
        <canvas
          id="game"
          width="800"
          height="500"
          aria-label="Game canvas"
        ></canvas>
      </main>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById('game');
        if (!canvas) {
          console.error('Game canvas element not found!');
          return;
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Failed to get 2d context from game canvas!');
          return;
        }
        ctx.imageSmoothingEnabled = false; // Disable smoothing for crisp pixel art

        const world = {
          width: 2400,
          height: 2064,
          bg: '#0f1226',
        };

        const camera = {
          x: world.width / 2,
          y: world.height / 2,
          followLerp: 0.12,
        };

        // Title screen camera for scrolling background
        const titleScreenCamera = {
          centerX: world.width / 2, // Center of circular movement
          centerY: world.height / 2,
          radiusX: world.width * 0.2, // Horizontal radius of movement
          radiusY: world.height * 0.15, // Vertical radius of movement
          angle: 0, // Current angle in radians (for smooth circular movement)
          speed: 0.3, // radians per second (slow, smooth rotation)
        };

        // Game state: 'loading', 'title', 'achievements', 'saveSelect', 'controls', 'starting', 'playing',
        // 'dayEnd', 'museum', or 'weekEnd'
        let gameState = 'loading';

        // Achievements system
        // Achievements are global (not per-save) and persist across all games
        const achievements = {
          // List of achievements - each has: id, name, description, completed (boolean)
          // Names are always visible, descriptions show "???" when locked
          list: [
            {
              id: 'clocking_out',
              name: 'Clocking out',
              description: 'Complete a full week of work',
              completed: false,
            },
            {
              id: 'scanning_master',
              name: 'Scanning master',
              description: 'You got the radar',
              iconType: 'radar',
              completed: false,
            },
            {
              id: 'henry_knox_experience',
              name: 'Henry Knox Experience',
              description: 'You displayed the cannon',
              iconType: 'cannon',
              completed: false,
            },
            {
              id: 'nothing',
              name: 'Nothing',
              description: "You didn't do anything. Wow.",
              completed: false,
            },
            {
              id: 'consolation_prize',
              name: 'Consolation prize',
              description: "You didn't do that bad, I guess.",
              completed: false,
            },
            {
              id: 'classic',
              name: 'Classic',
              description: 'Congrats on a amazing museum!',
              completed: false,
            },
            {
              id: 'overachiever',
              name: 'Overachiever',
              description:
                'You did great! There may be something you are missing, though.',
              completed: false,
            },
            {
              id: 'legendary',
              name: 'Legendary',
              description: 'You got the best ending! Hooray to you!',
              completed: false,
            },
            {
              id: 'good_start',
              name: 'Good start',
              description: 'You dug your first X!',
              completed: false,
            },
            {
              id: 'on_the_right_track',
              name: 'On the right track',
              description: "You dug 20 X's!",
              completed: false,
            },
            {
              id: 'pro_digger',
              name: 'Pro digger',
              description: "You dug 50 X's!",
              completed: false,
            },
            {
              id: 'master_digger',
              name: 'Master digger',
              description: "You dug a whopping 100 X's!",
              completed: false,
            },
          ],
        };

        // Save achievements to localStorage (global, not per-save)
        function saveAchievements() {
          try {
            const achievementsData = achievements.list.map((a) => ({
              id: a.id,
              completed: a.completed,
            }));
            localStorage.setItem(
              'gameAchievements',
              JSON.stringify(achievementsData),
            );
          } catch (error) {
            console.error('Failed to save achievements:', error);
          }
        }

        // Load achievements from localStorage
        function loadAchievements() {
          try {
            const achievementsDataStr =
              localStorage.getItem('gameAchievements');
            if (achievementsDataStr) {
              const achievementsData = JSON.parse(achievementsDataStr);
              // Merge saved completion status with current achievement list
              achievements.list.forEach((achievement) => {
                const saved = achievementsData.find(
                  (a) => a.id === achievement.id,
                );
                if (saved) {
                  achievement.completed = saved.completed;
                }
              });
            }
          } catch (error) {
            console.error('Failed to load achievements:', error);
          }
        }

        // Start-game flow: queue heavy setup so input feels instant
        let startGamePending = false;

        // Auto-save timer (save every 30 seconds during gameplay)
        let autoSaveTimer = 0;
        const AUTO_SAVE_INTERVAL = 30000; // 30 seconds in milliseconds

        // Save system: 3 save slots using localStorage
        // Each save slot stores: game state, player data, inventory, museum, etc.
        const SAVE_SLOTS = 3;
        let currentSaveSlot = null; // Track which save slot is currently active (0-2)

        // Save game state to localStorage
        // This function captures all important game data and stores it in the browser's localStorage
        // localStorage persists even after closing the browser, making saves permanent
        function saveGame(slotIndex) {
          try {
            // Create a save data object with all game state
            const saveData = {
              version: 1, // Save format version (for future compatibility)
              timestamp: Date.now(), // When this save was created
              completed: false, // Whether the week has been completed

              // Game state
              gameState: gameState,

              // Player data
              player: {
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
              },

              // Camera position
              camera: {
                x: camera.x,
                y: camera.y,
              },

              // Day/time system
              dayTime: {
                currentDay: dayTime.currentDay,
                currentHour: dayTime.currentHour,
                hourTimer: dayTime.hourTimer,
              },

              // Inventory
              inventory: {
                slots: JSON.parse(JSON.stringify(inventory.slots)), // Deep copy
                equipment: inventory.equipment,
                speedBrush: inventory.speedBrush,
              },

              // Museum state
              museum: {
                displayCases: JSON.parse(JSON.stringify(museum.displayCases)), // Deep copy
                cannonDisplay: museum.cannonDisplay
                  ? JSON.parse(JSON.stringify(museum.cannonDisplay))
                  : null,
                hasInitializedDisplays: museum.hasInitializedDisplays,
              },

              // Radar discoveries
              radar: {
                discoveredSecretX: JSON.parse(
                  JSON.stringify(radar.discoveredSecretX),
                ),
                rings: JSON.parse(JSON.stringify(radar.rings)),
              },

              // NPC dialogue states
              npcs: {
                oldGuy: {
                  hasCompletedIntro: oldGuy.hasCompletedIntro,
                },
                joseph: {
                  hasGivenRadar: joseph.hasGivenRadar,
                },
                warningGuy: {
                  hasCompletedIntro: warningGuy.hasCompletedIntro,
                },
                curator: {
                  hasCompletedIntro: curator.hasCompletedIntro,
                },
                cannonBuff: {
                  hasCompletedIntro: cannonBuff.hasCompletedIntro,
                  hasGivenReward: cannonBuff.hasGivenReward,
                },
              },

              // Quest states
              quests: {
                getCannonForCannonBuff: {
                  active: quests.getCannonForCannonBuff.active,
                  completed: quests.getCannonForCannonBuff.completed,
                },
              },

              // Tile map: save which tiles have been converted (X -> grass)
              // We don't save the entire tileMap (it's regenerated each day),
              // but we track which X tiles have been used
              convertedTiles: [], // Array of {row, col} for tiles converted from X to grass
            };

            // Store in localStorage with key "gameSave_slot0", "gameSave_slot1", etc.
            const saveKey = `gameSave_slot${slotIndex}`;
            localStorage.setItem(saveKey, JSON.stringify(saveData));

            return true;
          } catch (error) {
            console.error('Failed to save game:', error);
            return false;
          }
        }

        // Load game state from localStorage
        // This function restores all saved game data
        function loadGame(slotIndex) {
          try {
            const saveKey = `gameSave_slot${slotIndex}`;
            const saveDataStr = localStorage.getItem(saveKey);

            if (!saveDataStr) {
              return false; // No save data found
            }

            const saveData = JSON.parse(saveDataStr);

            // Restore game state
            if (saveData.gameState) {
              gameState = saveData.gameState;
            }

            // Restore player position
            if (saveData.player) {
              player.x = saveData.player.x;
              player.y = saveData.player.y;
              player.vx = saveData.player.vx || 0;
              player.vy = saveData.player.vy || 0;
            }

            // Restore camera
            if (saveData.camera) {
              camera.x = saveData.camera.x;
              camera.y = saveData.camera.y;
            }

            // Restore day/time
            if (saveData.dayTime) {
              dayTime.currentDay = saveData.dayTime.currentDay;
              dayTime.currentHour = saveData.dayTime.currentHour;
              dayTime.hourTimer = saveData.dayTime.hourTimer || 0;
            }

            // Restore inventory
            if (saveData.inventory) {
              inventory.slots =
                saveData.inventory.slots || Array(25).fill(null);
              // Restore artifact sprites (they don't serialize properly)
              for (let i = 0; i < inventory.slots.length; i++) {
                if (inventory.slots[i] && inventory.slots[i].name) {
                  const sprite = getArtifactSpriteByName(
                    inventory.slots[i].name,
                  );
                  if (sprite) {
                    inventory.slots[i].sprite = sprite;
                  }
                }
              }
              // Restore equipment sprite if it's an artifact
              if (inventory.equipment && inventory.equipment.name) {
                const equipmentSprite = getArtifactSpriteByName(
                  inventory.equipment.name,
                );
                if (equipmentSprite) {
                  inventory.equipment.sprite = equipmentSprite;
                }
              }
              inventory.speedBrush = saveData.inventory.speedBrush || false;
            }

            // Restore museum
            if (saveData.museum) {
              museum.displayCases = saveData.museum.displayCases || [];
              // Restore artifact sprites in display cases
              for (let i = 0; i < museum.displayCases.length; i++) {
                if (
                  museum.displayCases[i].artifact &&
                  museum.displayCases[i].artifact.name
                ) {
                  const sprite = getArtifactSpriteByName(
                    museum.displayCases[i].artifact.name,
                  );
                  if (sprite) {
                    museum.displayCases[i].artifact.sprite = sprite;
                  }
                }
              }
              // Restore cannon display sprite
              if (
                museum.cannonDisplay &&
                museum.cannonDisplay.artifact &&
                museum.cannonDisplay.artifact.name
              ) {
                const sprite = getArtifactSpriteByName(
                  museum.cannonDisplay.artifact.name,
                );
                if (sprite) {
                  museum.cannonDisplay.artifact.sprite = sprite;
                }
              }
              museum.hasInitializedDisplays =
                saveData.museum.hasInitializedDisplays || false;
            }

            // Restore radar
            if (saveData.radar) {
              radar.discoveredSecretX = saveData.radar.discoveredSecretX || [];
              radar.rings = saveData.radar.rings || [];
            }

            // Restore NPC states
            if (saveData.npcs) {
              if (saveData.npcs.oldGuy) {
                oldGuy.hasCompletedIntro =
                  saveData.npcs.oldGuy.hasCompletedIntro || false;
              }
              if (saveData.npcs.joseph) {
                joseph.hasGivenRadar =
                  saveData.npcs.joseph.hasGivenRadar || false;
              }
              if (saveData.npcs.warningGuy) {
                warningGuy.hasCompletedIntro =
                  saveData.npcs.warningGuy.hasCompletedIntro || false;
              }
              if (saveData.npcs.curator) {
                curator.hasCompletedIntro =
                  saveData.npcs.curator.hasCompletedIntro || false;
              }
              if (saveData.npcs.cannonBuff) {
                cannonBuff.hasCompletedIntro =
                  saveData.npcs.cannonBuff.hasCompletedIntro || false;
                cannonBuff.hasGivenReward =
                  saveData.npcs.cannonBuff.hasGivenReward || false;
              }
            }

            // Restore quests
            if (saveData.quests) {
              if (saveData.quests.getCannonForCannonBuff) {
                quests.getCannonForCannonBuff.active =
                  saveData.quests.getCannonForCannonBuff.active || false;
                quests.getCannonForCannonBuff.completed =
                  saveData.quests.getCannonForCannonBuff.completed || false;
              }
            }

            // Regenerate tiles (they're regenerated each day anyway)
            tileMap = generateTiles();
            tileRegenerationScheduled = false;
            doRegenerateTiles();

            // Mark this as the current save slot
            currentSaveSlot = slotIndex;

            return true;
          } catch (error) {
            console.error('Failed to load game:', error);
            return false;
          }
        }

        // Get save slot info (for displaying in menu)
        // Returns metadata about a save slot without loading the full game
        function getSaveSlotInfo(slotIndex) {
          try {
            const saveKey = `gameSave_slot${slotIndex}`;
            const saveDataStr = localStorage.getItem(saveKey);

            if (!saveDataStr) {
              return null; // Empty slot
            }

            const saveData = JSON.parse(saveDataStr);

            return {
              exists: true,
              completed: saveData.completed || false,
              timestamp: saveData.timestamp || 0,
              dayTime: saveData.dayTime || { currentDay: 0, currentHour: 8 },
            };
          } catch (error) {
            console.error('Failed to get save slot info:', error);
            return null;
          }
        }

        // Delete a save slot
        function deleteSaveSlot(slotIndex) {
          try {
            const saveKey = `gameSave_slot${slotIndex}`;
            localStorage.removeItem(saveKey);
            return true;
          } catch (error) {
            console.error('Failed to delete save slot:', error);
            return false;
          }
        }

        // Auto-save during gameplay (called periodically)
        function autoSave() {
          if (currentSaveSlot !== null && gameState === 'playing') {
            saveGame(currentSaveSlot);
          }
        }

        // Loading screen facts - random facts shown while loading
        // These help entertain the player during asset loading
        const loadingFacts = [
          'Did you know honey never spoils? Archaeologists have found 3,000 year old honey in Egyptian tombs that is still safe to eat!',
          'The oldest urban civilization is Sumer, settled around 4500 B.C.!',
          'The oldest tools ever found were in Kenya, dating back to 3.3 Million years ago!',
        ];

        // Loading screen state
        const loadingState = {
          progress: 0,
          displayProgress: 0, // Smoothed progress for visual display
          loadingTimer: 0, // Timer tracking how long we've been loading
          fillDuration: 7500, // Progress bar fills over 7.5 seconds
          allLoaded: false,
          postLoadTimer: 0,
          postLoadDelay: 0, // No additional delay - bar fill time is the delay
          currentFact: null, // The fact being displayed during this loading session
        };

        // Track all sprites for loading progress
        let allSprites = [];

        // Function to check loading progress
        function updateLoadingProgress(dtMs) {
          // Track actual asset loading progress (for reference, but don't use for bar)
          if (allSprites.length > 0) {
            let loaded = 0;
            let failed = 0;
            for (let i = 0; i < allSprites.length; i++) {
              const sprite = allSprites[i];
              if (sprite.complete && sprite.naturalWidth > 0) {
                loaded++;
              } else if (sprite.complete && sprite.naturalWidth === 0) {
                failed++;
              }
            }
            loadingState.progress = (loaded + failed) / allSprites.length;

            // Check if all assets are loaded
            const allDone = allSprites.every((sprite) => sprite.complete);
            if (allDone && !loadingState.allLoaded) {
              loadingState.allLoaded = true;
            }
          }

          // Progress bar fills gradually over 8 seconds based on time, not asset loading
          // This ensures the bar always takes 8 seconds to fill, giving time to read facts
          loadingState.loadingTimer += dtMs;
          const timeBasedProgress = Math.min(
            loadingState.loadingTimer / loadingState.fillDuration,
            1.0,
          );

          // Smooth the progress bar animation using linear interpolation (lerp)
          // This creates a fluent, smooth progress bar
          const lerpSpeed = 0.2; // How fast the display progress catches up
          loadingState.displayProgress +=
            (timeBasedProgress - loadingState.displayProgress) * lerpSpeed;
        }

        // Initialize a random fact when loading starts
        // Called once when the game first starts loading
        function initializeLoadingFact() {
          if (loadingState.currentFact === null && loadingFacts.length > 0) {
            // Pick a random fact from the array
            const randomIndex = Math.floor(Math.random() * loadingFacts.length);
            loadingState.currentFact = loadingFacts[randomIndex];
          }
        }

        // Draw loading screen
        function drawLoadingScreen() {
          try {
            // Initialize fact if not already set (happens once on first load)
            initializeLoadingFact();

            // Clear canvas and draw background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f1a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'Loading...',
              canvas.width / 2,
              canvas.height / 2 - 60,
            );

            // Progress bar background
            const barWidth = 400;
            const barHeight = 30;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = canvas.height / 2;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Progress bar fill (use smoothed displayProgress for fluent animation)
            const progressWidth =
              barWidth * Math.min(Math.max(loadingState.displayProgress, 0), 1);
            ctx.fillStyle = '#51ff8a';
            ctx.fillRect(barX, barY, progressWidth, barHeight);

            // Progress bar border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Progress text (use displayProgress to match the bar)
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
            // Clamp percent to 0-100 so it never shows negative values
            const percentValue = Math.min(
              Math.max(loadingState.displayProgress || 0, 0),
              1,
            );
            const percentText = Math.round(percentValue * 100) + '%';
            ctx.fillText(percentText, canvas.width / 2, barY + barHeight + 30);

            // Display fact below progress (if we have one)
            if (loadingState.currentFact) {
              ctx.fillStyle = '#e6e6e6'; // Light white for readability
              ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
              // Word wrap the fact text so it fits nicely on screen
              // Max width for text wrapping
              const maxWidth = canvas.width - 100; // Leave 50px padding on each side
              const lineHeight = 24;
              const factY = barY + barHeight + 70; // Below progress text

              // Split text into lines that fit within maxWidth
              const words = loadingState.currentFact.split(' ');
              let currentLine = '';
              let y = factY;

              for (let i = 0; i < words.length; i++) {
                const testLine =
                  currentLine + (currentLine ? ' ' : '') + words[i];
                const metrics = ctx.measureText(testLine);

                // If this line would be too wide, draw the current line and start a new one
                if (metrics.width > maxWidth && currentLine) {
                  ctx.fillText(currentLine, canvas.width / 2, y);
                  y += lineHeight;
                  currentLine = words[i];
                } else {
                  currentLine = testLine;
                }
              }

              // Draw the last line
              if (currentLine) {
                ctx.fillText(currentLine, canvas.width / 2, y);
              }
            }
          } catch (error) {
            console.error('Loading screen draw error:', error);
            // Fallback: just fill with dark background
            ctx.fillStyle = '#0f1a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }

        // Museum system
        const museum = {
          width: 16, // 16 tiles wide
          height: 16, // 16 tiles tall
          doorRow: 15, // Bottom row (0-indexed)
          doorCol: 7, // Middle column (16/2 - 1 = 7, 0-indexed)
          doorPrompt: false, // Whether door prompt is showing
          wasNearDoor: false, // Track if player was near door (for one-time prompt activation)
          buildMode: false, // Whether build mode is active
          displayCases: [], // Array of display cases: {row, col, artifact: null or {name, sprite}}
          selectedArtifactIndex: null, // Index of selected artifact in inventory (for build mode)
          cannonDisplay: null, // Special 1x2 display for cannon artifact only: {artifact: null or {name, sprite, tier}}
          hasInitializedDisplays: false, // Keep displays across museum visits
        };

        // Day/Time system
        const dayTime = {
          currentDay: 0, // 0 = Monday, 1 = Tuesday, ..., 6 = Sunday
          currentHour: 8, // Current hour (start at start of Monday = 8 AM)
          hourTimer: 0, // Timer that accumulates seconds, resets when >= 30
          secondsPerHour: 30, // Each in-game hour = 30 seconds (reduced from 45)
          dayEndHour: 18, // 6 PM (day ends when hour reaches this)
          warningHour: 17, // 5 PM (1 hour before end)
          days: [
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday',
            'Sunday',
          ],
        };

        const tileSize = 32;
        const tileCols = Math.ceil(world.width / tileSize);
        const tileRows = Math.ceil(world.height / tileSize);
        const tileCell = 4;
        const cellsPerTile = tileSize / tileCell;

        // NPC spawn points (used for both NPC placement and X spawn safety)
        // We keep these near the center so the player meets key characters quickly.
        const npcSpawnPoints = {
          oldGuy: {
            x: world.width / 2 + 150, // To the right of spawn
            y: world.height - 40, // Same Y as spawn
            radius: 20,
          },
          warningGuy: {
            // New NPC: stands to the LEFT of spawn, mirroring oldGuy.
            // Because world.width/2 is the horizontal center, subtracting
            // moves him left, adding moves right.
            x: world.width / 2 - 150,
            y: world.height - 40,
            radius: 20,
          },
          joseph: {
            x: world.width / 2, // Central location
            y: world.height / 2, // Central location
            radius: 20,
          },
        };

        function randomRange(min, max) {
          return Math.random() * (max - min) + min;
        }

        function createScatter(
          count,
          minSize,
          maxSize,
          margin = 60,
          minDistance = 120,
        ) {
          const sprites = [];
          const maxAttempts = 50;
          const cellSize = minDistance * 2;
          const gridCols = Math.ceil(world.width / cellSize);
          const gridRows = Math.ceil(world.height / cellSize);
          const grid = Array.from({ length: gridRows }, () =>
            Array(gridCols)
              .fill(null)
              .map(() => []),
          );

          function getGridCell(x, y) {
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            return {
              row: Math.max(0, Math.min(gridRows - 1, row)),
              col: Math.max(0, Math.min(gridCols - 1, col)),
            };
          }

          for (let i = 0; i < count; i++) {
            const size = randomRange(minSize, maxSize);
            const colliderRadius = size * 0.42;
            const requiredDistance = minDistance + colliderRadius;
            const requiredDistanceSq = requiredDistance * requiredDistance;

            let x,
              y,
              valid = false;
            let placementAttempts = 0;

            while (!valid && placementAttempts < maxAttempts) {
              placementAttempts++;
              x = randomRange(margin, world.width - margin);
              y = randomRange(margin, world.height - margin);

              const cell = getGridCell(x, y);
              valid = true;
              for (let dr = -1; dr <= 1 && valid; dr++) {
                for (let dc = -1; dc <= 1 && valid; dc++) {
                  const checkRow = cell.row + dr;
                  const checkCol = cell.col + dc;
                  if (
                    checkRow >= 0 &&
                    checkRow < gridRows &&
                    checkCol >= 0 &&
                    checkCol < gridCols
                  ) {
                    for (const existing of grid[checkRow][checkCol]) {
                      const dx = x - existing.x;
                      const dy = y - existing.y;
                      const distSq = dx * dx + dy * dy;
                      if (distSq < requiredDistanceSq) {
                        valid = false;
                        break;
                      }
                    }
                  }
                }
              }
            }

            if (valid) {
              const tree = {
                x,
                y,
                size,
                rotation: randomRange(-Math.PI / 8, Math.PI / 8),
                colliderRadius,
              };
              sprites.push(tree);
              const cell = getGridCell(x, y);
              grid[cell.row][cell.col].push(tree);
            }
          }
          return sprites;
        }

        const flora = {
          trees: createScatter(65, 78, 102, 140, 180),
        };

        const brushingMinigame = {
          active: false,
          dirtLevel: 1.0,
          redness: 0,
          timeHoldingSpace: 0,
          redTriggerTime: 0,
          timeSinceRed: 0,
          redTransitionTime: 1.0,
          perfectReleaseWindow: 0.5,
          baseReward: 10,
          tileRow: null,
          tileCol: null,
          brushX: 0,
          brushY: 0,
          brushOffset: 0,
          brushDirection: 1,
          particles: [],
          completed: false,
          broken: false,
          isSecretX: false, // Track if this minigame came from a secret X tile
          showInstructions: false, // Track if question mark was clicked to show instructions
          hasStartedFirstTime: false, // Track if this minigame type has been started before
        };

        const minesweeperMinigame = {
          active: false,
          grid: [], // 6x6 grid of cells (true = mine, false = safe)
          revealed: [], // Boolean grid for revealed cells
          flagged: [], // Boolean grid for flagged cells
          gridSize: 6,
          mineCount: 4, // 4 mines in a 6x6 grid
          gameOver: false,
          won: false,
          gameOverMessage: null, // Message to display when game over (e.g., "Oops!")
          firstClick: true,
          clickCount: 0, // Track number of left clicks made (to prevent winning on first turn)
          tileRow: null,
          tileCol: null,
          isSecretX: false,
          baseReward: 10,
          showInstructions: false, // Track if question mark was clicked to show instructions
          hasStartedFirstTime: false, // Track if this minigame type has been started before
        };

        // Typo minigame documents with their possible typos
        const typoDocuments = [
          {
            // Declaration of Independence
            realExcerpt:
              'We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the pursuit of Happiness.',
            typoOptions: [
              { from: 'certain', to: 'sertain' },
              { from: 'self-evident', to: 'Celf-Evident' },
              { from: 'created', to: 'Craeted' },
              { from: 'unalienable', to: 'Unaliable' },
              { from: 'pursuit', to: 'Persuit' },
            ],
          },
          {
            // Thomas Paine's Common Sense
            realExcerpt:
              'Some writers have so confounded society with government, as to leave little or no distinction between them; whereas they are not only different, but have different origins. Society is produced by our wants, and government by our wickedness; the former promotes our happiness possitively by uniting our affections, the latter negatively by restraining our vices.',
            typoOptions: [
              { from: 'confounded', to: 'confoded' },
              { from: 'government', to: 'govement' },
              { from: 'distinction', to: 'disticon' },
              { from: 'wants', to: 'wahts' },
              { from: 'possitively', to: 'posetively' },
            ],
          },
          {
            // Declaration of Confederacy
            realExcerpt:
              'And now the State of South Carolina having resumed her separate and equal place among nations, deems it due to herself, to the remaining United States of America, and to the nations of the world, that she should declare the immediate causes which have led to this act.',
            typoOptions: [
              { from: 'America', to: 'amaraca' },
              { from: 'Carolina', to: 'Carilona' },
              { from: 'immediate', to: 'amedeate' },
              { from: 'nations', to: 'naetons' },
              { from: 'deems', to: 'dooms' },
            ],
          },
        ];

        // Typo minigame - randomly selects from typoDocuments
        const typoMinigame = {
          active: false,
          baseReward: 50,
          penalty: 30,
          tileRow: null,
          tileCol: null,
          realExcerpt: '',
          testExcerpt: '',
          isFake: false,
          answered: false,
          wasCorrect: false,
          actualReward: 0,
          isSecretX: false, // Track if this minigame came from a secret X tile
          selectedTypo: null, // Store which typo was selected for highlighting
          showInstructions: false, // Track if question mark was clicked
          hasStartedFirstTime: false, // Track if this minigame type has been started before
        };

        // Quiz minigame questions
        // Each question has a question text and the correct answer (true = Yes, false = No)
        const quizQuestions = [
          {
            question: 'A bigger shovel is always better.',
            correctAnswer: false, // No
          },
          {
            question: 'A backhoe is common in digs.',
            correctAnswer: true, // Yes
          },
          {
            question:
              'You should always get permission to dig on land you do not own.',
            correctAnswer: true, // Yes
          },
          {
            question:
              'If you find a grave while digging, you should open it without consulting the property owners.',
            correctAnswer: false, // No
          },
          {
            question: "You don't need a permit to dig on a dig site.",
            correctAnswer: false, // No
          },
        ];

        // Quiz minigame - asks yes/no questions about archaeology
        const quizMinigame = {
          active: false,
          baseReward: 50,
          penalty: 30,
          tileRow: null,
          tileCol: null,
          question: '',
          correctAnswer: false, // true = Yes, false = No
          answered: false,
          wasCorrect: false,
          actualReward: 0,
          isSecretX: false, // Track if this minigame came from a secret X tile
          showInstructions: false, // Track if question mark was clicked
          hasStartedFirstTime: false, // Track if this minigame type has been started before
        };

        // Optimize sprite loading: set imageSmoothingEnabled before src for faster rendering

        const brushSprite = new Image();
        brushSprite.imageSmoothingEnabled = false;
        brushSprite.src = 'assets/sprites/brush.png';

        const speedBrushSprite = new Image();
        speedBrushSprite.imageSmoothingEnabled = false;
        speedBrushSprite.src = 'assets/sprites/Speed_Brush.png';

        const dirtSprite = new Image();
        dirtSprite.imageSmoothingEnabled = false;
        dirtSprite.src = 'assets/sprites/dirt.png';

        const hotDirtSprite = new Image();
        hotDirtSprite.imageSmoothingEnabled = false;
        hotDirtSprite.src = 'assets/sprites/Hot_dirt.png';

        const grassSprite = new Image();
        grassSprite.imageSmoothingEnabled = false;
        grassSprite.src = 'assets/sprites/Grass.png';

        const flowerSprite = new Image();
        flowerSprite.imageSmoothingEnabled = false;
        flowerSprite.src = 'assets/sprites/New_Flower.png';

        const rock1Sprite = new Image();
        rock1Sprite.imageSmoothingEnabled = false;
        rock1Sprite.src = 'assets/sprites/Rock_1.png';

        const rock2Sprite = new Image();
        rock2Sprite.imageSmoothingEnabled = false;
        rock2Sprite.src = 'assets/sprites/Rock_2.png';

        const newXSprite = new Image();
        newXSprite.imageSmoothingEnabled = false;
        newXSprite.src = 'assets/sprites/New_New_X.png';

        const yellowXSprite = new Image();
        yellowXSprite.imageSmoothingEnabled = false;
        yellowXSprite.src = 'assets/sprites/Yellow_X.png';

        const newBushSprite = new Image();
        newBushSprite.imageSmoothingEnabled = false;
        newBushSprite.src = 'assets/sprites/New_Bush.png';

        const tallGrassSprite = new Image();
        tallGrassSprite.imageSmoothingEnabled = false;
        tallGrassSprite.src = 'assets/sprites/Tall_Grass.png';

        // Function to regenerate tiles that use sprites (optimized - only regenerates when needed)
        // Deferred to avoid blocking the main thread during load
        let tileRegenerationScheduled = false;
        function regenerateTiles(immediate = false) {
          // If immediate flag is set, regenerate synchronously (for restarts)
          // Otherwise defer regeneration to avoid blocking during sprite load
          if (!immediate) {
            if (tileRegenerationScheduled) return;
            tileRegenerationScheduled = true;

            // Use requestAnimationFrame to defer to next frame, allowing page to be interactive
            requestAnimationFrame(() => {
              doRegenerateTiles();
              tileRegenerationScheduled = false;
            });
          } else {
            // Immediate regeneration (synchronous)
            doRegenerateTiles();
          }
        }

        function doRegenerateTiles() {
          // Check if tileMap exists (it's created later in the code)
          if (typeof tileMap === 'undefined') {
            return; // tileMap not created yet, skip regeneration
          }

          // Only regenerate tiles that use sprites (grass, flowers, and tiles with grass base)
          const spriteTileNames = [
            'grass',
            'moundedBush',
            'singleRock',
            'rockCluster',
            'redX',
            'secretX',
            'logRows',
          ];

          for (let row = 0; row < tileRows; row++) {
            for (let col = 0; col < tileCols; col++) {
              const tile = tileMap[row][col];
              if (tile && spriteTileNames.includes(tile.name)) {
                // Find the original tile definition
                const def = tileDefinitions.find((d) => d.name === tile.name);
                if (def) {
                  // Regenerate the canvas with the now-loaded sprites
                  // Preserve rotation for grass tiles
                  const oldTile = tileMap[row][col];
                  const rotation =
                    oldTile && oldTile.grassRotation !== undefined
                      ? oldTile.grassRotation
                      : 0;
                  tileMap[row][col] = {
                    name: def.name,
                    canvas: createTileCanvas((ctx) => def.draw(ctx, rotation)),
                    grassRotation: rotation, // Preserve rotation
                  };
                }
              }
            }
          }
        }

        // Regenerate tiles when grass sprite loads (deferred)
        grassSprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when flower sprite loads (deferred)
        flowerSprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when rock sprites load (deferred)
        rock1Sprite.onload = function () {
          regenerateTiles();
        };

        rock2Sprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when New_X sprite loads (deferred)
        newXSprite.onload = function () {
          regenerateTiles();
        };

        newBushSprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when tall grass sprite loads (deferred)
        tallGrassSprite.onload = function () {
          regenerateTiles();
        };

        // If sprite is already loaded (cached), regenerate tiles immediately
        if (grassSprite.complete && grassSprite.naturalWidth > 0) {
          // Sprite already loaded, but tiles haven't been created yet
          // We'll regenerate after tiles are created (see below)
        }

        // Optimize sprite loading: set imageSmoothingEnabled before src
        const oldGuySprite = new Image();
        oldGuySprite.imageSmoothingEnabled = false;
        oldGuySprite.src = 'assets/sprites/oldguy.png';

        // Warning Guy NPC sprite (new character on the left of spawn)
        const warningGuySprite = new Image();
        warningGuySprite.imageSmoothingEnabled = false;
        // Note: the actual file in assets is named "Warning_guy.png.png"
        // so we point directly to that filename here.
        warningGuySprite.src = 'assets/sprites/Warning_guy.png.png';

        const shopkeeperSprite = new Image();
        shopkeeperSprite.imageSmoothingEnabled = false;
        shopkeeperSprite.src = 'assets/sprites/shopkeeper.png';

        const curatorSprite = new Image();
        curatorSprite.imageSmoothingEnabled = false;
        curatorSprite.src = 'assets/sprites/Museum_Curator.png';

        const cannonBuffSprite = new Image();
        cannonBuffSprite.imageSmoothingEnabled = false;
        cannonBuffSprite.src = 'assets/sprites/Cannon_buff.png';

        // Minigame reward sprites
        const bulletsSprite = new Image();
        bulletsSprite.imageSmoothingEnabled = false;
        bulletsSprite.src = 'assets/sprites/Bullets.png';

        const grapeshotSprite = new Image();
        grapeshotSprite.imageSmoothingEnabled = false;
        grapeshotSprite.src = 'assets/sprites/Grapeshot.png';

        const rustyNailsSprite = new Image();
        rustyNailsSprite.imageSmoothingEnabled = false;
        rustyNailsSprite.src = 'assets/sprites/Rusty_Nails.png';

        const forkSprite = new Image();
        forkSprite.imageSmoothingEnabled = false;
        forkSprite.src = 'assets/sprites/Fork.png';

        const pinSprite = new Image();
        pinSprite.imageSmoothingEnabled = false;
        pinSprite.src = 'assets/sprites/Pin.png';

        const canteenSprite = new Image();
        canteenSprite.imageSmoothingEnabled = false;
        canteenSprite.src = 'assets/sprites/Canteen.png';

        const arrowheadSprite = new Image();
        arrowheadSprite.imageSmoothingEnabled = false;
        arrowheadSprite.src = 'assets/sprites/Arrowhead.png';

        const cannonSprite = new Image();
        cannonSprite.imageSmoothingEnabled = false;
        cannonSprite.src = 'assets/sprites/Cannon.png';

        const cartridgeSprite = new Image();
        cartridgeSprite.imageSmoothingEnabled = false;
        cartridgeSprite.src = 'assets/sprites/Cartridge.png';

        const cannonShardsSprite = new Image();
        cannonShardsSprite.imageSmoothingEnabled = false;
        cannonShardsSprite.src = 'assets/sprites/Cannon_shards.png';

        const buttonsSprite = new Image();
        buttonsSprite.imageSmoothingEnabled = false;
        buttonsSprite.src = 'assets/sprites/Buttons.png';

        const quickShoesSprite = new Image();
        quickShoesSprite.imageSmoothingEnabled = false;
        quickShoesSprite.src = 'assets/sprites/Quick_shoes.png';

        // Museum sprites
        const displaySprite = new Image();
        displaySprite.imageSmoothingEnabled = false;
        displaySprite.src = 'assets/sprites/Display.png';
        const floorTileSprite = new Image();
        floorTileSprite.imageSmoothingEnabled = false;
        floorTileSprite.src = 'assets/sprites/Floor_Tile.png';

        const wallTileSprite = new Image();
        wallTileSprite.imageSmoothingEnabled = false;
        wallTileSprite.src = 'assets/sprites/Wall_Tile.png';

        const wallDoorSprite = new Image();
        wallDoorSprite.imageSmoothingEnabled = false;
        wallDoorSprite.src = 'assets/sprites/Wall_Door.png';

        const cannonDisplaySprite = new Image();
        cannonDisplaySprite.imageSmoothingEnabled = false;
        cannonDisplaySprite.src = 'assets/sprites/Cannon_display.png';

        // Trophy sprite for achievements
        const trophySprite = new Image();
        trophySprite.imageSmoothingEnabled = false;
        trophySprite.src = 'assets/sprites/Trophy.png';

        // Achievement icon sprites (radar and cannon for specific achievements)
        const radarIconSprite = new Image();
        radarIconSprite.imageSmoothingEnabled = false;
        radarIconSprite.src = 'assets/sprites/Radar.png';

        const cannonIconSprite = new Image();
        cannonIconSprite.imageSmoothingEnabled = false;
        cannonIconSprite.src = 'assets/sprites/Cannon.png';

        // Load player sprites from PNG images
        const playerSpriteIdle = new Image();
        playerSpriteIdle.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteIdle.src = 'assets/sprites/player.png';

        const playerSpriteBack = new Image();
        playerSpriteBack.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteBack.src = 'assets/sprites/player_back.png';

        const playerSpriteBackWalk1 = new Image();
        playerSpriteBackWalk1.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteBackWalk1.src = 'assets/sprites/player_back_walk1.png';

        const playerSpriteBackWalk2 = new Image();
        playerSpriteBackWalk2.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteBackWalk2.src = 'assets/sprites/player_back_walk2.png';

        const playerSpriteWalk1 = new Image();
        playerSpriteWalk1.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteWalk1.src = 'assets/sprites/player_walk1.png';

        const playerSpriteWalk2 = new Image();
        playerSpriteWalk2.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteWalk2.src = 'assets/sprites/player_walk2.png';

        const playerSpriteCrouch1 = new Image();
        playerSpriteCrouch1.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteCrouch1.src = 'assets/sprites/crouch-one.png';

        const playerSpriteCrouch2 = new Image();
        playerSpriteCrouch2.src = 'assets/sprites/crouch-two.png';
        playerSpriteCrouch2.imageSmoothingEnabled = false; // Pixelated rendering

        // Celebration animation sprites
        const playerSpriteRaisedHands = new Image();
        playerSpriteRaisedHands.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteRaisedHands.src = 'assets/sprites/Raised_hands.png';

        const starSprite = new Image();
        starSprite.imageSmoothingEnabled = false; // Pixelated rendering
        starSprite.src = 'assets/sprites/Star.png';

        // Walking animation state
        let walkAnimationFrame = 0;
        const walkAnimationSpeed = 0.15; // How fast the animation cycles (lower = faster)

        // Crouch animation state (plays before starting minigame)
        const crouchAnimation = {
          active: false,
          timer: 0,
          duration: 1.0, // 1 second
          pendingMinigame: null, // Stores which minigame to start after animation
          particles: [], // Particle effects during animation
        };

        // Celebration animation state (plays after completing minigame)
        // Shows player holding artifact over head with spinning star behind it
        const celebrationAnimation = {
          active: false,
          timer: 0,
          duration: 2.25, // 2.25 seconds (reduced by 0.25 seconds)
          artifact: null, // Stores the artifact that was just received: {name, sprite}
          starRotation: 0, // Current rotation angle of the star (in radians)
        };

        function createTileCanvas(drawFn) {
          // Create canvas with 1px overlap to eliminate seams between tiles
          // This technique ensures tiles can overlap slightly without stretching
          const overlap = 1;
          const buffer = document.createElement('canvas');
          buffer.width = tileSize + overlap;
          buffer.height = tileSize + overlap;
          const bctx = buffer.getContext('2d');
          if (!bctx) {
            console.error('Failed to get 2d context for tile canvas');
            return buffer; // Return empty canvas if context creation fails
          }
          // Disable image smoothing for pixel art
          bctx.imageSmoothingEnabled = false;
          // Draw the tile content (drawFn draws in the tileSize x tileSize area)
          drawFn(bctx);
          // Copy edges for seamless tiling (only if not blocked by CORS)
          // When loading from file:// URLs, getImageData can fail due to CORS restrictions
          // Wrap in try-catch to handle gracefully
          try {
            // Copy the rightmost column (column tileSize - 1) to the overlap column (column tileSize)
            // This creates seamless tiling: when adjacent tiles are drawn, they overlap by 1px
            // The rightmost pixel of each tile is the same as the leftmost visible pixel of the next tile
            const rightEdge = bctx.getImageData(tileSize - 1, 0, 1, tileSize);
            bctx.putImageData(rightEdge, tileSize, 0);
            // Copy the bottommost row (row tileSize - 1) to the overlap row (row tileSize)
            const bottomEdge = bctx.getImageData(0, tileSize - 1, tileSize, 1);
            bctx.putImageData(bottomEdge, 0, tileSize);
            // Copy the corner pixel for the bottom-right overlap
            const corner = bctx.getImageData(tileSize - 1, tileSize - 1, 1, 1);
            bctx.putImageData(corner, tileSize, tileSize);
          } catch (e) {
            // CORS error when loading from file:// URLs - skip edge copying
            // Tiles will still work, just without 1px overlap seam elimination
          }
          return buffer;
        }

        const colors = {
          grassBase: '#28a933',
          grassBright: '#36c843',
          grassDark: '#1e902a',
          outline: '#0c0c0c',
          rockLight: '#c2c2c2',
          rockMid: '#959595',
          rockDark: '#5f5f5f',
          rockShadow: '#3f3f3f',
          moundOuter: '#0c3f16',
          moundInner: '#0f5c1f',
          moundHighlight: '#157f2d',
          logLight: '#147429',
          logDark: '#0e5a20',
          logShadow: '#094217',
          redDark: '#780808',
          redBase: '#c40f0f',
          redBright: '#ff2a2a',
        };

        function fillCell(ctx, cx, cy, color) {
          ctx.fillStyle = color;
          ctx.fillRect(cx * tileCell, cy * tileCell, tileCell, tileCell);
        }

        function drawPlus(ctx, cx, cy, color) {
          fillCell(ctx, cx, cy, color);
          fillCell(ctx, cx - 1, cy, color);
          fillCell(ctx, cx + 1, cy, color);
          fillCell(ctx, cx, cy - 1, color);
          fillCell(ctx, cx, cy + 1, color);
        }

        function paintGrassBase(ctx, plusLayout) {
          ctx.fillStyle = colors.grassBase;
          ctx.fillRect(0, 0, tileSize, tileSize);
          const layout = plusLayout || [
            { x: 2, y: 2, color: colors.grassBright },
            { x: 5, y: 4, color: colors.grassBright },
            { x: 1, y: 5, color: colors.grassDark },
            { x: 6, y: 1, color: colors.grassDark },
          ];
          layout.forEach((plus) => drawPlus(ctx, plus.x, plus.y, plus.color));
        }

        const tileDefinitions = [
          {
            name: 'grass',
            weight: 110,
            draw(ctx, rotation = 0) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                // Apply random rotation (0, 90, 180, or 270 degrees)
                if (rotation !== 0) {
                  ctx.save();
                  ctx.translate(tileSize / 2, tileSize / 2);
                  ctx.rotate((rotation * Math.PI) / 180);
                  ctx.drawImage(
                    grassSprite,
                    -tileSize / 2,
                    -tileSize / 2,
                    tileSize,
                    tileSize,
                  );
                  ctx.restore();
                } else {
                  ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
                }
              } else {
                // Fallback: draw grass base color if sprite not loaded yet
                paintGrassBase(ctx);
              }
            },
          },
          {
            name: 'singleRock',
            weight: 10,
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw Rock_1 sprite on top of grass
              if (rock1Sprite.complete && rock1Sprite.naturalWidth > 0) {
                ctx.drawImage(rock1Sprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'rockCluster',
            weight: 8,
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              } else {
                // Fallback: draw grass base color if sprite not loaded yet
                paintGrassBase(ctx);
              }
              // Draw Rock_2 sprite on top of grass
              if (rock2Sprite.complete && rock2Sprite.naturalWidth > 0) {
                ctx.drawImage(rock2Sprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'moundedBush',
            weight: 7,
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw New_Bush sprite on top of grass
              if (newBushSprite.complete && newBushSprite.naturalWidth > 0) {
                ctx.drawImage(newBushSprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'logRows',
            weight: 5,
            draw(ctx) {
              // Always use grass sprite as base (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              } else {
                // Fallback: draw grass base color if sprite not loaded yet
                paintGrassBase(ctx);
              }
              // Draw tall grass sprite instead of logs
              // Position tall grass sprite in the center of the tile
              if (
                tallGrassSprite.complete &&
                tallGrassSprite.naturalWidth > 0
              ) {
                ctx.drawImage(tallGrassSprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'redX',
            weight: 3, // Slightly increased to make X's a tiny bit more common
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw New_New_X sprite on top of grass (no darkening needed)
              if (newXSprite.complete && newXSprite.naturalWidth > 0) {
                ctx.drawImage(newXSprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'secretX',
            weight: 3, // Slightly increased to make X's a tiny bit more common
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              // Secret X tiles: base is grass only (yellow X is drawn later if radar is active)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              } else {
                // Fallback: draw grass base color if sprite not loaded yet
                paintGrassBase(ctx);
              }
            },
          },
        ];

        const tileWeightTotal = tileDefinitions.reduce(
          (sum, t) => sum + t.weight,
          0,
        );

        function pickTileDefinition() {
          let roll = Math.random() * tileWeightTotal;
          for (const def of tileDefinitions) {
            if ((roll -= def.weight) <= 0) {
              return def;
            }
          }
          return tileDefinitions[0];
        }

        // Helper function to check if a tile position overlaps with any tree
        function isTreeAtTile(row, col) {
          const tileCenterX = (col + 0.5) * tileSize;
          const tileCenterY = (row + 0.5) * tileSize;

          for (let i = 0; i < flora.trees.length; i++) {
            const tree = flora.trees[i];
            const dx = tree.x - tileCenterX;
            const dy = tree.y - tileCenterY;
            const distSq = dx * dx + dy * dy;
            const treeRadius = tree.colliderRadius || tree.size * 0.42;
            const minDistSq =
              (tileSize / 2 + treeRadius) * (tileSize / 2 + treeRadius);

            if (distSq < minDistSq) {
              return true;
            }
          }
          return false;
        }

        // Helper function to check if a tile position overlaps with NPCs
        function isNpcAtTile(row, col) {
          const tileCenterX = (col + 0.5) * tileSize;
          const tileCenterY = (row + 0.5) * tileSize;
          const npcKeys = Object.keys(npcSpawnPoints);

          for (let i = 0; i < npcKeys.length; i++) {
            const npc = npcSpawnPoints[npcKeys[i]];
            const dx = npc.x - tileCenterX;
            const dy = npc.y - tileCenterY;
            const npcRadius = npc.radius || tileSize * 0.5;
            const minDist = tileSize / 2 + npcRadius;
            if (dx * dx + dy * dy < minDist * minDist) {
              return true;
            }
          }
          return false;
        }

        // Function to generate tiles (used at start and when resetting days)
        function generateTiles() {
          const newTileMap = [];
          for (let row = 0; row < tileRows; row++) {
            newTileMap[row] = [];
            for (let col = 0; col < tileCols; col++) {
              let def = pickTileDefinition();

              // If redX or secretX tile was picked and there's a tree at this position, replace with grass
              if (
                (def.name === 'redX' || def.name === 'secretX') &&
                (isTreeAtTile(row, col) || isNpcAtTile(row, col))
              ) {
                def = tileDefinitions.find((d) => d.name === 'grass');
              }

              // No rotation for grass tiles to ensure seamless tiling
              // Random rotations cause adjacent tiles to have mismatched edges, creating visible seams
              // Keeping all grass tiles at 0 rotation ensures edges align perfectly
              let grassRotation = 0;

              newTileMap[row][col] = {
                name: def.name,
                canvas: createTileCanvas((ctx) => def.draw(ctx, grassRotation)),
                grassRotation: grassRotation, // Store rotation for reference
              };
            }
          }
          return newTileMap;
        }

        // Generate initial tiles
        let tileMap = generateTiles();

        // If sprites were already loaded before tiles were created, regenerate now
        if (
          (grassSprite.complete && grassSprite.naturalWidth > 0) ||
          (flowerSprite.complete && flowerSprite.naturalWidth > 0)
        ) {
          regenerateTiles();
        }

        const player = {
          x: world.width / 2,
          y: world.height - 40,
          width: 43,
          height: 43,
          color: '#7cffb3', // Original teal/green player color
          outline: '#0c2a19',
          vx: 0,
          vy: 0,
          maxSpeed: 2.0,
          accel: 0.25,
          friction: 0.86,
          sprintMultiplier: 1.6,
          radius: Math.max(39, 39) * 0.5, // Cache radius calculation
        };

        // Stamina system for sprinting
        const stamina = {
          current: 100,
          max: 100,
          drainPerSecond: 35, // how fast stamina drains while sprinting (base value)
          regenPerSecond: 22, // how fast stamina regenerates when not sprinting
          minToSprint: 8, // must have at least this much to initiate sprint
          exhausted: false, // when true, cannot sprint until fully recovered
          hasShoes: false, // Track if player has received shoes from cannonBuff (reduces drain by 50%)
        };

        // Cache gradients for stamina bar (created once, reused)
        let staminaBarGradients = null;
        function initStaminaGradients() {
          if (staminaBarGradients) return; // Already initialized
          const barW = 220;
          const barX = 16.5;
          const normalGradient = ctx.createLinearGradient(
            barX,
            0,
            barX + barW,
            0,
          );
          normalGradient.addColorStop(0, '#51ff8a'); // Original teal/green
          normalGradient.addColorStop(1, '#7cffb3'); // Original teal/green
          const exhaustedGradient = ctx.createLinearGradient(
            barX,
            0,
            barX + barW,
            0,
          );
          exhaustedGradient.addColorStop(0, '#ff4d4f');
          exhaustedGradient.addColorStop(1, '#ff7875');
          staminaBarGradients = {
            normal: normalGradient,
            exhausted: exhaustedGradient,
          };
        }

        // Game over state removed - not triggerable without money system

        // System message (no character name, skippable)
        const systemMessage = {
          text: null, // Current system message text
        };

        // Tutorial dialogue system
        const tutorial = {
          active: false, // Tutorial disabled - oldGuy shows first dialogue instead
          dialogue: 'Hey! Over here!',
        };

        // Old Guy NPC (positioned to the right of spawn)
        const oldGuy = {
          x: npcSpawnPoints.oldGuy.x,
          y: npcSpawnPoints.oldGuy.y,
          radius: npcSpawnPoints.oldGuy.radius,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // Track which dialogue to show (0-5 for initial sequence)
          hasCompletedIntro: false, // Track if player has completed initial dialogue sequence
        };

        // Warning Guy NPC (positioned to the left of spawn)
        const warningGuy = {
          x: npcSpawnPoints.warningGuy.x,
          y: npcSpawnPoints.warningGuy.y,
          radius: npcSpawnPoints.warningGuy.radius,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // 0-3 for first conversation, 1 for repeat line
          hasCompletedIntro: false, // After first full conversation
        };

        // Joseph NPC (shopkeeper with radar, positioned centrally)
        const joseph = {
          x: npcSpawnPoints.joseph.x,
          y: npcSpawnPoints.joseph.y,
          radius: npcSpawnPoints.joseph.radius,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // Track dialogue progress (0-5)
          hasGivenRadar: false, // Track if player has received radar
          selectingArtifact: false, // Track if player is selecting artifact to give
        };

        // Museum Curator NPC (positioned in museum)
        const curator = {
          x: 0, // Will be set in initializeMuseum
          y: 0, // Will be set in initializeMuseum
          radius: 20,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // Dialogue stage (0-6 for has artifacts, 0-2 for no artifacts)
          dialogueTimer: 0, // Timer for auto-closing dialogue
          hasCompletedIntro: false, // Track if player has completed initial dialogue sequence
        };

        // Cannon Buff NPC (positioned in museum, next to cannon display)
        const cannonBuff = {
          x: 0, // Will be set in initializeMuseum
          y: 0, // Will be set in initializeMuseum
          radius: 20,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // Dialogue stage (0-4 for intro, 0 for repeat)
          dialogueTimer: 0, // Timer for auto-closing dialogue
          hasCompletedIntro: false, // Track if player has seen initial dialogue
          hasGivenReward: false, // Track if player has received shoes reward
        };

        // Inventory system
        const inventory = {
          open: false,
          slots: Array(25).fill(null), // 25 inventory slots (increased from 15)
          equipment: null, // 1 equipment slot
          speedBrush: false, // Track if Speed Brush is owned (equipment slot only, not inventory)
          selectedSlotIndex: null, // Track which slot is selected for deletion
        };

        const keys = Object.create(null);
        const keyJustPressed = Object.create(null); // Track keys that were just pressed this frame
        const pressed = (code) => keys[code] === true;

        // Start a fresh game after the controls screen
        // Kept in a function so we can run it after the controls screen closes
        function startNewGameFromControls() {
          // Initialize day/time system for new game
          dayTime.currentDay = 0; // Start on Monday
          dayTime.currentHour = 8; // Start at start of Monday (8 AM)
          dayTime.hourTimer = 0;

          // Reset player position
          player.x = world.width / 2;
          player.y = world.height - 40;
          player.vx = 0;
          player.vy = 0;

          // Reset camera
          camera.x = player.x;
          camera.y = player.y;

          // Regenerate tiles (randomize X's) and ensure sprites are loaded
          tileMap = generateTiles();
          tileRegenerationScheduled = false; // Reset flag to allow regeneration
          // Force immediate regeneration to ensure all sprite-based tiles render
          doRegenerateTiles(); // Call directly to ensure it happens synchronously

          // Also reset radar discoveries when starting a completely new game.
          // This prevents old yellow X markers from carrying over between runs.
          radar.discoveredSecretX = [];
          radar.rings = [];

          // Reset museum state
          museum.doorPrompt = false;
          museum.wasNearDoor = false;
          museum.buildMode = false;
          museum.cannonDisplay = null;
          museum.displayCases = [];
          museum.hasInitializedDisplays = false;

          // Start the game
          gameState = 'playing';

          // Save the new game
          if (currentSaveSlot !== null) {
            saveGame(currentSaveSlot);
          }
        }

        window.addEventListener(
          'keydown',
          (e) => {
            if (!keys[e.code]) {
              keyJustPressed[e.code] = true; // Mark as just pressed
            }
            keys[e.code] = true;
            // Prevent arrow keys from scrolling
            if (
              [
                'ArrowUp',
                'ArrowDown',
                'ArrowLeft',
                'ArrowRight',
                'Space',
              ].includes(e.code)
            ) {
              e.preventDefault();
            }
            // Toggle inventory with E (or build mode in museum)
            if (e.code === 'KeyE') {
              e.preventDefault();
              // In museum, E toggles build mode instead of inventory
              if (gameState === 'museum') {
                // Only toggle if this is a new key press (not held)
                if (keyJustPressed['KeyE']) {
                  museum.buildMode = !museum.buildMode;
                }
                return;
              }
              // Don't allow opening inventory during minigame
              if (
                brushingMinigame.active ||
                minesweeperMinigame.active ||
                typoMinigame.active
              ) {
                return;
              }
              const wasOpen = inventory.open;
              inventory.open = !inventory.open;
              // Kill momentum when opening inventory
              if (!wasOpen && inventory.open) {
                player.vx = 0;
                player.vy = 0;
              }
            }

            // Interaction key Spacebar
            if (e.code === 'Space') {
              e.preventDefault();
              // Don't allow interaction during crouch animation or minigames (minigames use spacebar for their own mechanics)
              if (
                crouchAnimation.active ||
                brushingMinigame.active ||
                minesweeperMinigame.active ||
                typoMinigame.active
              ) {
                return;
              }
              // If tutorial is active, close it immediately on Space.
              // This avoids requiring a "fresh" key press to dismiss the popup.
              if (tutorial.active && gameState !== 'museum') {
                tutorial.active = false;
                player.vx = 0;
                player.vy = 0;
                return;
              }
              // Only process dialogue/interaction on key press, not while held
              // This prevents dialogue from skipping too fast when holding spacebar
              if (!keyJustPressed['Space']) {
                return; // Key already processed this frame
              }
              // If dialogue is showing, advance it (only once per key press)
              if (
                systemMessage.text ||
                oldGuy.dialogue ||
                warningGuy.dialogue ||
                joseph.dialogue ||
                curator.dialogue ||
                cannonBuff.dialogue
              ) {
                // System messages can always be closed with spacebar
                if (systemMessage.text) {
                  systemMessage.text = null;
                } else if (oldGuy.dialogue) {
                  advanceOldGuyDialogue(); // Advance through dialogue stages
                  player.vx = 0;
                  player.vy = 0;
                } else if (warningGuy.dialogue) {
                  advanceWarningGuyDialogue();
                  player.vx = 0;
                  player.vy = 0;
                } else if (joseph.dialogue) {
                  advanceJosephDialogue();
                  player.vx = 0;
                  player.vy = 0;
                } else if (curator.dialogue) {
                  advanceCuratorDialogue();
                  player.vx = 0;
                  player.vy = 0;
                } else if (cannonBuff.dialogue) {
                  advanceCannonBuffDialogue();
                  player.vx = 0;
                  player.vy = 0;
                }
              } else {
                // Try to interact (curator in museum, or other NPCs in playing state)
                // Check curator directly in museum state, otherwise use handleInteraction
                if (gameState === 'museum') {
                  // Direct curator interaction check - use fixed distance for reliability
                  const dx = player.x - curator.x;
                  const dy = player.y - curator.y;
                  const distSq = dx * dx + dy * dy;
                  // Use fixed interaction distance of 50 pixels
                  const interactionDistSq = 50 * 50;

                  if (distSq <= interactionDistSq) {
                    const hasArtifacts = inventory.slots.some(
                      (slot) => slot !== null,
                    );

                    if (hasArtifacts) {
                      curator.dialogue =
                        'Hello there! I see you have some artifacts.';
                      curator.dialogueStage = 0; // Start at 0, advanceCuratorDialogue will increment to 1
                    } else {
                      curator.dialogue =
                        "Looks like you don't have anything to put in your museum.";
                      curator.dialogueStage = 0; // Start at 0, advanceCuratorDialogue will increment to 1
                    }
                    curator.dialogueTimer = 0;
                    player.vx = 0;
                    player.vy = 0;
                    return;
                  }

                  // Check cannonBuff interaction - use fixed distance for reliability
                  const cannonDx = player.x - cannonBuff.x;
                  const cannonDy = player.y - cannonBuff.y;
                  const cannonDistSq =
                    cannonDx * cannonDx + cannonDy * cannonDy;

                  if (cannonDistSq <= interactionDistSq) {
                    // Check if cannon is placed in museum
                    const hasCannon =
                      museum.cannonDisplay &&
                      museum.cannonDisplay.artifact &&
                      museum.cannonDisplay.artifact.name === 'Cannon';

                    // Start cannonBuff dialogue sequence
                    if (hasCannon && !cannonBuff.hasGivenReward) {
                      // First talk after placing cannon
                      cannonBuff.dialogueStage = 0;
                      cannonBuff.dialogue =
                        "Wow! A cannon! I don't know how you did it, but here it is!";
                    } else if (hasCannon && cannonBuff.hasGivenReward) {
                      // After reward given
                      cannonBuff.dialogue = 'Good luck!';
                      cannonBuff.dialogueStage = 0;
                    } else if (!cannonBuff.hasCompletedIntro) {
                      // Initial intro dialogue - activate quest
                      cannonBuff.dialogueStage = 0;
                      cannonBuff.dialogue =
                        "Hello there! As you can tell, I'm a big fan of cannons.";
                      // Activate quest when first talking
                      if (!quests.getCannonForCannonBuff.active) {
                        quests.getCannonForCannonBuff.active = true;
                      }
                    } else {
                      // After intro, no cannon yet
                      cannonBuff.dialogue =
                        "Find and put a cannon in your museum, I'll make it worth your while!";
                      cannonBuff.dialogueStage = 0;
                    }
                    cannonBuff.dialogueTimer = 0;
                    player.vx = 0;
                    player.vy = 0;
                    return;
                  }
                } else {
                  // Use normal handleInteraction for playing state
                  handleInteraction();
                }
              }
            }

            // Shop controls removed - now uses mouse clicks only

            // Typo minigame: Uses buttons (merged with declaration minigame)

            // Day end: Space to continue to next day
            if (gameState === 'dayEnd' && e.code === 'Space') {
              e.preventDefault();
              startNewDay();
              return;
            }

            // Week end: Space to return to title
            if (gameState === 'weekEnd' && e.code === 'Space') {
              e.preventDefault();

              // Mark save as completed before returning to title
              if (currentSaveSlot !== null) {
                try {
                  const saveKey = `gameSave_slot${currentSaveSlot}`;
                  const saveDataStr = localStorage.getItem(saveKey);
                  if (saveDataStr) {
                    const saveData = JSON.parse(saveDataStr);
                    saveData.completed = true;
                    localStorage.setItem(saveKey, JSON.stringify(saveData));
                  }
                } catch (error) {
                  console.error('Failed to mark save as completed:', error);
                }
              }

              // Reset current save slot
              currentSaveSlot = null;

              // Return to title screen
              gameState = 'title';

              // Reset everything for new game (will be fully reset when starting from title)
              dayTime.currentDay = 0; // Start on Monday
              dayTime.currentHour = 8; // Start at 8:00 AM
              dayTime.hourTimer = 0;
              // Reset museum state
              museum.doorPrompt = false;
              museum.wasNearDoor = false;
              museum.buildMode = false;
              museum.cannonDisplay = null;
              museum.displayCases = [];
              museum.hasInitializedDisplays = false;
              return;
            }

            // Controls screen: Space to continue to game (only on key press, not hold)
            if (
              gameState === 'controls' &&
              e.code === 'Space' &&
              keyJustPressed['Space']
            ) {
              e.preventDefault();
              // Switch to a lightweight "starting" screen immediately
              // Heavy setup runs after the screen updates (feels snappier)
              gameState = 'starting';
              startGamePending = true;
              return;
            }
          },
          { passive: false },
        );

        window.addEventListener('keyup', (e) => {
          keys[e.code] = false;
          keyJustPressed[e.code] = false;
        });

        // Track mouse position for hover effects
        let mouseX = 0;
        let mouseY = 0;

        // Prevent the browser context menu while Minesweeper is active
        canvas.addEventListener('contextmenu', (e) => {
          if (minesweeperMinigame.active) {
            e.preventDefault();
          }
        });

        // Handle right clicks for Minesweeper (more reliable than contextmenu)
        canvas.addEventListener('mousedown', (e) => {
          if (e.button !== 2) return; // Right click only
          if (
            !minesweeperMinigame.active ||
            minesweeperMinigame.gameOver ||
            minesweeperMinigame.won
          ) {
            return;
          }

          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          const gridSize = minesweeperMinigame.gridSize;
          const cellSize = 50; // Match render function
          const panelPadding = 40;
          const gridAreaSize = gridSize * cellSize;
          const panelWidth = gridAreaSize + panelPadding * 2;
          const panelHeight = panelWidth; // Square panel
          const panelX = (canvas.width - panelWidth) / 2;
          const panelY = (canvas.height - panelHeight) / 2;
          const gridStartX = panelX + panelPadding;
          const gridStartY = panelY + panelPadding;

          // Check if click is within grid bounds
          if (
            x >= gridStartX &&
            x <= gridStartX + gridSize * cellSize &&
            y >= gridStartY &&
            y <= gridStartY + gridSize * cellSize
          ) {
            const col = Math.floor((x - gridStartX) / cellSize);
            const row = Math.floor((y - gridStartY) / cellSize);

            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
              handleMinesweeperClick(minesweeperMinigame, row, col, true);
            }
          }
        });

        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          // Account for canvas scaling - convert display coordinates to internal canvas coordinates
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          mouseX = (e.clientX - rect.left) * scaleX;
          mouseY = (e.clientY - rect.top) * scaleY;
        });

        // Mouse click handling for buttons
        canvas.addEventListener('click', (e) => {
          // Don't handle clicks if on title screen (title screen has its own handler)
          if (gameState === 'title') {
            return;
          }

          // If the tutorial popup is showing, ignore ALL canvas clicks.
          // This makes the tutorial behave like a proper modal:
          //  - Player can only close it with Space (handled in keydown)
          //  - Minigames and other UI cannot be clicked "through" it
          if (tutorial.active && dayTime.currentDay === 0) {
            return;
          }

          const rect = canvas.getBoundingClientRect();
          // Account for canvas scaling - convert display coordinates to internal canvas coordinates
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          // Museum door prompt click handling
          if (gameState === 'museum' && museum.doorPrompt) {
            const panelWidth = 400;
            const panelHeight = 200;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;
            const buttonWidth = 120;
            const buttonHeight = 50;
            const buttonSpacing = 40;
            const continueButtonX =
              panelX + panelWidth / 2 - buttonWidth - buttonSpacing / 2;
            const stayButtonX = panelX + panelWidth / 2 + buttonSpacing / 2;
            const buttonY = panelY + panelHeight - buttonHeight - 30;

            // Check if clicking continue button
            if (
              x >= continueButtonX &&
              x <= continueButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              museum.doorPrompt = false;
              startNewDay();
              return;
            }

            // Check if clicking stay button
            if (
              x >= stayButtonX &&
              x <= stayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              museum.doorPrompt = false;
              return;
            }
          }

          // Typo minigame buttons (handles all text-based minigames)
          if (typoMinigame.active && !typoMinigame.answered) {
            // Prevent interaction when tutorial popup is active
            if (tutorial.active && dayTime.currentDay === 0) {
              return;
            }

            // Calculate button positions (same as in render function)
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            const buttonY = panelY + panelHeight - 80;
            const buttonWidth = 150;
            const buttonHeight = 40;
            const buttonSpacing = 20;
            const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
            const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

            // Display button (left)
            const displayButtonX = buttonStartX;
            if (
              x >= displayButtonX &&
              x <= displayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleTypoAnswer(true); // Display = Real
              return;
            }

            // Throw away button (right)
            const throwAwayButtonX = buttonStartX + buttonWidth + buttonSpacing;
            if (
              x >= throwAwayButtonX &&
              x <= throwAwayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleTypoAnswer(false); // Throw away = Fake
              return;
            }

            // Close button removed
          }

          // Quiz minigame buttons
          if (quizMinigame.active && !quizMinigame.answered) {
            // Prevent interaction when tutorial popup is active
            if (tutorial.active && dayTime.currentDay === 0) {
              return;
            }

            // Calculate button positions (same as in render function)
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            const buttonY = panelY + panelHeight - 80;
            const buttonWidth = 150;
            const buttonHeight = 40;
            const buttonSpacing = 20;
            const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
            const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

            // Yes button (left)
            const yesButtonX = buttonStartX;
            if (
              x >= yesButtonX &&
              x <= yesButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleQuizAnswer(true); // Yes
              return;
            }

            // No button (right)
            const noButtonX = buttonStartX + buttonWidth + buttonSpacing;
            if (
              x >= noButtonX &&
              x <= noButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleQuizAnswer(false); // No
              return;
            }
          }

          // Build mode click handling (select artifacts and place in display cases)
          if (gameState === 'museum' && museum.buildMode) {
            // First, check if player clicked the build mode inventory panel
            const buildLayout = getBuildModeInventoryLayout();

            // Check if clicking on red X delete button (bottom right of panel)
            const deleteButtonSize = 32;
            const deleteButtonX =
              buildLayout.panelX +
              buildLayout.panelWidth -
              deleteButtonSize -
              8;
            const deleteButtonY =
              buildLayout.panelY +
              buildLayout.panelHeight -
              deleteButtonSize -
              8;

            if (
              x >= deleteButtonX &&
              x <= deleteButtonX + deleteButtonSize &&
              y >= deleteButtonY &&
              y <= deleteButtonY + deleteButtonSize
            ) {
              // Check if an artifact slot is selected
              if (museum.selectedArtifactIndex !== null) {
                const selectedItem =
                  inventory.slots[museum.selectedArtifactIndex];
                if (selectedItem && selectedItem.type === 'artifact') {
                  // Delete the selected artifact
                  inventory.slots[museum.selectedArtifactIndex] = null;
                  museum.selectedArtifactIndex = null; // Clear selection
                }
              }
              return;
            }

            if (
              x >= buildLayout.panelX &&
              x <= buildLayout.panelX + buildLayout.panelWidth &&
              y >= buildLayout.panelY &&
              y <= buildLayout.panelY + buildLayout.panelHeight
            ) {
              const slotSize = buildLayout.slotSize;
              const slotSpacing = buildLayout.slotSpacing;
              const slotsStartX = buildLayout.slotsStartX;
              const slotsStartY = buildLayout.slotsStartY;
              const slotsPerRow = buildLayout.slotsPerRow;
              const rows = buildLayout.rows;

              // Check if click is inside the slots grid area
              const slotsWidth =
                slotsPerRow * slotSize + (slotsPerRow - 1) * slotSpacing;
              const slotsHeight = rows * slotSize + (rows - 1) * slotSpacing;

              if (
                x >= slotsStartX &&
                x <= slotsStartX + slotsWidth &&
                y >= slotsStartY &&
                y <= slotsStartY + slotsHeight
              ) {
                const col = Math.floor(
                  (x - slotsStartX) / (slotSize + slotSpacing),
                );
                const row = Math.floor(
                  (y - slotsStartY) / (slotSize + slotSpacing),
                );
                const index = row * slotsPerRow + col;
                const artifacts = buildLayout.artifacts;

                if (index >= 0 && index < artifacts.length) {
                  // Select this artifact (store the real inventory slot index)
                  museum.selectedArtifactIndex = artifacts[index].slotIndex;
                } else {
                  // Clicked an empty slot -> clear selection
                  museum.selectedArtifactIndex = null;
                }
              }
              return;
            }

            const museumTileSize = tileSize;
            const museumWorldWidth = museum.width * museumTileSize;
            const museumWorldHeight = museum.height * museumTileSize;
            const offsetX = (canvas.width - museumWorldWidth) / 2;
            const offsetY = canvas.height - museumWorldHeight;

            // Convert screen coordinates to museum world coordinates
            const museumX = x - offsetX;
            const museumY = y - offsetY;

            // Check if click is within museum bounds
            if (
              museumX >= 0 &&
              museumX < museumWorldWidth &&
              museumY >= 0 &&
              museumY < museumWorldHeight
            ) {
              // Find which display case was clicked
              const clickedCol = Math.floor(museumX / museumTileSize);
              const clickedRow = Math.floor(museumY / museumTileSize);

              // Check if cannon display was clicked (special 1x2 display at row 6, cols 7-8)
              const cannonRow = Math.floor(museum.height / 2) - 2; // Row 6
              const leftCannonCol = Math.floor(museum.width / 2) - 1; // Col 7
              const rightCannonCol = leftCannonCol + 1; // Col 8

              if (
                clickedRow === cannonRow &&
                (clickedCol === leftCannonCol || clickedCol === rightCannonCol)
              ) {
                // Clicked on cannon display
                const selectedIndex = museum.selectedArtifactIndex;
                const selectedItem =
                  selectedIndex !== null
                    ? inventory.slots[selectedIndex]
                    : null;

                if (museum.cannonDisplay && museum.cannonDisplay.artifact) {
                  // Try to remove cannon artifact back into inventory
                  const added = addItemToInventory(
                    museum.cannonDisplay.artifact.name,
                    museum.cannonDisplay.artifact.sprite,
                  );
                  if (added) {
                    museum.cannonDisplay.artifact = null;
                    museum.selectedArtifactIndex = null;
                  }
                } else if (
                  selectedItem &&
                  selectedItem.type === 'artifact' &&
                  selectedItem.name === 'Cannon'
                ) {
                  // Place cannon in cannon display (only Cannon can go here)
                  museum.cannonDisplay = {
                    artifact: {
                      name: selectedItem.name,
                      sprite: selectedItem.sprite,
                      tier:
                        selectedItem.tier || getArtifactTier(selectedItem.name),
                    },
                  };
                  // Remove from inventory and clear selection
                  inventory.slots[selectedIndex] = null;
                  museum.selectedArtifactIndex = null;
                }
              } else {
                // Check regular display cases
                for (let i = 0; i < museum.displayCases.length; i++) {
                  const displayCase = museum.displayCases[i];
                  if (
                    displayCase.row === clickedRow &&
                    displayCase.col === clickedCol
                  ) {
                    // Clicked on a regular display case
                    if (displayCase.artifact) {
                      // Try to remove artifact back into inventory
                      const added = addItemToInventory(
                        displayCase.artifact.name,
                        displayCase.artifact.sprite,
                      );
                      if (added) {
                        displayCase.artifact = null;
                        museum.selectedArtifactIndex = null;
                      }
                    } else {
                      // Place the selected artifact if possible (but not Cannon)
                      const selectedIndex = museum.selectedArtifactIndex;
                      const selectedItem =
                        selectedIndex !== null
                          ? inventory.slots[selectedIndex]
                          : null;

                      if (
                        selectedItem &&
                        selectedItem.type === 'artifact' &&
                        selectedItem.name !== 'Cannon'
                      ) {
                        // Place artifact in display case (Cannon cannot go in regular displays)
                        displayCase.artifact = {
                          name: selectedItem.name,
                          sprite: selectedItem.sprite,
                          tier:
                            selectedItem.tier ||
                            getArtifactTier(selectedItem.name),
                        };
                        // Remove from inventory and clear selection
                        inventory.slots[selectedIndex] = null;
                        museum.selectedArtifactIndex = null;
                      }
                    }
                    break;
                  }
                }
              }
            }
          }

          // Typo minigame clicks
          if (typoMinigame.active) {
            // Prevent interaction when tutorial popup is active
            if (tutorial.active && dayTime.currentDay === 0) {
              return;
            }

            // Check for question mark click first
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkSize = 34; // Slightly bigger for visibility
            const questionMarkPadding = 6;
            if (
              x >= questionMarkX - questionMarkPadding &&
              x <= questionMarkX + questionMarkSize + questionMarkPadding &&
              y >= questionMarkY - questionMarkSize - questionMarkPadding &&
              y <= questionMarkY + questionMarkPadding
            ) {
              // Toggle instructions
              typoMinigame.showInstructions = !typoMinigame.showInstructions;
              return;
            }

            // If instructions are showing, close them on any click
            if (typoMinigame.showInstructions) {
              const instructionsPanelWidth = 460;
              const instructionsPanelHeight = 200;
              const instructionsPanelX =
                (canvas.width - instructionsPanelWidth) / 2;
              const instructionsPanelY =
                (canvas.height - instructionsPanelHeight) / 2;
              // Close instructions on click
              typoMinigame.showInstructions = false;
              return;
            }
          }

          // Quiz minigame clicks
          if (quizMinigame.active) {
            // Prevent interaction when tutorial popup is active
            if (tutorial.active && dayTime.currentDay === 0) {
              return;
            }

            // If instructions are showing, close them on any click and block all other interactions
            if (quizMinigame.showInstructions) {
              // Close instructions on any click
              quizMinigame.showInstructions = false;
              return;
            }

            // Check for question mark click
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkSize = 34;
            const questionMarkPadding = 6;
            if (
              x >= questionMarkX - questionMarkPadding &&
              x <= questionMarkX + questionMarkSize + questionMarkPadding &&
              y >= questionMarkY - questionMarkSize - questionMarkPadding &&
              y <= questionMarkY + questionMarkPadding
            ) {
              // Toggle instructions
              quizMinigame.showInstructions = !quizMinigame.showInstructions;
              return;
            }

            if (!quizMinigame.answered) {
              // Calculate button positions (same as in render function)
              const panelWidth = 700;
              const panelHeight = 500;
              const panelX = (canvas.width - panelWidth) / 2;
              const panelY = (canvas.height - panelHeight) / 2;

              const buttonY = panelY + panelHeight - 80;
              const buttonWidth = 150;
              const buttonHeight = 40;
              const buttonSpacing = 20;
              const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
              const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

              // Display button (left)
              const displayButtonX = buttonStartX;
              if (
                x >= displayButtonX &&
                x <= displayButtonX + buttonWidth &&
                y >= buttonY &&
                y <= buttonY + buttonHeight
              ) {
                handleTypoAnswer(true); // Display = Real
                return;
              }

              // Throw away button (right)
              const throwAwayButtonX =
                buttonStartX + buttonWidth + buttonSpacing;
              if (
                x >= throwAwayButtonX &&
                x <= throwAwayButtonX + buttonWidth &&
                y >= buttonY &&
                y <= buttonY + buttonHeight
              ) {
                handleTypoAnswer(false); // Throw away = Fake
                return;
              }
            }
          }

          // Minesweeper minigame clicks (left click)
          if (minesweeperMinigame.active) {
            // Check for question mark click first (works even when game is over/won)
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkSize = 34; // Slightly bigger for visibility
            const questionMarkPadding = 6;
            if (
              x >= questionMarkX - questionMarkPadding &&
              x <= questionMarkX + questionMarkSize + questionMarkPadding &&
              y >= questionMarkY - questionMarkSize - questionMarkPadding &&
              y <= questionMarkY + questionMarkPadding
            ) {
              // Toggle instructions
              minesweeperMinigame.showInstructions =
                !minesweeperMinigame.showInstructions;
              return;
            }

            // If instructions are showing, close them on any click (except question mark)
            if (minesweeperMinigame.showInstructions) {
              // Check if click is outside the instructions panel
              const instructionsPanelWidth = 400;
              const instructionsPanelHeight = 200;
              const instructionsPanelX =
                (canvas.width - instructionsPanelWidth) / 2;
              const instructionsPanelY =
                (canvas.height - instructionsPanelHeight) / 2;

              if (
                x < instructionsPanelX ||
                x > instructionsPanelX + instructionsPanelWidth ||
                y < instructionsPanelY ||
                y > instructionsPanelY + instructionsPanelHeight
              ) {
                // Clicked outside instructions panel - close it
                minesweeperMinigame.showInstructions = false;
                return;
              }
              // Clicked inside instructions panel - don't do anything (let it stay open)
              return;
            }

            // Only handle grid clicks if game is active (not over/won)
            if (!minesweeperMinigame.gameOver && !minesweeperMinigame.won) {
              const gridSize = minesweeperMinigame.gridSize;
              const cellSize = 50; // Match render function
              const panelPadding = 40;
              const gridAreaSize = gridSize * cellSize;
              const panelWidth = gridAreaSize + panelPadding * 2;
              const panelHeight = panelWidth; // Square panel
              const panelX = (canvas.width - panelWidth) / 2;
              const panelY = (canvas.height - panelHeight) / 2;
              const gridStartX = panelX + panelPadding;
              const gridStartY = panelY + panelPadding;

              // Check if click is within grid bounds
              if (
                x >= gridStartX &&
                x <= gridStartX + gridSize * cellSize &&
                y >= gridStartY &&
                y <= gridStartY + gridSize * cellSize
              ) {
                const col = Math.floor((x - gridStartX) / cellSize);
                const row = Math.floor((y - gridStartY) / cellSize);

                if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
                  handleMinesweeperClick(minesweeperMinigame, row, col, false);
                }
              }
            }
          }

          // Brushing minigame clicks
          if (brushingMinigame.active) {
            // Prevent interaction when tutorial popup is active
            if (tutorial.active && dayTime.currentDay === 0) {
              return;
            }

            // Check for question mark click first
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkSize = 34; // Slightly bigger for visibility
            const questionMarkPadding = 6;
            if (
              x >= questionMarkX - questionMarkPadding &&
              x <= questionMarkX + questionMarkSize + questionMarkPadding &&
              y >= questionMarkY - questionMarkSize - questionMarkPadding &&
              y <= questionMarkY + questionMarkPadding
            ) {
              // Toggle instructions
              brushingMinigame.showInstructions =
                !brushingMinigame.showInstructions;
              return;
            }

            // If instructions are showing, close them on any click (except question mark)
            if (brushingMinigame.showInstructions) {
              // Check if click is outside the instructions panel
              const instructionsPanelWidth = 400;
              const instructionsPanelHeight = 200;
              const instructionsPanelX =
                (canvas.width - instructionsPanelWidth) / 2;
              const instructionsPanelY =
                (canvas.height - instructionsPanelHeight) / 2;

              if (
                x < instructionsPanelX ||
                x > instructionsPanelX + instructionsPanelWidth ||
                y < instructionsPanelY ||
                y > instructionsPanelY + instructionsPanelHeight
              ) {
                // Clicked outside instructions panel - close it
                brushingMinigame.showInstructions = false;
                return;
              }
              // Clicked inside instructions panel - don't do anything (let it stay open)
              return;
            }
          }

          // Inventory click handling (selecting artifacts for Joseph, etc.)
          if (inventory.open) {
            // Equipment items array (must match drawInventory)
            const equipmentItems = [
              {
                name: 'Radar',
                sprite: radarSprite,
                description: "Reveals hidden X's",
              },
              {
                name: 'Quick shoes',
                sprite: quickShoesSprite,
                description: 'Decreases stamina drain when sprinting',
              },
            ];

            const slotSize = 48;
            const slotSpacing = 4;
            const slotsPerRow = 5;
            const numRows = 5; // Match drawInventory (increased from 2 to 5)
            const panelPadding = 24;
            const equipmentSlotSize = 48; // Match drawInventory
            const equipmentRowSpacing = 4; // Match drawInventory
            const titleHeight = 40;
            const equipmentLabelHeight = 16;
            const equipmentSpacing = 30; // Match drawInventory
            const instructionsHeight = 30;

            // Calculate dimensions (match drawInventory)
            const equipmentRowWidth =
              equipmentItems.length * equipmentSlotSize +
              (equipmentItems.length - 1) * equipmentRowSpacing;
            const slotsAreaWidth =
              slotsPerRow * slotSize + (slotsPerRow - 1) * slotSpacing;
            const slotsAreaHeight =
              numRows * slotSize + (numRows - 1) * slotSpacing;
            const inventoryWidth =
              Math.max(equipmentRowWidth, slotsAreaWidth) + panelPadding * 2;
            const inventoryHeight =
              titleHeight +
              equipmentSlotSize +
              equipmentLabelHeight +
              equipmentSpacing +
              slotsAreaHeight +
              panelPadding * 2 +
              instructionsHeight;

            const panelX =
              Math.round(canvas.width / 2 - inventoryWidth / 2) + 0.5;
            const panelY =
              Math.round(canvas.height / 2 - inventoryHeight / 2) + 0.5;

            // Equipment row (match drawInventory)
            const equipmentRowStartX =
              panelX + inventoryWidth / 2 - equipmentRowWidth / 2;
            const equipmentY = panelY + titleHeight + 30; // Match drawInventory

            // Equipment slots are display-only (Quick shoes are always active when owned)

            // Artifacts slots (for other items)
            const artifactsLabelY =
              equipmentY +
              equipmentSlotSize +
              equipmentLabelHeight +
              equipmentSpacing;
            const slotsStartX = panelX + panelPadding;
            const slotsStartY = artifactsLabelY;

            // Check if clicking on red X delete button
            const deleteButtonSize = 40;
            const deleteButtonX =
              buildLayout.panelX + buildLayout.panelWidth + 60; // 60px spacing from inventory (moved right)
            const deleteButtonY = buildLayout.panelY + buildLayout.titleHeight;

            if (
              x >= deleteButtonX &&
              x <= deleteButtonX + deleteButtonSize &&
              y >= deleteButtonY &&
              y <= deleteButtonY + deleteButtonSize
            ) {
              // Check if an artifact slot is selected
              if (inventory.selectedSlotIndex !== null) {
                const selectedItem =
                  inventory.slots[inventory.selectedSlotIndex];
                if (selectedItem && selectedItem.type === 'artifact') {
                  // Delete the selected artifact
                  inventory.slots[inventory.selectedSlotIndex] = null;
                  inventory.selectedSlotIndex = null; // Clear selection
                }
              }
              return;
            }

            // Check if clicking on inventory slots
            for (let row = 0; row < numRows; row++) {
              for (let col = 0; col < slotsPerRow; col++) {
                const slotIndex = row * slotsPerRow + col;
                const slotX = slotsStartX + col * (slotSize + slotSpacing);
                const slotY = slotsStartY + row * (slotSize + slotSpacing);

                if (
                  x >= slotX &&
                  x <= slotX + slotSize &&
                  y >= slotY &&
                  y <= slotY + slotSize
                ) {
                  const item = inventory.slots[slotIndex];

                  // Check if selecting artifact for Joseph
                  if (
                    joseph.selectingArtifact &&
                    item &&
                    item.type === 'artifact' &&
                    item.name !== 'Cannon' &&
                    (item.tier === 'rare' ||
                      item.tier === 'super rare' ||
                      item.tier === 'legendary')
                  ) {
                    // Give artifact to Joseph and receive radar
                    inventory.slots[slotIndex] = null; // Remove from inventory
                    // Give radar to player
                    inventory.equipment = {
                      name: 'Radar',
                      sprite: radarSprite,
                      tier: 0, // Not a shovel tier
                    };
                    radar.active = true;
                    quests.findArtifactWithRadar.active = true;
                    joseph.hasGivenRadar = true;
                    joseph.selectingArtifact = false;
                    joseph.dialogue = null;
                    joseph.dialogueStage = 0;
                  } else if (item && item.type === 'artifact') {
                    // Select artifact for deletion (toggle selection)
                    if (inventory.selectedSlotIndex === slotIndex) {
                      inventory.selectedSlotIndex = null; // Deselect if already selected
                    } else {
                      inventory.selectedSlotIndex = slotIndex; // Select this slot
                    }
                  }
                  return;
                }
              }
            }
          }
        });

        function clamp(value, min, max) {
          return Math.min(max, Math.max(min, value));
        }

        // Function to initialize museum
        function initializeMuseum() {
          // Set museum world size
          const museumTileSize = tileSize; // Use same tile size
          const museumWorldWidth = museum.width * museumTileSize;
          const museumWorldHeight = museum.height * museumTileSize;

          // Position player in center-top of museum
          player.x = museumWorldWidth / 2;
          player.y = museumTileSize * 2; // A bit down from top
          player.vx = 0;
          player.vy = 0;

          // Position curator in bottom left of museum
          curator.x = museumTileSize * 2; // Left side, 2 tiles from edge
          curator.y = museumWorldHeight - museumTileSize * 2; // Bottom, 2 tiles from edge

          // Position cannonBuff next to cannon display (to the right of right cannon)
          // Cannons are at row 6 (0-indexed), cols 7-8
          const cannonRow = Math.floor(museum.height / 2) - 2; // Row 6
          const rightCannonCol = Math.floor(museum.width / 2); // Col 8
          // Center cannonBuff in the tile (add half tile size to center it)
          cannonBuff.x =
            (rightCannonCol + 2) * museumTileSize + museumTileSize / 2; // 2 tiles to the right of right cannon, centered
          cannonBuff.y = cannonRow * museumTileSize + museumTileSize / 2; // Same row as cannons, centered

          // Position camera to place museum at bottom middle of screen
          camera.x = museumWorldWidth / 2; // Center horizontally (160 for 320px wide museum)
          // Position camera so museum appears at bottom of screen
          // Translation formula: screenY = worldY + (canvas.height/2 - camera.y)
          // Museum is drawn from world (0,0) to (320,320)
          // We want museum bottom (worldY = 320) at screen bottom (screenY = 500)
          // 500 = 320 + (250 - camera.y)
          // camera.y = 320 + 250 - 500 = 70
          // This positions museum from screenY 180 to 500 (at bottom)
          camera.y = museumWorldHeight - canvas.height / 2; // = 70
          camera.x = Math.round(camera.x);
          camera.y = Math.round(camera.y);

          // Debug: Force camera position (museum is 320px tall, canvas is 500px tall)
          // With camera.y = 70: screenY = worldY + 180
          // Museum top (worldY=0)  screenY=180, bottom (worldY=320)  screenY=500 

          // Reset door prompt and tracking
          museum.doorPrompt = false;
          museum.wasNearDoor = false;
          museum.buildMode = false;
          // Note: cannonBuff.hasGivenReward is NOT reset here - reward persists across days
          // Initialize display cases once per game so placed artifacts persist
          if (!museum.hasInitializedDisplays) {
            museum.cannonDisplay = null;
            // Initialize display cases along the walls (top, left, right)
            // Keep them away from corners so the room feels less cramped
            museum.displayCases = [];
            // Top wall cases (row 1 = inside the top wall)
            museum.displayCases.push({ row: 1, col: 3, artifact: null });
            museum.displayCases.push({ row: 1, col: 6, artifact: null });
            museum.displayCases.push({ row: 1, col: 9, artifact: null });
            museum.displayCases.push({ row: 1, col: 12, artifact: null });
            // Left wall cases (col 1 = inside the left wall)
            museum.displayCases.push({ row: 3, col: 1, artifact: null });
            museum.displayCases.push({ row: 6, col: 1, artifact: null });
            museum.displayCases.push({ row: 9, col: 1, artifact: null });
            // Removed bottom two displays (row 12, col 1 and row 12, col 14)
            // Right wall cases (col 14 = inside the right wall)
            museum.displayCases.push({ row: 3, col: 14, artifact: null });
            museum.displayCases.push({ row: 6, col: 14, artifact: null });
            museum.displayCases.push({ row: 9, col: 14, artifact: null });
            // Removed bottom two displays (row 12, col 1 and row 12, col 14) - already removed

            museum.hasInitializedDisplays = true;
          }
        }

        // Function to start a new day
        function startNewDay() {
          // IMPORTANT: Set game state FIRST to prevent museum update loop from running
          gameState = 'playing';

          // Reset museum state to ensure clean transition
          museum.doorPrompt = false;
          museum.wasNearDoor = false;
          museum.buildMode = false;

          // Move to next day
          dayTime.currentDay++;

          // Check if week is over (Sunday = day 6, so after Sunday we're done)
          if (dayTime.currentDay > 6) {
            // Week is over - mark save as completed
            if (currentSaveSlot !== null) {
              try {
                const saveKey = `gameSave_slot${currentSaveSlot}`;
                const saveDataStr = localStorage.getItem(saveKey);
                if (saveDataStr) {
                  const saveData = JSON.parse(saveDataStr);
                  saveData.completed = true;
                  localStorage.setItem(saveKey, JSON.stringify(saveData));
                }
              } catch (error) {
                console.error('Failed to mark save as completed:', error);
              }
            }

            // Week is over
            gameState = 'weekEnd';
            return;
          }

          // Reset time for new day
          dayTime.currentHour = 8;
          dayTime.hourTimer = 0;

          // Don't show tutorial after first day
          if (dayTime.currentDay > 0) {
            tutorial.active = false;
          }

          // Set oldGuy's first dialogue on first day (replaces tutorial)
          if (dayTime.currentDay === 0) {
            oldGuy.dialogue = 'Hey! Over here!';
            oldGuy.dialogueStage = 0;
          }

          // Reset player to starting position (overworld coordinates)
          player.x = world.width / 2;
          player.y = world.height - 40;
          player.vx = 0;
          player.vy = 0;

          // Reset camera to player
          camera.x = player.x;
          camera.y = player.y;
          camera.x = Math.round(camera.x);
          camera.y = Math.round(camera.y);

          // Clear any stored radar discoveries from previous days.
          // Otherwise, we keep drawing yellow X markers for secretX tiles
          // that no longer exist in the new day's tileMap (the "ghost X" bug).
          radar.discoveredSecretX = [];
          radar.rings = [];

          // Regenerate tiles (randomize X's) and ensure sprites are loaded
          tileMap = generateTiles();
          tileRegenerationScheduled = false; // Reset flag to allow regeneration
          regenerateTiles(); // Regenerate tiles to ensure sprites are properly loaded

          // Day 0 (Monday) starts in museum, other days start in overworld
          if (dayTime.currentDay === 0) {
            gameState = 'museum';
            initializeMuseum();
          }
          // Otherwise gameState is already 'playing' - start in overworld
        }

        function update(dtMs) {
          const dt = (dtMs || 16.67) / 1000; // seconds

          // Update day/time system (only when playing)
          if (gameState === 'playing') {
            // Increment timer for current hour
            dayTime.hourTimer += dt;

            // When timer reaches 45 seconds, advance to next hour
            if (dayTime.hourTimer >= dayTime.secondsPerHour) {
              dayTime.currentHour++;
              dayTime.hourTimer = 0; // Reset timer for new hour
            }

            // Auto-save periodically (every 30 seconds)
            autoSaveTimer += dtMs;
            if (autoSaveTimer >= AUTO_SAVE_INTERVAL) {
              autoSave();
              autoSaveTimer = 0; // Reset timer
            }

            // Check if day should end (6 PM = 18:00)
            // Only end day if not in a minigame
            if (
              dayTime.currentHour >= dayTime.dayEndHour &&
              !brushingMinigame.active &&
              !minesweeperMinigame.active &&
              !typoMinigame.active &&
              !quizMinigame.active
            ) {
              // Auto-save before day ends
              autoSave();

              // Go to museum (except Sunday/after Sunday)
              if (dayTime.currentDay < 6) {
                // Not Sunday yet, go to museum
                gameState = 'museum';
                initializeMuseum();
              } else {
                // Sunday or later, go to dayEnd (week end)
                gameState = 'dayEnd';
              }
              // Stop player movement
              player.vx = 0;
              player.vy = 0;
            }
          }

          // Update museum (separate from playing state)
          if (gameState === 'museum' && !museum.doorPrompt) {
            const museumTileSize = tileSize;
            const museumWorldWidth = museum.width * museumTileSize;
            const museumWorldHeight = museum.height * museumTileSize;

            // Player movement in museum - disable movement if dialogue is showing
            // Declare variables outside if/else so they're available for animation/stamina updates
            const wantsSprint = pressed('ShiftLeft') || pressed('ShiftRight');
            const hasInput =
              pressed('ArrowLeft') ||
              pressed('KeyA') ||
              pressed('ArrowRight') ||
              pressed('KeyD') ||
              pressed('ArrowUp') ||
              pressed('KeyW') ||
              pressed('ArrowDown') ||
              pressed('KeyS');
            const allowBoost =
              wantsSprint &&
              !stamina.exhausted &&
              stamina.current >= stamina.minToSprint;
            const shouldDrain =
              wantsSprint &&
              !stamina.exhausted &&
              hasInput &&
              stamina.current > 0;

            // Declare speedSq outside if/else so it's accessible for walking animation
            let speedSq = 0;

            if (
              curator.dialogue ||
              cannonBuff.dialogue ||
              museum.buildMode ||
              celebrationAnimation.active
            ) {
              // Stop player movement during dialogue, build mode, or celebration animation
              player.vx = 0;
              player.vy = 0;
              speedSq = 0; // No movement
            } else {
              const accel = allowBoost
                ? player.accel * player.sprintMultiplier
                : player.accel;
              const maxSpeed = allowBoost
                ? player.maxSpeed * player.sprintMultiplier
                : player.maxSpeed;

              let ax = 0;
              let ay = 0;
              if (pressed('ArrowLeft') || pressed('KeyA')) ax -= accel;
              if (pressed('ArrowRight') || pressed('KeyD')) ax += accel;
              if (pressed('ArrowUp') || pressed('KeyW')) ay -= accel;
              if (pressed('ArrowDown') || pressed('KeyS')) ay += accel;

              player.vx += ax;
              player.vy += ay;

              if (ax === 0) player.vx *= player.friction;
              if (ay === 0) player.vy *= player.friction;

              // Optimize: use squared speed to avoid Math.hypot
              speedSq = player.vx * player.vx + player.vy * player.vy;
              const maxSpeedSq = maxSpeed * maxSpeed;
              if (speedSq > maxSpeedSq) {
                const speed = Math.sqrt(speedSq);
                const s = maxSpeed / speed;
                player.vx *= s;
                player.vy *= s;
              }

              player.x += player.vx;
              player.y += player.vy;
            }

            // Display case collision (treat each case like a solid block)
            resolveDisplayCaseCollisions();

            // Museum wall collision (keep player inside museum bounds)
            const playerRadius = player.width / 2;
            const wallThickness = museumTileSize;
            player.x = clamp(
              player.x,
              wallThickness + playerRadius,
              museumWorldWidth - wallThickness - playerRadius,
            );
            player.y = clamp(
              player.y,
              wallThickness + playerRadius,
              museumWorldHeight - wallThickness - playerRadius,
            );

            // Update camera - follow player horizontally, but keep museum at bottom
            camera.x += (player.x - camera.x) * camera.followLerp;
            // Only clamp if museum is larger than canvas (otherwise keep centered horizontally)
            if (museumWorldWidth > canvas.width) {
              camera.x = clamp(
                camera.x,
                canvas.width / 2,
                museumWorldWidth - canvas.width / 2,
              );
            } else {
              // Museum is smaller than canvas - keep camera centered horizontally
              camera.x = museumWorldWidth / 2;
            }
            // Always keep museum at bottom of screen (don't follow player vertically)
            if (museumWorldHeight > canvas.height) {
              // Museum is larger than canvas - allow vertical scrolling but clamp
              camera.y += (player.y - camera.y) * camera.followLerp;
              camera.y = clamp(
                camera.y,
                canvas.height / 2,
                museumWorldHeight - canvas.height / 2,
              );
            } else {
              // Museum is smaller than canvas - position at bottom middle
              // Keep camera at position that places museum at bottom
              camera.y = museumWorldHeight - canvas.height / 2;
            }
            camera.x = Math.round(camera.x);
            camera.y = Math.round(camera.y);

            // Check if player is near door (show prompt only when entering radius)
            // Optimize: use squared distance to avoid Math.sqrt
            const doorX = museum.doorCol * museumTileSize + museumTileSize / 2;
            const doorY = (museum.height - 1) * museumTileSize;
            const dx = player.x - doorX;
            const dy = player.y - doorY;
            const distToDoorSq = dx * dx + dy * dy;

            // Smaller activation radius (0.8 tiles) - squared
            const doorActivationRadius = museumTileSize * 0.8;
            const doorActivationRadiusSq =
              doorActivationRadius * doorActivationRadius;
            const wasNearDoor = museum.wasNearDoor || false;

            if (distToDoorSq < doorActivationRadiusSq) {
              // Player is near door - show prompt only if we weren't near before
              if (!wasNearDoor) {
                museum.doorPrompt = true;
              }
              museum.wasNearDoor = true;
            } else {
              // Player moved away from door - reset tracking
              museum.wasNearDoor = false;
              // Don't hide prompt immediately - let it stay until player clicks or moves
            }

            // Resolve curator collision (separate function, like other NPCs)
            resolveCuratorCollision();

            // Resolve cannonBuff collision (separate function, like other NPCs)
            resolveCannonBuffCollision();

            // Update walking animation (reuse speedSq from speed cap calculation above)
            // speedSq was already calculated when capping speed
            const isMoving = speedSq > 0.01; // 0.1^2 = 0.01
            if (isMoving) {
              const animationMultiplier = allowBoost ? 1.25 : 0.75;
              walkAnimationFrame +=
                dt * 60 * walkAnimationSpeed * animationMultiplier;
            } else {
              walkAnimationFrame = 0;
            }

            // Infinite stamina in museum - keep it at max
            stamina.current = stamina.max;
            stamina.exhausted = false;
          }

          // Only update player movement if inventory is closed, shop is closed, vending machine is closed, dialogue is not showing, tutorial is not active, crouch animation is not active, celebration animation is not active, and minigame is not active
          // Also don't update if day/week has ended
          if (
            gameState === 'playing' &&
            !inventory.open &&
            !systemMessage.text &&
            !oldGuy.dialogue &&
            !warningGuy.dialogue &&
            !joseph.dialogue &&
            !curator.dialogue &&
            !cannonBuff.dialogue &&
            !tutorial.active &&
            !crouchAnimation.active &&
            !celebrationAnimation.active &&
            !brushingMinigame.active &&
            !minesweeperMinigame.active &&
            !typoMinigame.active
          ) {
            // Keep the player from walking through NPCs in the overworld
            resolveOldGuyCollision();
            resolveWarningGuyCollision();
            resolveJosephCollision();

            const wantsSprint = pressed('ShiftLeft') || pressed('ShiftRight');

            // Decouple boost from draining so the bar can reach 0
            const hasInput =
              pressed('ArrowLeft') ||
              pressed('KeyA') ||
              pressed('ArrowRight') ||
              pressed('KeyD') ||
              pressed('ArrowUp') ||
              pressed('KeyW') ||
              pressed('ArrowDown') ||
              pressed('KeyS');
            const allowBoost =
              wantsSprint &&
              !stamina.exhausted &&
              stamina.current >= stamina.minToSprint;
            const shouldDrain =
              wantsSprint &&
              !stamina.exhausted &&
              hasInput &&
              stamina.current > 0;

            const accel = allowBoost
              ? player.accel * player.sprintMultiplier
              : player.accel;
            const maxSpeed = allowBoost
              ? player.maxSpeed * player.sprintMultiplier
              : player.maxSpeed;

            // Input axes
            let ax = 0;
            let ay = 0;
            if (pressed('ArrowLeft') || pressed('KeyA')) ax -= accel;
            if (pressed('ArrowRight') || pressed('KeyD')) ax += accel;
            if (pressed('ArrowUp') || pressed('KeyW')) ay -= accel;
            if (pressed('ArrowDown') || pressed('KeyS')) ay += accel;

            player.vx += ax;
            player.vy += ay;

            // Apply friction only when no input along that axis to keep controls snappy
            if (ax === 0) player.vx *= player.friction;
            if (ay === 0) player.vy *= player.friction;

            // Cap speed (optimize: use squared speed)
            const speedSq = player.vx * player.vx + player.vy * player.vy;
            const maxSpeedSq = maxSpeed * maxSpeed;
            if (speedSq > maxSpeedSq) {
              const speed = Math.sqrt(speedSq);
              const s = maxSpeed / speed;
              player.vx *= s;
              player.vy *= s;
            }

            player.x += player.vx;
            player.y += player.vy;

            resolveTreeCollisions();
            resolveOldGuyCollision();
            resolveJosephCollision();
            resolveRadarCollision(); // Radar has collision too

            // Update walking animation with speed based on sprinting (reuse speedSq from above)
            const isMoving = speedSq > 0.01; // 0.1^2 = 0.01
            if (isMoving) {
              // 75% slower when walking, 125% faster when sprinting
              const animationMultiplier = allowBoost ? 1.25 : 0.75;
              walkAnimationFrame +=
                dt * 60 * walkAnimationSpeed * animationMultiplier; // Normalize to 60fps
            } else {
              walkAnimationFrame = 0; // Reset to idle when not moving
            }

            // Stamina update
            if (shouldDrain) {
              // Shoes reduce stamina drain by 50%
              const drainRate = stamina.hasShoes
                ? stamina.drainPerSecond * 0.5
                : stamina.drainPerSecond;
              stamina.current -= drainRate * dt;
            } else {
              stamina.current += stamina.regenPerSecond * dt;
            }
            stamina.current = clamp(stamina.current, 0, stamina.max);

            // Exhaustion rules: lock sprint when empty until fully refilled
            if (stamina.current <= 0.0001) {
              stamina.exhausted = true;
            } else if (stamina.current >= stamina.max - 0.0001) {
              stamina.exhausted = false;
            }

            // World bounds (keep player fully inside)
            const halfW = player.width / 2;
            const halfH = player.height / 2;
            player.x = clamp(player.x, halfW, world.width - halfW);
            player.y = clamp(player.y, halfH, world.height - halfH);
          }

          // Clear keyJustPressed at end of frame
          Object.keys(keyJustPressed).forEach(
            (key) => (keyJustPressed[key] = false),
          );

          // Camera follow (smoothly move camera toward player)
          const targetX = player.x;
          const targetY = player.y;
          camera.x += (targetX - camera.x) * camera.followLerp;
          camera.y += (targetY - camera.y) * camera.followLerp;

          // Clamp camera so it doesn't show outside world
          const halfViewW = canvas.width / 2;
          const halfViewH = canvas.height / 2;
          camera.x = clamp(camera.x, halfViewW, world.width - halfViewW);
          camera.y = clamp(camera.y, halfViewH, world.height - halfViewH);

          // Round camera to integer pixels to prevent sub-pixel jitter
          // This ensures the translate() call produces consistent pixel-aligned results
          camera.x = Math.round(camera.x);
          camera.y = Math.round(camera.y);

          // Update celebration animation
          if (celebrationAnimation.active) {
            const dt = dtMs / 1000; // Convert to seconds
            celebrationAnimation.timer += dt;

            // Rotate star continuously (spinning effect)
            // Rotate at 2 full rotations per second (2 * 2 radians per second)
            celebrationAnimation.starRotation += dt * 2 * Math.PI * 2;

            // Stop player movement during celebration
            player.vx = 0;
            player.vy = 0;

            // End animation after duration
            if (celebrationAnimation.timer >= celebrationAnimation.duration) {
              celebrationAnimation.active = false;
              celebrationAnimation.artifact = null;
              celebrationAnimation.starRotation = 0;
            }
          }

          // Update crouch animation
          if (crouchAnimation.active) {
            const dt = dtMs / 1000; // Convert to seconds
            const effectiveDuration = crouchAnimation.duration;
            crouchAnimation.timer += dt;

            // Create particles during animation (small dirt particles)
            if (crouchAnimation.timer < effectiveDuration) {
              // Emit particles continuously during animation
              const particleEmitRate = 25; // particles per second (reduced from 30)
              const maxParticles = 50; // Limit total particles for performance
              const particlesToEmit = Math.min(
                particleEmitRate * dt,
                maxParticles - crouchAnimation.particles.length,
              );
              // Optimize: cache screen position calculation
              const screenX = player.x - camera.x + canvas.width / 2;
              const screenY = player.y - camera.y + canvas.height / 2;

              for (let i = 0; i < particlesToEmit; i++) {
                crouchAnimation.particles.push({
                  x: screenX + (Math.random() - 0.5) * 20,
                  y: screenY + (Math.random() - 0.5) * 20,
                  vx: (Math.random() - 0.5) * 60,
                  vy: (Math.random() - 0.5) * 60 - 20, // Slight upward bias
                  life: 1.0,
                  size: Math.random() * 2 + 1,
                });
              }
            }

            // Update particles (optimized: filter instead of splice)
            const aliveParticles = [];
            for (let i = 0; i < crouchAnimation.particles.length; i++) {
              const p = crouchAnimation.particles[i];
              p.x += p.vx * dt;
              p.y += p.vy * dt;
              p.vy += 80 * dt; // Gravity
              p.life -= dt * 2; // Fade out over 0.5 seconds

              // Keep alive particles
              if (p.life > 0) {
                aliveParticles.push(p);
              }
            }
            crouchAnimation.particles = aliveParticles;

            // After animation duration, start the pending minigame (if any) or just end animation
            if (crouchAnimation.timer >= effectiveDuration) {
              if (crouchAnimation.pendingMinigame) {
                startPendingMinigame();
              } else {
                // Just end the animation if no minigame is pending
                crouchAnimation.active = false;
                crouchAnimation.timer = 0;
                crouchAnimation.pendingMinigame = null;
                crouchAnimation.particles = [];
              }
            }
          }

          updateBrushingMinigame(dtMs);
          updateMinesweeperMinigame(dtMs);
          updateTypoMinigame(dtMs);
          updateQuizMinigame(dtMs);
          updateRadar(dtMs);
        }

        function drawTiles() {
          // No ctx.save()/restore() here - transform is already applied in render()
          // Viewport culling: only draw tiles visible on screen
          const viewLeft = camera.x - canvas.width / 2;
          const viewTop = camera.y - canvas.height / 2;
          const viewRight = camera.x + canvas.width / 2;
          const viewBottom = camera.y + canvas.height / 2;

          const startRow = Math.max(0, Math.floor(viewTop / tileSize) - 1);
          const endRow = Math.min(
            tileRows - 1,
            Math.ceil(viewBottom / tileSize) + 1,
          );
          const startCol = Math.max(0, Math.floor(viewLeft / tileSize) - 1);
          const endCol = Math.min(
            tileCols - 1,
            Math.ceil(viewRight / tileSize) + 1,
          );

          for (let row = startRow; row <= endRow; row++) {
            for (let col = startCol; col <= endCol; col++) {
              const tile = tileMap[row][col];
              if (tile && tile.canvas) {
                // Draw tiles at exact integer world positions
                // Tile canvas is 33x33 (tileSize + 1) with 1px overlap on right and bottom
                // Tiles drawn at col * tileSize will naturally overlap:
                // - Tile at col=0: drawn at x=0, covers x=0 to x=32 (33px)
                // - Tile at col=1: drawn at x=32, covers x=32 to x=64 (33px)
                // - Overlap at x=32 ensures seamless edges
                // World positions are always multiples of tileSize (32), so they're integers
                // The camera transform (already applied) converts these to screen coordinates
                // Camera position is rounded, so screen positions should align to pixel boundaries
                const tileX = col * tileSize;
                const tileY = row * tileSize;
                ctx.drawImage(tile.canvas, tileX, tileY);
              }
            }
          }
        }

        function resolveTreeCollisions() {
          const playerRadius = player.radius; // Use cached radius
          const maxCheckDistance = 150;
          const maxCheckDistanceSq = maxCheckDistance * maxCheckDistance;

          // Early exit optimization: use squared distances to avoid sqrt
          for (let i = 0; i < flora.trees.length; i++) {
            const tree = flora.trees[i];
            const dx = player.x - tree.x;
            const dy = player.y - tree.y;
            const distSq = dx * dx + dy * dy;

            // Quick distance check first (no sqrt needed)
            if (distSq > maxCheckDistanceSq) continue;

            const treeRadius = tree.colliderRadius;
            const minDist = treeRadius + playerRadius;
            const minDistSq = minDist * minDist;

            if (distSq < minDistSq && distSq > 0) {
              // Avoid division by zero
              const dist = Math.sqrt(distSq);
              const overlap = minDist - dist;
              const invDist = 1 / dist; // Cache inverse distance
              player.x += dx * invDist * overlap;
              player.y += dy * invDist * overlap;
            }
          }
        }

        function resolveOldGuyCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - oldGuy.x;
          const dy = player.y - oldGuy.y;
          const distSq = dx * dx + dy * dy;
          const minDist = oldGuy.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        // Warning Guy collision (same pattern as other circular NPCs)
        function resolveWarningGuyCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - warningGuy.x;
          const dy = player.y - warningGuy.y;
          const distSq = dx * dx + dy * dy;
          const minDist = warningGuy.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        function resolveJosephCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - joseph.x;
          const dy = player.y - joseph.y;
          const distSq = dx * dx + dy * dy;
          const minDist = joseph.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        // Radar collision (radar is positioned next to Joseph)
        function resolveRadarCollision() {
          const playerRadius = player.radius;
          const radarSpriteSize = 43; // Same size as Joseph
          const radarOffsetX = 50; // Position to the right of Joseph
          const radarX = joseph.x + radarOffsetX;
          const radarY = joseph.y;
          const radarRadius = radarSpriteSize / 2;

          const dx = player.x - radarX;
          const dy = player.y - radarY;
          const distSq = dx * dx + dy * dy;
          const minDist = radarRadius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist;
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        function resolveCuratorCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - curator.x;
          const dy = player.y - curator.y;
          const distSq = dx * dx + dy * dy;
          const minDist = curator.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        function resolveCannonBuffCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - cannonBuff.x;
          const dy = player.y - cannonBuff.y;
          const distSq = dx * dx + dy * dy;
          const minDist = cannonBuff.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        // Display case collision (AABB vs circle)
        // Keeps the player from walking through museum display cases
        function resolveDisplayCaseCollisions() {
          const playerRadius = player.radius;
          const caseSize = tileSize;

          for (let i = 0; i < museum.displayCases.length; i++) {
            const displayCase = museum.displayCases[i];
            const caseX = displayCase.col * caseSize;
            const caseY = displayCase.row * caseSize;

            // Find the closest point on the case rectangle to the player center
            const closestX = clamp(player.x, caseX, caseX + caseSize);
            const closestY = clamp(player.y, caseY, caseY + caseSize);
            const dx = player.x - closestX;
            const dy = player.y - closestY;
            const distSq = dx * dx + dy * dy;

            // If the player circle overlaps the rectangle, push it out
            if (distSq < playerRadius * playerRadius) {
              if (distSq > 0) {
                const dist = Math.sqrt(distSq);
                const overlap = playerRadius - dist;
                const invDist = 1 / dist;
                player.x += dx * invDist * overlap;
                player.y += dy * invDist * overlap;
              } else {
                // Player center is inside the case; push out on the nearest side
                const leftDist = player.x - caseX;
                const rightDist = caseX + caseSize - player.x;
                const topDist = player.y - caseY;
                const bottomDist = caseY + caseSize - player.y;
                const minDist = Math.min(
                  leftDist,
                  rightDist,
                  topDist,
                  bottomDist,
                );

                if (minDist === leftDist) {
                  player.x = caseX - playerRadius;
                } else if (minDist === rightDist) {
                  player.x = caseX + caseSize + playerRadius;
                } else if (minDist === topDist) {
                  player.y = caseY - playerRadius;
                } else {
                  player.y = caseY + caseSize + playerRadius;
                }
              }
            }
          }
        }

        function advanceJosephDialogue() {
          // Progress through Joseph's dialogue sequence
          // If already completed dialogue (stage 10), just close
          if (joseph.dialogueStage >= 10) {
            joseph.dialogue = null;
            joseph.dialogueStage = 0;
            return;
          }

          joseph.dialogueStage++;

          if (joseph.dialogueStage === 1) {
            joseph.dialogue =
              'Did you know that radars can detect hidden things underground?';
          } else if (joseph.dialogueStage === 2) {
            joseph.dialogue =
              'This one here is a GPR, or Ground Penetrating Radar.';
          } else if (joseph.dialogueStage === 3) {
            joseph.dialogue =
              'It works by emitting radio waves that bounce off objects, approximating their location.';
          } else if (joseph.dialogueStage === 4) {
            joseph.dialogue =
              "Since I don't have much use for this radar, you can have it - do me a favor.";
          } else if (joseph.dialogueStage === 5) {
            joseph.dialogue = "I'll swap it with a rare or rarer artifact!";
          } else if (joseph.dialogueStage === 6) {
            // Check if player has rare or higher artifacts (excluding cannon)
            const rareArtifacts = inventory.slots.filter(
              (slot, index) =>
                slot &&
                slot.type === 'artifact' &&
                slot.name !== 'Cannon' &&
                (slot.tier === 'rare' ||
                  slot.tier === 'super rare' ||
                  slot.tier === 'legendary'),
            );

            if (rareArtifacts.length > 0) {
              // Player has rare+ artifacts - ask them to select one
              joseph.dialogue =
                'I need a rare or higher artifact for my collection. Choose one from your inventory!';
              joseph.selectingArtifact = true;
              // Automatically open inventory so player can select an artifact
              inventory.open = true;
            } else {
              // No rare+ artifacts
              joseph.dialogue =
                "But it looks like you don't have one. Come back when you get a rare or higher artifact!";
              joseph.selectingArtifact = false;
            }
          } else if (joseph.dialogueStage >= 7) {
            // Close dialogue
            joseph.dialogue = null;
            joseph.dialogueStage = 0;
            joseph.selectingArtifact = false;
          }
        }

        function advanceOldGuyDialogue() {
          // Progress through the Old Guy's dialogue sequence
          if (!oldGuy.hasCompletedIntro) {
            // Initial dialogue sequence
            oldGuy.dialogueStage++;

            if (oldGuy.dialogueStage === 1) {
              oldGuy.dialogue =
                'Well, here we are. The newly discovered "Battle of the hills" historical site!';
            } else if (oldGuy.dialogueStage === 2) {
              oldGuy.dialogue =
                'It is time for you to uncover the history of this place!';
            } else if (oldGuy.dialogueStage === 3) {
              oldGuy.dialogue = 'Are you ready?';
            } else if (oldGuy.dialogueStage === 4) {
              oldGuy.dialogue = 'Dig up those holes with Spacebar!';
            } else if (oldGuy.dialogueStage >= 5) {
              // Completed the intro sequence
              oldGuy.dialogue = null;
              oldGuy.hasCompletedIntro = true;
              oldGuy.dialogueStage = 0;
            }
          } else {
            // After intro is complete, just close the "hurry up" message
            oldGuy.dialogue = null;
          }
        }

        // Warning Guy dialogue:
        // - First time: multi-line conversation about permits.
        // - After that: short repeat line.
        function advanceWarningGuyDialogue() {
          if (!warningGuy.hasCompletedIntro) {
            warningGuy.dialogueStage++;

            if (warningGuy.dialogueStage === 1) {
              warningGuy.dialogue =
                'Hey, you there, are you really an archeologist?';
            } else if (warningGuy.dialogueStage === 2) {
              warningGuy.dialogue =
                "You are? Good. Can't believe the nerve of some people.";
            } else if (warningGuy.dialogueStage === 3) {
              warningGuy.dialogue =
                "They come here with their metal detector's and shovels, trying to find some souvenir or something.";
            } else if (warningGuy.dialogueStage === 4) {
              warningGuy.dialogue =
                "Don't they know you have to be given permission to excavate an area?";
            } else if (warningGuy.dialogueStage >= 5) {
              // End of intro conversation
              warningGuy.dialogue = null;
              warningGuy.hasCompletedIntro = true;
              warningGuy.dialogueStage = 0;
            }
          } else {
            // After intro:
            // - First call (from interaction) shows the short line
            // - Next Space press closes it
            if (!warningGuy.dialogue) {
              // Start repeat line
              warningGuy.dialogue = 'So long as you have a permit, have fun!';
            } else {
              // Close repeat line
              warningGuy.dialogue = null;
            }
            warningGuy.dialogueStage = 0;
          }
        }

        function advanceCuratorDialogue() {
          // Curator dialogue advances through stages
          curator.dialogueStage++;
          const hasArtifacts = inventory.slots.some((slot) => slot !== null);

          if (hasArtifacts) {
            // Player has artifacts - dialogue sequence (stages 1-5)
            if (curator.dialogueStage === 1) {
              curator.dialogue =
                "Did you know the first museum was the Ennigaldi-Nana's museum, most likley created in 530 B.C.?";
            } else if (curator.dialogueStage === 2) {
              curator.dialogue = 'It too, had artifacts lined up in its halls.';
            } else if (curator.dialogueStage === 3) {
              curator.dialogue =
                'If you want to do the same, use "E" to enter build mode.';
            } else if (curator.dialogueStage === 4) {
              curator.dialogue =
                'There, you can choose which artifacts to put in the displays!';
            } else if (curator.dialogueStage === 5) {
              curator.dialogue =
                'I hear that you will be rewarded if you get the best artifacts by the end of the week...';
              curator.hasCompletedIntro = true; // Mark intro as complete
            } else if (curator.dialogueStage >= 6) {
              curator.dialogue = null;
              curator.dialogueStage = 0;
            }
          } else {
            // Player has no artifacts - two stages (1, 2)
            if (curator.dialogueStage === 1) {
              curator.dialogue = 'Dig up some artifacts, then we can talk.';
            } else if (curator.dialogueStage >= 2) {
              curator.dialogue = null;
              curator.dialogueStage = 0;
            }
          }
        }

        function advanceCannonBuffDialogue() {
          // Cannon Buff dialogue advances through stages
          cannonBuff.dialogueStage++;

          // Check if cannon is placed in museum
          const hasCannon =
            museum.cannonDisplay &&
            museum.cannonDisplay.artifact &&
            museum.cannonDisplay.artifact.name === 'Cannon';

          if (hasCannon && !cannonBuff.hasGivenReward) {
            // Reward dialogue sequence (4 stages: 0, 1, 2, 3)
            if (cannonBuff.dialogueStage === 1) {
              cannonBuff.dialogue =
                'As your reward, I will give you these new shoes.';
            } else if (cannonBuff.dialogueStage === 2) {
              cannonBuff.dialogue =
                "I was going to hike Henry Knox's trail with these, but I think i'll just admire this cannon instead.";
            } else if (cannonBuff.dialogueStage === 3) {
              cannonBuff.dialogue =
                'They make you lose less stamina while sprinting! Good luck filling out your museum!';
            } else if (cannonBuff.dialogueStage >= 4) {
              // Give Quick shoes reward and complete sequence
              stamina.hasShoes = true;
              cannonBuff.hasGivenReward = true;
              cannonBuff.dialogue = null;
              cannonBuff.dialogueStage = 0;
              // Complete quest
              if (quests.getCannonForCannonBuff) {
                quests.getCannonForCannonBuff.completed = true;
                quests.getCannonForCannonBuff.active = false;
              }
            }
          } else if (hasCannon && cannonBuff.hasGivenReward) {
            // After reward given, just say "Good luck!" and close
            cannonBuff.dialogue = null;
            cannonBuff.dialogueStage = 0;
          } else if (!cannonBuff.hasCompletedIntro) {
            // Initial dialogue sequence (4 stages: 0, 1, 2, 3)
            if (cannonBuff.dialogueStage === 1) {
              cannonBuff.dialogue =
                'Did you know that in the winter of 1775-76, this colonel called Henry Knox hauled 60 tons of these over 300 miles?';
            } else if (cannonBuff.dialogueStage === 2) {
              cannonBuff.dialogue =
                'Its true! It\'s called the "Henry Knox Noble Train of Artillety".';
            } else if (cannonBuff.dialogueStage === 3) {
              cannonBuff.dialogue =
                "If you somehow get a cannon in your museum, I'll make it worth your while!";
            } else if (cannonBuff.dialogueStage >= 4) {
              // Completed the intro sequence
              cannonBuff.dialogue = null;
              cannonBuff.hasCompletedIntro = true;
              cannonBuff.dialogueStage = 0;
              // Activate quest when intro completes
              if (!quests.getCannonForCannonBuff.active) {
                quests.getCannonForCannonBuff.active = true;
              }
            }
          } else {
            // After intro is complete (no cannon yet), just close the message
            cannonBuff.dialogue = null;
            cannonBuff.dialogueStage = 0;
          }
        }

        function handleInteraction() {
          // Don't interact if inventory is open
          if (inventory.open) {
            return;
          }

          // Don't interact if in build mode (museum build mode)
          if (gameState === 'museum' && museum.buildMode) {
            return;
          }

          // Don't start new dialogue if one is already showing
          if (
            oldGuy.dialogue ||
            joseph.dialogue ||
            curator.dialogue ||
            cannonBuff.dialogue
          ) {
            return;
          }

          const playerRadius = player.radius; // Use cached radius

          // Check if player is touching curator (collision-based, only in museum state)
          // Completely rewritten - check curator FIRST, exactly like shopkeeper pattern
          if (gameState === 'museum') {
            // Calculate distance to curator
            const dx = player.x - curator.x;
            const dy = player.y - curator.y;
            const distSq = dx * dx + dy * dy;
            const minDist = curator.radius + playerRadius;
            const minDistSq = minDist * minDist;

            // Allow interaction when very close (within collision distance + small buffer)
            if (distSq <= minDistSq * 1.2) {
              // Check if player has any artifacts
              const hasArtifacts = inventory.slots.some(
                (slot) => slot !== null,
              );

              if (curator.hasCompletedIntro) {
                // After intro is complete, just say "Open build mode with E!"
                curator.dialogue = 'Open build mode with E!';
                curator.dialogueStage = 1; // Single stage for repeat dialogue
              } else if (hasArtifacts) {
                // First time with artifacts - start intro dialogue sequence
                curator.dialogue =
                  "Did you know the first museum was the Ennigaldi-Nana's museum, most likley created in 530 B.C.?";
                curator.dialogueStage = 1;
              } else {
                // No artifacts - start "no artifacts" dialogue sequence
                curator.dialogue = "Looks like you don't have any artifacts.";
                curator.dialogueStage = 1;
              }
              curator.dialogueTimer = 0; // Don't auto-close, wait for Spacebar press
              // Kill momentum when opening dialogue
              player.vx = 0;
              player.vy = 0;
              return;
            }

            // Check if player is touching cannonBuff (collision-based, only in museum state)
            // Use larger interaction distance (2.0x) to make it easier to interact, like joseph
            const cannonDx = player.x - cannonBuff.x;
            const cannonDy = player.y - cannonBuff.y;
            const cannonDistSq = cannonDx * cannonDx + cannonDy * cannonDy;
            const cannonMinDist = cannonBuff.radius + playerRadius;
            const cannonMinDistSq = cannonMinDist * cannonMinDist;

            // Allow interaction when very close (use 2.0x multiplier for easier interaction)
            if (cannonDistSq <= cannonMinDistSq * 2.0) {
              // Check if cannon is placed in museum
              const hasCannon =
                museum.cannonDisplay &&
                museum.cannonDisplay.artifact &&
                museum.cannonDisplay.artifact.name === 'Cannon';

              // Start cannonBuff dialogue sequence
              if (hasCannon && !cannonBuff.hasGivenReward) {
                // First talk after placing cannon
                cannonBuff.dialogueStage = 0;
                cannonBuff.dialogue =
                  "Wow! A cannon! I don't know how you did it, but here it is!";
              } else if (hasCannon && cannonBuff.hasGivenReward) {
                // After reward given
                cannonBuff.dialogue = 'Good luck!';
                cannonBuff.dialogueStage = 0;
              } else if (!cannonBuff.hasCompletedIntro) {
                // Initial intro dialogue - activate quest
                cannonBuff.dialogueStage = 0;
                cannonBuff.dialogue =
                  "Hello there! As you can tell, I'm a big fan of cannons.";
                // Activate quest when first talking
                if (!quests.getCannonForCannonBuff.active) {
                  quests.getCannonForCannonBuff.active = true;
                }
              } else {
                // After intro, no cannon yet
                cannonBuff.dialogue =
                  "Find and put a cannon in your museum, I'll make it worth your while!";
                cannonBuff.dialogueStage = 0;
              }
              cannonBuff.dialogueTimer = 0; // Don't auto-close, wait for Spacebar press
              // Kill momentum when opening dialogue
              player.vx = 0;
              player.vy = 0;
            return;
          }
          return;
        }

          // In playing state, check for X tile first (priority over NPC dialogue)
          if (gameState === 'playing') {
            const playerLeft = player.x - player.radius;
            const playerRight = player.x + player.radius;
            const playerTop = player.y - player.radius;
            const playerBottom = player.y + player.radius;
            const startCol = Math.floor(playerLeft / tileSize);
            const endCol = Math.floor(playerRight / tileSize);
            const startRow = Math.floor(playerTop / tileSize);
            const endRow = Math.floor(playerBottom / tileSize);
            let foundXTile = null;
            let foundRow = null;
            let foundCol = null;
            for (let row = startRow; row <= endRow; row++) {
              if (row < 0 || row >= tileRows) continue;
              for (let col = startCol; col <= endCol; col++) {
                if (col < 0 || col >= tileCols) continue;
                const tile = tileMap[row][col];
                if (tile && (tile.name === 'redX' || tile.name === 'secretX')) {
                  const tileLeft = col * tileSize;
                  const tileRight = (col + 1) * tileSize;
                  const tileTop = row * tileSize;
                  const tileBottom = (row + 1) * tileSize;
                  if (
                    playerRight > tileLeft &&
                    playerLeft < tileRight &&
                    playerBottom > tileTop &&
                    playerTop < tileBottom
                  ) {
                    foundXTile = tile;
                    foundRow = row;
                    foundCol = col;
                    break;
                  }
                }
              }
              if (foundXTile) break;
            }
            if (foundXTile) {
              const tile = foundXTile;
              const row = foundRow;
              const col = foundCol;
              if (!crouchAnimation.active) {
                crouchAnimation.active = true;
                crouchAnimation.timer = 0;
                crouchAnimation.particles = [];
                if (tile.name === 'redX' || tile.name === 'secretX') {
                  crouchAnimation.pendingMinigame = 'quiz';
                  crouchAnimation.isSecretX = tile.name === 'secretX';
                  crouchAnimation.tileRow = row;
                  crouchAnimation.tileCol = col;
                  const grassDef = tileDefinitions.find(
                    (def) => def.name === 'grass',
                  );
                  if (grassDef) {
                    tileMap[row][col] = {
                      name: grassDef.name,
                      canvas: createTileCanvas(grassDef.draw),
                    };
                    if (tile.name === 'secretX') {
                      radar.discoveredSecretX = radar.discoveredSecretX.filter(
                        (pos) => !(pos.row === row && pos.col === col),
                      );
                    }
                  }
                } else {
                  crouchAnimation.pendingMinigame = null;
                  crouchAnimation.isSecretX = false;
                  crouchAnimation.tileRow = null;
                  crouchAnimation.tileCol = null;
                }
                player.vx = 0;
                player.vy = 0;
              }
              return;
            }
          }

          // Check if player is touching old guy (collision-based)
          let dx = player.x - oldGuy.x;
          let dy = player.y - oldGuy.y;
          let distSq = dx * dx + dy * dy;
          let minDist = oldGuy.radius + playerRadius;
          let minDistSq = minDist * minDist;

          // Allow interaction when very close (within collision distance + small buffer)
          if (distSq <= minDistSq * 1.2) {
            // Set dialogue based on whether intro is completed
            if (!oldGuy.hasCompletedIntro) {
              // Start the intro dialogue sequence
              oldGuy.dialogueStage = 0;
              oldGuy.dialogue = 'Hello there!';
            } else {
              // Show the "hurry up" message after intro is done
              oldGuy.dialogue =
                'What are you waiting for? Get going! Dig those holes with Spacebar!';
            }
            // Kill momentum when opening dialogue
            player.vx = 0;
            player.vy = 0;
            return;
          }

          // Check if player is touching Warning Guy (collision-based)
          dx = player.x - warningGuy.x;
          dy = player.y - warningGuy.y;
          distSq = dx * dx + dy * dy;
          minDist = warningGuy.radius + playerRadius;
          minDistSq = minDist * minDist;

          // Same idea as oldGuy: only interact when very close to him
          if (distSq <= minDistSq * 1.2) {
            if (!warningGuy.hasCompletedIntro) {
              // Start permit-warning intro sequence
              warningGuy.dialogueStage = 0;
              advanceWarningGuyDialogue();
            } else {
              // After intro, jump straight to his short repeat line
              warningGuy.dialogueStage = 0;
              advanceWarningGuyDialogue();
            }
            // Stop the player so the dialogue feels intentional
            player.vx = 0;
            player.vy = 0;
            return;
          }

          // Check if player is touching Joseph (collision-based)
          // Increase interaction distance to make it easier to talk to Joseph
          dx = player.x - joseph.x;
          dy = player.y - joseph.y;
          distSq = dx * dx + dy * dy;
          minDist = joseph.radius + playerRadius;
          minDistSq = minDist * minDist;

          // Use larger interaction distance (2.0x instead of 1.2x) to make it easier to interact
          if (distSq <= minDistSq * 2.0) {
            // Start Joseph dialogue sequence if not completed
            if (!joseph.hasGivenRadar) {
              // Start at stage 1 so the first Space press advances to stage 2
              // (prevents the first sentence from repeating).
              joseph.dialogueStage = 1;
              joseph.dialogue =
                'Did you know that radars can detect hidden things underground?';
            } else {
              // Already gave radar, just acknowledge
              joseph.dialogue = 'Good luck finding artifacts with that radar!';
              joseph.dialogueStage = 10; // High number so it closes quickly
            }
            // Kill momentum when opening dialogue
            player.vx = 0;
            player.vy = 0;
            return;
          }
        }

        // Helper function to add items to inventory when minigames complete
        // This function finds the first empty slot and adds the item there
        // Artifacts have tiers that affect their inventory outline color
        const ARTIFACT_NAMES = [
          'Rusty Nails',
          'Bullets',
          'Grapeshot',
          'Buttons',
          'Fork',
          'Ornate pin',
          'Canteen',
          'Arrowhead',
          'Cannon',
          'Cannon Shards',
          'Cartridge',
        ];
        const artifactTiers = {
          'Rusty Nails': 'common',
          Bullets: 'common',
          Grapeshot: 'uncommon',
          Buttons: 'uncommon',
          Fork: 'common',
          'Ornate pin': 'rare',
          Canteen: 'rare',
          Arrowhead: 'super rare',
          'Cannon Shards': 'super rare',
          Cannon: 'legendary',
          Cartridge: 'legendary',
        };
        const rarityRank = {
          common: 0,
          uncommon: 1,
          rare: 2,
          'super rare': 3,
          legendary: 4,
        };

        // Function to get artifact sprite by name (used when loading saves)
        function getArtifactSpriteByName(itemName) {
          // Map artifact names to their sprite objects
          const spriteMap = {
            'Rusty Nails': rustyNailsSprite,
            Bullets: bulletsSprite,
            Grapeshot: grapeshotSprite,
            Buttons: buttonsSprite,
            Fork: forkSprite,
            'Ornate pin': pinSprite,
            Canteen: canteenSprite,
            Arrowhead: arrowheadSprite,
            'Cannon Shards': cannonShardsSprite,
            Cannon: cannonSprite,
            Cartridge: cartridgeSprite,
          };
          return spriteMap[itemName] || null;
        }

        function getArtifactTier(itemName) {
          return artifactTiers[itemName] || 'common';
        }

        // Helper to check if the player or museum already has a Cannon artifact.
        // This enforces the rule: you can only ever obtain ONE Cannon per save.
        function playerOrMuseumHasCannon() {
          // Check inventory slots
          const hasInInventory = inventory.slots.some(
            (slot) =>
              slot && slot.type === 'artifact' && slot.name === 'Cannon',
          );

          // Check museum cannon display
          const hasInMuseum =
            museum.cannonDisplay &&
            museum.cannonDisplay.artifact &&
            museum.cannonDisplay.artifact.name === 'Cannon';

          return hasInInventory || hasInMuseum;
        }

        // Check if a tier is above another tier (strictly higher)
        function isTierAbove(tier, minimumTier) {
          const tierValue =
            rarityRank[tier] !== undefined ? rarityRank[tier] : -1;
          const minValue =
            rarityRank[minimumTier] !== undefined
              ? rarityRank[minimumTier]
              : -1;
          return tierValue > minValue;
        }

        function addItemToInventory(itemName, sprite) {
          const isArtifact = ARTIFACT_NAMES.includes(itemName);

          // Find first empty inventory slot
          for (let i = 0; i < inventory.slots.length; i++) {
            if (inventory.slots[i] === null) {
              // Empty slot found, add the item
              const tier = isArtifact ? getArtifactTier(itemName) : null;
              inventory.slots[i] = {
                name: itemName,
                sprite: sprite,
                type: isArtifact ? 'artifact' : 'item', // Mark artifacts for build mode
                tier: tier, // common, uncommon, rare (artifacts only)
              };
              return true; // Successfully added
            }
          }
          // No empty slots available
          return false; // Inventory full
        }

        // Function to give minigame reward (randomly chooses artifact)
        // Distribution: 70% common, 16% uncommon, 7.5% rare, 4% super rare, 2.5% legendary
        // For radar-discovered X's: 65% common, 17.5% uncommon, 8.75% rare, 5% super rare, 3.75% legendary
        // Common: Rusty Nails (23.33%), Bullets (23.33%), Fork (23.33%) = 70% total (65% for secret X: 32.5% Rusty Nails, 32.5% Bullets)
        // Uncommon: Grapeshot (8%), Buttons (8%) = 16% total (17.5% for secret X: 8.75% each)
        // Rare: Ornate pin (3.75%), Canteen (3.75%) = 7.5% total (8.75% for secret X: 4.375% each)
        // Super Rare: Arrowhead (2%), Cannon Shards (2%) = 4% total (5% for secret X: 2.5% each)
        // Legendary: Cannon (1.25%, restricted to one per save), Cartridge (1.25%, unlimited) = 2.5% total
        // For secret X: Cannon (1.875%, restricted), Cartridge (1.875%, unlimited) = 3.75% total
        function giveMinigameReward() {
          // Increment global X dug count (for achievements)
          let totalXDug = parseInt(localStorage.getItem('gameTotalXDug') || '0', 10);
          totalXDug += 1;
          localStorage.setItem('gameTotalXDug', String(totalXDug));
          // Unlock dig-count achievements
          const digAchievements = [
            { id: 'good_start', threshold: 1 },
            { id: 'on_the_right_track', threshold: 20 },
            { id: 'pro_digger', threshold: 50 },
            { id: 'master_digger', threshold: 100 },
          ];
          for (const { id, threshold } of digAchievements) {
            if (totalXDug >= threshold) {
              const ach = achievements.list.find((a) => a.id === id);
              if (ach && !ach.completed) {
                ach.completed = true;
                saveAchievements();
              }
            }
          }

          // Check if this reward is from a radar-discovered secret X
          const isSecretX =
            brushingMinigame.isSecretX ||
            minesweeperMinigame.isSecretX ||
            typoMinigame.isSecretX;

          // Helper to add rewards and only complete radar quest on yellow X digs
          // Returns artifact info if successfully added, null otherwise
          const tryAddReward = (name, sprite) => {
            const added = addItemToInventory(name, sprite);
            if (
              added &&
              isSecretX &&
              quests.findArtifactWithRadar.active &&
              !quests.findArtifactWithRadar.completed
            ) {
              // Player found an artifact from a yellow X - complete quest
              quests.findArtifactWithRadar.completed = true;
              quests.findArtifactWithRadar.active = false;
            }
            // Return artifact info if added, null otherwise
            return added ? { name, sprite } : null;
          };

          let roll = Math.random();

          if (isSecretX) {
            // Radar-discovered X: Everything twice as rare except common
            // Common: 65% (32.5% Rusty Nails, 32.5% Bullets)
            // Uncommon: 17.5% (8.75% Grapeshot, 8.75% Buttons)
            // Rare: 8.75% (4.375% Ornate pin, 4.375% Canteen)
            // Super Rare: 5% (2.5% Arrowhead, 2.5% Cannon Shards)
            // Legendary: 3.75% (1.875% Cannon - restricted, 1.875% Cartridge - unlimited)

            if (roll < 0.325) {
              // 32.5% chance - Rusty Nails (common)
              if (
                rustyNailsSprite.complete &&
                rustyNailsSprite.naturalWidth > 0
              ) {
                return tryAddReward('Rusty Nails', rustyNailsSprite);
              }
            } else if (roll < 0.65) {
              // 32.5% chance - Bullets (common)
              if (bulletsSprite.complete && bulletsSprite.naturalWidth > 0) {
                return tryAddReward('Bullets', bulletsSprite);
              }
            } else if (roll < 0.7375) {
              // 8.75% chance - Grapeshot (uncommon)
              if (
                grapeshotSprite.complete &&
                grapeshotSprite.naturalWidth > 0
              ) {
                return tryAddReward('Grapeshot', grapeshotSprite);
              }
            } else if (roll < 0.825) {
              // 8.75% chance - Buttons (uncommon)
              if (buttonsSprite.complete && buttonsSprite.naturalWidth > 0) {
                return tryAddReward('Buttons', buttonsSprite);
              }
            } else if (roll < 0.86875) {
              // 4.375% chance - Ornate pin (rare)
              if (pinSprite.complete && pinSprite.naturalWidth > 0) {
                return tryAddReward('Ornate pin', pinSprite);
              }
            } else if (roll < 0.9125) {
              // 4.375% chance - Canteen (rare)
              if (canteenSprite.complete && canteenSprite.naturalWidth > 0) {
                return tryAddReward('Canteen', canteenSprite);
              }
            } else if (roll < 0.9375) {
              // 2.5% chance - Arrowhead (super rare)
              if (
                arrowheadSprite.complete &&
                arrowheadSprite.naturalWidth > 0
              ) {
                return tryAddReward('Arrowhead', arrowheadSprite);
              }
            } else if (roll < 0.9625) {
              // 2.5% chance - Cannon Shards (super rare)
              if (
                cannonShardsSprite.complete &&
                cannonShardsSprite.naturalWidth > 0
              ) {
                return tryAddReward('Cannon Shards', cannonShardsSprite);
              }
            } else if (roll < 0.98125) {
              // 1.875% chance - Cannon (legendary)
              // But only if the player/museum doesn't already have one.
              if (
                cannonSprite.complete &&
                cannonSprite.naturalWidth > 0 &&
                !playerOrMuseumHasCannon()
              ) {
                return tryAddReward('Cannon', cannonSprite);
              }
              // If we already have a Cannon, fall back to Cartridge instead.
              if (
                cartridgeSprite.complete &&
                cartridgeSprite.naturalWidth > 0
              ) {
                return tryAddReward('Cartridge', cartridgeSprite);
              }
            } else {
              // 1.875% chance - Cartridge (legendary, unlimited)
              if (
                cartridgeSprite.complete &&
                cartridgeSprite.naturalWidth > 0
              ) {
                return tryAddReward('Cartridge', cartridgeSprite);
              }
            }
          } else {
            // Normal X: Everything twice as rare except common
            // Common: 70% (23.33% Rusty Nails, 23.33% Bullets, 23.34% Fork)
            // Uncommon: 16% (8% Grapeshot, 8% Buttons)
            // Rare: 7.5% (3.75% Ornate pin, 3.75% Canteen)
            // Super Rare: 4% (2% Arrowhead, 2% Cannon Shards)
            // Legendary: 2.5% (1.25% Cannon - restricted, 1.25% Cartridge - unlimited)
            if (roll < 0.2333) {
              // 23.33% chance - Rusty Nails (common)
              if (
                rustyNailsSprite.complete &&
                rustyNailsSprite.naturalWidth > 0
              ) {
                return tryAddReward('Rusty Nails', rustyNailsSprite);
              }
            } else if (roll < 0.4666) {
              // 23.33% chance - Bullets (common)
              if (bulletsSprite.complete && bulletsSprite.naturalWidth > 0) {
                return tryAddReward('Bullets', bulletsSprite);
              }
            } else if (roll < 0.7) {
              // 23.34% chance - Fork (common)
              if (forkSprite.complete && forkSprite.naturalWidth > 0) {
                return tryAddReward('Fork', forkSprite);
              }
            } else if (roll < 0.78) {
              // 8% chance - Grapeshot (uncommon)
              if (
                grapeshotSprite.complete &&
                grapeshotSprite.naturalWidth > 0
              ) {
                return tryAddReward('Grapeshot', grapeshotSprite);
              }
            } else if (roll < 0.86) {
              // 8% chance - Buttons (uncommon)
              if (buttonsSprite.complete && buttonsSprite.naturalWidth > 0) {
                return tryAddReward('Buttons', buttonsSprite);
              }
            } else if (roll < 0.8975) {
              // 3.75% chance - Ornate pin (rare)
              if (pinSprite.complete && pinSprite.naturalWidth > 0) {
                return tryAddReward('Ornate pin', pinSprite);
              }
            } else if (roll < 0.935) {
              // 3.75% chance - Canteen (rare)
              if (canteenSprite.complete && canteenSprite.naturalWidth > 0) {
                return tryAddReward('Canteen', canteenSprite);
              }
            } else if (roll < 0.955) {
              // 2% chance - Arrowhead (super rare)
              if (
                arrowheadSprite.complete &&
                arrowheadSprite.naturalWidth > 0
              ) {
                return tryAddReward('Arrowhead', arrowheadSprite);
              }
            } else if (roll < 0.975) {
              // 2% chance - Cannon Shards (super rare)
              if (
                cannonShardsSprite.complete &&
                cannonShardsSprite.naturalWidth > 0
              ) {
                return tryAddReward('Cannon Shards', cannonShardsSprite);
              }
            } else if (roll < 0.9875) {
              // 1.25% chance - Cannon (legendary)
              // But only if the player/museum doesn't already have one.
              if (
                cannonSprite.complete &&
                cannonSprite.naturalWidth > 0 &&
                !playerOrMuseumHasCannon()
              ) {
                return tryAddReward('Cannon', cannonSprite);
              }
              // If we already have a Cannon, fall back to Cartridge instead.
              if (
                cartridgeSprite.complete &&
                cartridgeSprite.naturalWidth > 0
              ) {
                return tryAddReward('Cartridge', cartridgeSprite);
              }
            } else {
              // 1.25% chance - Cartridge (legendary, unlimited)
              if (
                cartridgeSprite.complete &&
                cartridgeSprite.naturalWidth > 0
              ) {
                return tryAddReward('Cartridge', cartridgeSprite);
              }
            }
          }
          return null; // Failed to add reward (inventory full or sprite not loaded)
        }

        // Function to start celebration animation after receiving an artifact
        // Shows player holding artifact over head with spinning star behind it
        function startCelebrationAnimation(artifact) {
          if (!artifact) return; // No artifact to celebrate

          celebrationAnimation.active = true;
          celebrationAnimation.timer = 0;
          celebrationAnimation.artifact = artifact;
          celebrationAnimation.starRotation = 0;
        }

        // Function to start the actual minigame after crouch animation completes
        function startPendingMinigame() {
          // Close inventory automatically when minigame starts to prevent softlocks
          inventory.open = false;

          // Use stored tile position from crouch animation (tile already converted to grass)
          const row = crouchAnimation.tileRow;
          const col = crouchAnimation.tileCol;

          if (crouchAnimation.pendingMinigame === 'brushing') {
            // Start Brushing minigame
            brushingMinigame.active = true;
            brushingMinigame.tileRow = row;
            brushingMinigame.tileCol = col;
            brushingMinigame.isSecretX = crouchAnimation.isSecretX;
            brushingMinigame.dirtLevel = 1.0;
            brushingMinigame.redness = 0;
            brushingMinigame.timeHoldingSpace = 0;
            // Show instructions automatically on first time
            if (!brushingMinigame.hasStartedFirstTime) {
              brushingMinigame.showInstructions = true;
              brushingMinigame.hasStartedFirstTime = true;
            }
            // Check if player has speed brush (equipment slot only)
            const hasSpeedBrush = inventory.speedBrush;
            // Speed brush: red trigger time is 2-4 seconds (instead of 3-8)
            if (hasSpeedBrush) {
              brushingMinigame.redTriggerTime = 2 + Math.random() * 2; // 2-4 seconds
              brushingMinigame.perfectReleaseWindow = 0.75; // 0.75 seconds (instead of 0.5)
            } else {
              // Randomly choose between 3-7 second interval for turning red
              brushingMinigame.redTriggerTime = 3 + Math.random() * 4; // 3-7 seconds
              brushingMinigame.perfectReleaseWindow = 0.5; // 0.5 seconds
            }
            brushingMinigame.timeSinceRed = 0;
            brushingMinigame.particles = [];
            brushingMinigame.completed = false;
            brushingMinigame.broken = false;
            // Initialize brush position to center of screen (slightly above dirt)
            brushingMinigame.brushX = canvas.width / 2;
            brushingMinigame.brushY = canvas.height / 2 - 40; // Slightly above center
            brushingMinigame.brushOffset = 0;
            brushingMinigame.brushDirection = 1;
          } else if (crouchAnimation.pendingMinigame === 'minesweeper') {
            // Start Minesweeper minigame
            minesweeperMinigame.active = true;
            minesweeperMinigame.tileRow = row;
            minesweeperMinigame.tileCol = col;
            minesweeperMinigame.isSecretX = crouchAnimation.isSecretX;
            minesweeperMinigame.gameOver = false;
            minesweeperMinigame.won = false;
            minesweeperMinigame.gameOverMessage = null;
            minesweeperMinigame.firstClick = true;
            minesweeperMinigame.clickCount = 0; // Reset click count for new game
            // Show instructions automatically on first time
            if (!minesweeperMinigame.hasStartedFirstTime) {
              minesweeperMinigame.showInstructions = true;
              minesweeperMinigame.hasStartedFirstTime = true;
            }

            // Initialize empty grids
            const size = minesweeperMinigame.gridSize;
            minesweeperMinigame.grid = [];
            minesweeperMinigame.revealed = [];
            minesweeperMinigame.flagged = [];

            for (let i = 0; i < size; i++) {
              minesweeperMinigame.grid[i] = [];
              minesweeperMinigame.revealed[i] = [];
              minesweeperMinigame.flagged[i] = [];
              for (let j = 0; j < size; j++) {
                minesweeperMinigame.grid[i][j] = false; // false = no mine
                minesweeperMinigame.revealed[i][j] = false;
                minesweeperMinigame.flagged[i][j] = false;
              }
            }

            // Mines will be placed after first click to ensure first click is safe
          } else if (crouchAnimation.pendingMinigame === 'typo') {
            // Start Typo minigame - randomly select a document
            typoMinigame.active = true;
            typoMinigame.tileRow = row;
            typoMinigame.tileCol = col;
            typoMinigame.isSecretX = crouchAnimation.isSecretX;
            typoMinigame.answered = false;
            // Show instructions automatically on first time
            if (!typoMinigame.hasStartedFirstTime) {
              typoMinigame.showInstructions = true;
              typoMinigame.hasStartedFirstTime = true;
            }

            // Randomly select a document
            const selectedDocument =
              typoDocuments[Math.floor(Math.random() * typoDocuments.length)];
            typoMinigame.realExcerpt = selectedDocument.realExcerpt;

            // 50% chance the test excerpt is fake (has typos)
            typoMinigame.isFake = Math.random() < 0.5;

            if (typoMinigame.isFake) {
              // Create fake version with random typo from the selected document
              const typoOptions = selectedDocument.typoOptions;
              // Randomly pick one typo
              const selectedTypo =
                typoOptions[Math.floor(Math.random() * typoOptions.length)];
              typoMinigame.testExcerpt = typoMinigame.realExcerpt.replace(
                selectedTypo.from,
                selectedTypo.to,
              );
              // Store the typo info for highlighting when wrong
              typoMinigame.selectedTypo = selectedTypo;
            } else {
              // Real version (no typos)
              typoMinigame.testExcerpt = typoMinigame.realExcerpt;
            }
          } else if (crouchAnimation.pendingMinigame === 'quiz') {
            // Start Quiz minigame - randomly select a question
            quizMinigame.active = true;
            quizMinigame.tileRow = row;
            quizMinigame.tileCol = col;
            quizMinigame.isSecretX = crouchAnimation.isSecretX;
            quizMinigame.answered = false;
            // Show instructions automatically on first time
            if (!quizMinigame.hasStartedFirstTime) {
              quizMinigame.showInstructions = true;
              quizMinigame.hasStartedFirstTime = true;
            }

            // Randomly select a question
            const selectedQuestion =
              quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
            quizMinigame.question = selectedQuestion.question;
            quizMinigame.correctAnswer = selectedQuestion.correctAnswer;
          }

          // Reset crouch animation
          crouchAnimation.active = false;
          crouchAnimation.timer = 0;
          crouchAnimation.pendingMinigame = null;
        }

        function updateBrushingMinigame(dtMs) {
          if (!brushingMinigame.active) return;

          // Prevent interaction when tutorial popup is active
          if (tutorial.active && dayTime.currentDay === 0) {
            return;
          }

          const dt = dtMs / 1000; // Convert to seconds
          const spacePressed = pressed('Space');

          // Animate brush back and forth when spacebar is held
          if (spacePressed) {
            // Track time holding space
            brushingMinigame.timeHoldingSpace += dt;

            // Animate brush moving back and forth across the dirt
            const brushSpeed = 200; // pixels per second (doubled from 100)
            brushingMinigame.brushOffset +=
              brushSpeed * dt * brushingMinigame.brushDirection;

            // Reverse direction when reaching edges (60 pixels from center)
            const maxOffset = 60;
            if (brushingMinigame.brushOffset >= maxOffset) {
              brushingMinigame.brushOffset = maxOffset;
              brushingMinigame.brushDirection = -1; // Move left
            } else if (brushingMinigame.brushOffset <= -maxOffset) {
              brushingMinigame.brushOffset = -maxOffset;
              brushingMinigame.brushDirection = 1; // Move right
            }

            // Spawn dirt particles while brushing (only if there's still dirt)
            // Optimize: cache center calculations (only calculate once per frame)
            if (brushingMinigame.dirtLevel > 0 && Math.random() < 0.3) {
              const centerX = canvas.width / 2;
              const centerY = canvas.height / 2;
              const brushX = centerX + brushingMinigame.brushOffset;
              brushingMinigame.particles.push({
                x: brushX + (Math.random() - 0.5) * 30,
                y: centerY + (Math.random() - 0.5) * 30,
                vx:
                  (Math.random() - 0.5) * 100 +
                  brushingMinigame.brushDirection * 30,
                vy: (Math.random() - 0.5) * 100 - 30, // Fly upward
                life: 1.0, // 0 = dead, 1.0 = fresh
                size: Math.random() * 3 + 2,
              });
            }

            // Brushing reduces dirt level (makes it cleaner)
            brushingMinigame.dirtLevel -= 0.2 * dt;
            brushingMinigame.dirtLevel = Math.max(
              0,
              brushingMinigame.dirtLevel,
            );

            // After at least 5 seconds, dirt is cleaned
            if (brushingMinigame.timeHoldingSpace >= 5.0) {
              // Dirt is now clean
              brushingMinigame.dirtLevel = 0;

              // After the random trigger time (3-8 seconds), start red gradient transition
              if (
                brushingMinigame.timeHoldingSpace >=
                  brushingMinigame.redTriggerTime &&
                brushingMinigame.redness < 1.0
              ) {
                // Gradually increase redness over 1 second
                brushingMinigame.redness +=
                  dt / brushingMinigame.redTransitionTime;
                brushingMinigame.redness = Math.min(
                  1.0,
                  brushingMinigame.redness,
                );
              }

              // Track time since turning red (only after fully red)
              if (brushingMinigame.redness >= 1.0) {
                brushingMinigame.timeSinceRed += dt;

                // If holding space too long after fully red, you break it (lose)
                if (
                  brushingMinigame.timeSinceRed >
                    brushingMinigame.perfectReleaseWindow &&
                  !brushingMinigame.broken
                ) {
                  brushingMinigame.broken = true;
                }
              }
            }
          } else {
            // When not brushing, reset time counter
            brushingMinigame.timeHoldingSpace = 0;

            // Reset brush position to center when not holding space
            brushingMinigame.brushOffset = 0;
            brushingMinigame.brushDirection = 1;

            // If dirt is clean and red, releasing in the perfect window = success!
            if (
              brushingMinigame.dirtLevel <= 0 &&
              brushingMinigame.redness > 0 &&
              !brushingMinigame.completed &&
              !brushingMinigame.broken
            ) {
              // Check if released within the perfect timing window
              if (
                brushingMinigame.timeSinceRed <=
                brushingMinigame.perfectReleaseWindow
              ) {
                brushingMinigame.completed = true; // PERFECT! Maximum reward
              } else {
                brushingMinigame.broken = true; // Missed the window, failed
              }
            }

            // Reset redness when not brushing (dirt returns to normal)
            brushingMinigame.redness = 0;
            brushingMinigame.timeSinceRed = 0;

            // Dirt slowly returns if not fully cleaned
            if (
              brushingMinigame.dirtLevel < 1.0 &&
              !brushingMinigame.completed &&
              !brushingMinigame.broken
            ) {
              brushingMinigame.dirtLevel += 0.15 * dt;
              brushingMinigame.dirtLevel = Math.min(
                1.0,
                brushingMinigame.dirtLevel,
              );
            }
          }

          // Update particles
          for (let i = brushingMinigame.particles.length - 1; i >= 0; i--) {
            const p = brushingMinigame.particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 100 * dt; // Gravity
            p.life -= dt * 2; // Fade out over 0.5 seconds

            // Remove dead particles
            if (p.life <= 0) {
              brushingMinigame.particles.splice(i, 1);
            }
          }

          // End minigame if completed or broken
          if (brushingMinigame.completed || brushingMinigame.broken) {
            // Give reward based on performance
            let multiplier = brushingMinigame.completed ? 3.0 : 1.0; // 3x for perfect timing, 1x for failure
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier *= 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2)
                multiplier *= 2.0; // Iron shovel
              else if (inventory.equipment.tier === 3) multiplier *= 2.5; // Steel shovel
            }
            // Apply 1.5x multiplier for secret X tiles
            if (brushingMinigame.isSecretX) {
              multiplier *= 1.5;
            }

            // Give minigame reward (bullets or grapeshot) when completed successfully
            if (brushingMinigame.completed) {
              const artifact = giveMinigameReward();
              if (artifact) {
                startCelebrationAnimation(artifact);
              }

              // Advance time by 10 seconds when minigame completes
              // This makes the game progress faster
              dayTime.hourTimer += 10;
              // Check if we've advanced past an hour boundary
              if (dayTime.hourTimer >= dayTime.secondsPerHour) {
                dayTime.currentHour++;
                dayTime.hourTimer -= dayTime.secondsPerHour;
              }
            }

            // Tile already converted to grass when interacted with
            brushingMinigame.active = false;
          }
        }

        function handleTypoAnswer(playerSaidReal) {
          if (typoMinigame.answered) return; // Already answered

          // Prevent interaction when tutorial popup is active
          if (tutorial.active && dayTime.currentDay === 0) {
            return;
          }

          typoMinigame.answered = true;

          // Check if player was correct
          // Player said Real (true) and it's actually Real (not fake) = correct
          // Player said Fake (false) and it's actually Fake (isFake = true) = correct
          // Special case: If player calls a real document fake, no penalty (neutral)
          const isCorrect =
            (playerSaidReal && !typoMinigame.isFake) ||
            (!playerSaidReal && typoMinigame.isFake);

          // Check if player called a real document fake (neutral outcome)
          const calledRealFake = !playerSaidReal && !typoMinigame.isFake;

          typoMinigame.wasCorrect = isCorrect;

          let actualReward = 0;
          if (isCorrect) {
            let multiplier = 1.0;
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier = 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2)
                multiplier = 2.0; // Iron shovel
              else if (inventory.equipment.tier === 3)
                multiplier = 2.5; // Steel shovel
              else if (inventory.equipment.tier === 4)
                multiplier = 3.0; // Diamond shovel
              else if (inventory.equipment.tier === 5) multiplier = 4.0; // Legendary shovel
            }
            // Apply 1.5x multiplier for secret X tiles
            if (typoMinigame.isSecretX) {
              multiplier *= 1.5;
            }
            actualReward = Math.round(typoMinigame.baseReward * multiplier);
          } else if (calledRealFake) {
            actualReward = 0;
          } else {
            actualReward = 0;
          }

          typoMinigame.actualReward = actualReward;

          // Give minigame reward (bullets or grapeshot) when answered correctly
          if (isCorrect) {
            const artifact = giveMinigameReward();
            if (artifact) {
              startCelebrationAnimation(artifact);
            }

            // Advance time by 10 seconds when minigame completes
            // This makes the game progress faster
            dayTime.hourTimer += 10;
            // Check if we've advanced past an hour boundary
            if (dayTime.hourTimer >= dayTime.secondsPerHour) {
              dayTime.currentHour++;
              dayTime.hourTimer -= dayTime.secondsPerHour;
            }
          }

          // Tile already converted to grass when interacted with
          // Close minigame after a short delay to show result
          setTimeout(() => {
            typoMinigame.active = false;
          }, 1000); // 1 second delay to show result
        }

        function updateTypoMinigame(dtMs) {
          if (!typoMinigame.active) return;

          // Prevent interaction when tutorial popup is active
          if (tutorial.active && dayTime.currentDay === 0) {
            return;
          }

          // Minigame logic is handled by key presses, no continuous updates needed
        }

        // Handle quiz minigame answer
        // playerSaidYes: true if player clicked Yes, false if clicked No
        function handleQuizAnswer(playerSaidYes) {
          if (quizMinigame.answered) return; // Already answered

          // Prevent interaction when tutorial popup is active
          if (tutorial.active && dayTime.currentDay === 0) {
            return;
          }

          quizMinigame.answered = true;

          // Check if player was correct
          // Player said Yes (true) and correct answer is Yes (true) = correct
          // Player said No (false) and correct answer is No (false) = correct
          const isCorrect = playerSaidYes === quizMinigame.correctAnswer;

          quizMinigame.wasCorrect = isCorrect;

          let actualReward = 0;
          if (isCorrect) {
            let multiplier = 1.0;
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier = 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2)
                multiplier = 2.0; // Iron shovel
              else if (inventory.equipment.tier === 3)
                multiplier = 2.5; // Steel shovel
              else if (inventory.equipment.tier === 4)
                multiplier = 3.0; // Diamond shovel
              else if (inventory.equipment.tier === 5) multiplier = 4.0; // Legendary shovel
            }
            // Apply 1.5x multiplier for secret X tiles
            if (quizMinigame.isSecretX) {
              multiplier *= 1.5;
            }
            actualReward = Math.round(quizMinigame.baseReward * multiplier);
          } else {
            actualReward = 0;
          }

          quizMinigame.actualReward = actualReward;

          // Give minigame reward (bullets or grapeshot) when answered correctly
          if (isCorrect) {
            const artifact = giveMinigameReward();
            if (artifact) {
              startCelebrationAnimation(artifact);
            }

            // Advance time by 10 seconds when minigame completes
            // This makes the game progress faster
            dayTime.hourTimer += 10;
            // Check if we've advanced past an hour boundary
            if (dayTime.hourTimer >= dayTime.secondsPerHour) {
              dayTime.currentHour++;
              dayTime.hourTimer -= dayTime.secondsPerHour;
            }
          }

          // Tile already converted to grass when interacted with
          // Close minigame after a short delay to show result
          setTimeout(() => {
            quizMinigame.active = false;
          }, 1000); // 1 second delay to show result
        }

        function updateQuizMinigame(dtMs) {
          if (!quizMinigame.active) return;

          // Prevent interaction when tutorial popup is active
          if (tutorial.active && dayTime.currentDay === 0) {
            return;
          }

          // Minigame logic is handled by button clicks, no continuous updates needed
        }

        // Minesweeper helper functions
        function placeMines(minesweeper, safeRow, safeCol) {
          // Place mines randomly, but not on the first clicked cell or its neighbors
          const size = minesweeper.gridSize;
          let placed = 0;
          const safeCells = new Set();

          // Mark first click and all neighbors as safe
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const r = safeRow + dr;
              const c = safeCol + dc;
              if (r >= 0 && r < size && c >= 0 && c < size) {
                safeCells.add(`${r},${c}`);
              }
            }
          }

          while (placed < minesweeper.mineCount) {
            const row = Math.floor(Math.random() * size);
            const col = Math.floor(Math.random() * size);
            const key = `${row},${col}`;

            if (!minesweeper.grid[row][col] && !safeCells.has(key)) {
              minesweeper.grid[row][col] = true; // true = mine
              placed++;
            }
          }
        }

        function countAdjacentMines(minesweeper, row, col) {
          let count = 0;
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const r = row + dr;
              const c = col + dc;
              if (
                r >= 0 &&
                r < minesweeper.gridSize &&
                c >= 0 &&
                c < minesweeper.gridSize
              ) {
                if (minesweeper.grid[r][c]) count++;
              }
            }
          }
          return count;
        }

        function revealCell(minesweeper, row, col) {
          if (minesweeper.revealed[row][col] || minesweeper.flagged[row][col])
            return;

          minesweeper.revealed[row][col] = true;

          // If it's a mine, game over - show "Oops!" message
          if (minesweeper.grid[row][col]) {
            minesweeper.gameOver = true;
            minesweeper.gameOverMessage = 'Oops!';
            return;
          }

          // If no adjacent mines, reveal neighbors
          const count = countAdjacentMines(minesweeper, row, col);
          if (count === 0) {
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const r = row + dr;
                const c = col + dc;
                if (
                  r >= 0 &&
                  r < minesweeper.gridSize &&
                  c >= 0 &&
                  c < minesweeper.gridSize
                ) {
                  if (
                    !minesweeper.revealed[r][c] &&
                    !minesweeper.flagged[r][c]
                  ) {
                    revealCell(minesweeper, r, c);
                  }
                }
              }
            }
          }

          // Check win condition
          checkMinesweeperWin(minesweeper);
        }

        function checkMinesweeperWin(minesweeper) {
          // Prevent winning on the first turn (first click)
          // Player must make at least 2 clicks before they can win
          if (minesweeper.clickCount < 2) {
            return; // Don't check for win until player has made at least 2 clicks
          }

          const size = minesweeper.gridSize;
          let revealedCount = 0;
          // Count all revealed cells (excluding mines)
          for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
              // Only count non-mine cells that are revealed
              if (minesweeper.revealed[i][j] && !minesweeper.grid[i][j]) {
                revealedCount++;
              }
            }
          }
          // Win if all non-mine cells are revealed
          const totalCells = size * size;
          const nonMineCells = totalCells - minesweeper.mineCount;
          if (revealedCount >= nonMineCells) {
            minesweeper.won = true;
          }
        }

        function handleMinesweeperClick(minesweeper, row, col, isRightClick) {
          if (minesweeper.gameOver || minesweeper.won) return;

          if (isRightClick) {
            // Right click = toggle flag (limit to 4 flags total)
            if (!minesweeper.revealed[row][col]) {
              const currentlyFlagged = minesweeper.flagged[row][col];

              // Count current flags
              let flagCount = 0;
              for (let r = 0; r < minesweeper.gridSize; r++) {
                for (let c = 0; c < minesweeper.gridSize; c++) {
                  if (minesweeper.flagged[r][c]) flagCount++;
                }
              }

              // Only allow flagging if we have less than 4 flags, or if we're unflagging
              if (!currentlyFlagged && flagCount >= 4) {
                return; // Can't place more flags
              }

              minesweeper.flagged[row][col] = !minesweeper.flagged[row][col];
            }
          } else {
            // Left click = reveal
            if (minesweeper.flagged[row][col]) return; // Can't reveal flagged cells

            // Place mines on first click (ensuring first click is safe)
            if (minesweeper.firstClick) {
              placeMines(minesweeper, row, col);
              minesweeper.firstClick = false;
            }

            // Increment click count before revealing (to track turns for win prevention)
            minesweeper.clickCount++;

            revealCell(minesweeper, row, col);
          }
        }

        function updateMinesweeperMinigame(dtMs) {
          if (!minesweeperMinigame.active) return;

          // Check win condition every frame as a backup (in case revealCell missed it)
          // This ensures the game properly detects when all non-mine tiles are revealed
          if (!minesweeperMinigame.gameOver && !minesweeperMinigame.won) {
            checkMinesweeperWin(minesweeperMinigame);
          }

          // If game over or won, wait a bit then close
          if (minesweeperMinigame.gameOver || minesweeperMinigame.won) {
            // Close after a delay to show result
            setTimeout(() => {
              if (minesweeperMinigame.won) {
                // Give reward for winning
                const artifact = giveMinigameReward();
                if (artifact) {
                  startCelebrationAnimation(artifact);
                }

                // Advance time by 10 seconds when minigame completes
                // This makes the game progress faster
                dayTime.hourTimer += 10;
                // Check if we've advanced past an hour boundary
                if (dayTime.hourTimer >= dayTime.secondsPerHour) {
                  dayTime.currentHour++;
                  dayTime.hourTimer -= dayTime.secondsPerHour;
                }

                // Tile already converted to grass when interacted with
              }

              minesweeperMinigame.active = false;
              minesweeperMinigame.gameOver = false;
              minesweeperMinigame.won = false;
              minesweeperMinigame.gameOverMessage = null;
            }, 2000); // 2 second delay
          }
        }

        function updateRadar(dtMs) {
          if (!radar.active) return;
          // Don't fire radar while in any menu
          if (inventory.open || false) {
            return;
          }

          const dt = dtMs / 1000; // Convert to seconds

          // Calculate player's movement direction
          const playerSpeed = Math.hypot(player.vx, player.vy);
          if (playerSpeed > 0.1) {
            // Player is moving - use velocity direction
            radar.lastDirection.x = player.vx / playerSpeed;
            radar.lastDirection.y = player.vy / playerSpeed;
          }

          // Radar appears behind player (further away)
          const followDistance = 40; // Further away, behind player
          radar.x = player.x - radar.lastDirection.x * followDistance;
          radar.y = player.y - radar.lastDirection.y * followDistance;

          // Update ring timer
          radar.ringTimer += dt;

          // Spawn new ring every 2.5-4 seconds (twice as common)
          const minInterval = 2.5;
          const maxInterval = 4.0;
          if (radar.ringTimer >= minInterval) {
            // Random interval between 2.5-4 seconds
            const randomInterval =
              minInterval + Math.random() * (maxInterval - minInterval);
            if (radar.ringTimer >= randomInterval) {
              // Spawn a new ring in a random direction from radar position
              const angle = Math.random() * Math.PI * 2;
              const speed = 150; // pixels per second
              radar.rings.push({
                x: radar.x,
                y: radar.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0, // Fade out over time
                maxLife: 3.0, // Ring lasts 3 seconds
                foundSecretX: false, // Whether this ring found a secret X
                secretXPos: null, // Position of found secret X
              });
              radar.ringTimer = 0; // Reset timer
            }
          }

          // Update existing rings
          for (let i = radar.rings.length - 1; i >= 0; i--) {
            const ring = radar.rings[i];

            if (ring.foundSecretX) {
              // Ring is returning to player
              const dx = radar.x - ring.x;
              const dy = radar.y - ring.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const speed = 200; // Return speed

              if (dist < 10) {
                // Reached player - remove ring
                radar.rings.splice(i, 1);
                continue;
              }

              // Move towards player
              const invDist = 1 / dist;
              ring.vx = dx * invDist * speed;
              ring.vy = dy * invDist * speed;
            } else {
              // Check collision with secret X tiles
              const ringCol = Math.floor(ring.x / tileSize);
              const ringRow = Math.floor(ring.y / tileSize);

              if (
                ringRow >= 0 &&
                ringRow < tileRows &&
                ringCol >= 0 &&
                ringCol < tileCols
              ) {
                const tile = tileMap[ringRow][ringCol];
                if (tile && tile.name === 'secretX') {
                  // Found a secret X! Make ring return to player
                  ring.foundSecretX = true;
                  ring.secretXPos = { x: ring.x, y: ring.y };

                  // Mark this secret X as discovered (avoid duplicates)
                  const alreadyDiscovered = radar.discoveredSecretX.some(
                    (pos) => pos.row === ringRow && pos.col === ringCol,
                  );
                  if (!alreadyDiscovered) {
                    radar.discoveredSecretX.push({
                      row: ringRow,
                      col: ringCol,
                    });
                  }
                }
              }
            }

            // Update ring position
            ring.x += ring.vx * dt;
            ring.y += ring.vy * dt;

            // Update ring life
            ring.life -= dt / ring.maxLife;

            // Remove dead rings
            if (ring.life <= 0) {
              radar.rings.splice(i, 1);
            }
          }
        }

        // Load New_Tree sprite
        const treeSprite = new Image();
        treeSprite.imageSmoothingEnabled = false;
        treeSprite.src = 'assets/sprites/New_Tree.png';

        // Load shovel sprites from PNG images
        const shovelSprites = {};
        function loadShovelSprite(tier, filename) {
          const sprite = new Image();
          sprite.src = filename;
          sprite.imageSmoothingEnabled = false; // Pixelated rendering
          shovelSprites[tier] = sprite;
          return sprite;
        }

        // Load shovel sprites for each tier (Multipliers)
        loadShovelSprite(1, 'assets/sprites/Trowel.png'); // Simple trowel
        loadShovelSprite(2, 'assets/sprites/Electric_Brush.png'); // Electric brush
        loadShovelSprite(3, 'assets/sprites/steel-shovel.png'); // Iron Sieve
        // Artifact equipment sprites (use steel-shovel for all artifact tools)
        const artifactShovelSprite = new Image();
        artifactShovelSprite.imageSmoothingEnabled = false;
        artifactShovelSprite.src = 'assets/sprites/steel-shovel.png';
        const artifactSpadeSprite = artifactShovelSprite;
        const artifactScoopSprite = artifactShovelSprite;

        // Load radar sprites (optimized: set imageSmoothingEnabled before src)
        const radarSprite = new Image(); // Default (up)
        radarSprite.imageSmoothingEnabled = false;
        radarSprite.src = 'assets/sprites/Radar.png';

        const radarSpriteRight = new Image(); // Right
        radarSpriteRight.imageSmoothingEnabled = false;
        radarSpriteRight.src = 'assets/sprites/Radar-2.png';

        const radarSpriteLeft = new Image(); // Left
        radarSpriteLeft.imageSmoothingEnabled = false;
        radarSpriteLeft.src = 'assets/sprites/Radar-3.png';

        const radarSpriteDown = new Image(); // Down
        radarSpriteDown.imageSmoothingEnabled = false;
        radarSpriteDown.src = 'assets/sprites/Radar-4.png';

        const radarRingSprite = new Image();
        radarRingSprite.imageSmoothingEnabled = false;
        radarRingSprite.src = 'assets/sprites/Radar_Ring.png';

        const flagSprite = new Image();
        flagSprite.imageSmoothingEnabled = false;
        flagSprite.src = 'assets/sprites/Flag.png';

        const dirtTileSprite = new Image();
        dirtTileSprite.imageSmoothingEnabled = false;
        dirtTileSprite.src = 'assets/sprites/Dirt_Tile.png';

        const mineSprite = new Image();
        mineSprite.imageSmoothingEnabled = false;
        mineSprite.src = 'assets/sprites/Mine.png';

        // Initialize allSprites array after ALL sprites are defined
        allSprites = [
          brushSprite,
          speedBrushSprite,
          dirtSprite,
          grassSprite,
          flowerSprite,
          rock1Sprite,
          rock2Sprite,
          newXSprite,
          newBushSprite,
          tallGrassSprite,
          oldGuySprite,
          shopkeeperSprite,
          curatorSprite,
          cannonBuffSprite,
          quickShoesSprite,
          buttonsSprite,
          bulletsSprite,
          grapeshotSprite,
          rustyNailsSprite,
          pinSprite,
          canteenSprite,
          arrowheadSprite,
          cannonShardsSprite,
          cannonSprite,
          displaySprite,
          flagSprite,
          dirtTileSprite,
          mineSprite,
          hotDirtSprite,
          floorTileSprite,
          wallTileSprite,
          wallDoorSprite,
          playerSpriteIdle,
          playerSpriteBack,
          playerSpriteBackWalk1,
          playerSpriteBackWalk2,
          playerSpriteWalk1,
          playerSpriteWalk2,
          playerSpriteCrouch1,
          playerSpriteCrouch2,
          radarSprite,
          radarSpriteRight,
          radarSpriteLeft,
          radarSpriteDown,
          radarRingSprite,
          treeSprite,
          trophySprite,
        ];

        // Radar system
        const radar = {
          active: false, // Whether player owns radar (equipped in inventory)
          x: 0, // Position (follows behind player)
          y: 0,
          ringTimer: 0, // Timer for next ring
          rings: [], // Active radar rings
          discoveredSecretX: [], // Array of discovered secret X positions {row, col}
          lastDirection: { x: 0, y: -1 }, // Last movement direction (default: up)
          lastSpriteDirection: 'up', // Last sprite direction: 'up', 'down', 'left', 'right'
        };

        // Quest system
        const quests = {
          findArtifactWithRadar: {
            active: false, // Whether quest is active
            completed: false, // Whether quest is completed
          },
          getCannonForCannonBuff: {
            active: false, // Whether quest is active
            completed: false, // Whether quest is completed
          },
        };

        function drawFlora() {
          // Viewport culling: only draw trees visible on screen
          const halfCanvasW = canvas.width / 2;
          const halfCanvasH = canvas.height / 2;
          const viewLeft = camera.x - halfCanvasW;
          const viewTop = camera.y - halfCanvasH;
          const viewRight = camera.x + halfCanvasW;
          const viewBottom = camera.y + halfCanvasH;
          const padding = 120; // Extra padding to account for tree size
          // Use tree sprite dimensions (fallback to tileCell8 if not loaded yet)
          const spriteWidth =
            treeSprite.complete && treeSprite.naturalWidth > 0
              ? treeSprite.width
              : tileCell * 8;
          const spriteHeight =
            treeSprite.complete && treeSprite.naturalHeight > 0
              ? treeSprite.height
              : tileCell * 8;
          const spriteHalfW = spriteWidth / 2;
          const spriteHalfH = spriteHeight / 2;
          const tileCell8 = tileCell * 8;

          ctx.save();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Set once outside loop

          for (let i = 0; i < flora.trees.length; i++) {
            const tree = flora.trees[i];
            const halfSize = tree.size / 2;

            // Skip trees outside viewport (optimized bounds check)
            if (
              tree.x + halfSize < viewLeft - padding ||
              tree.x - halfSize > viewRight + padding ||
              tree.y + halfSize < viewTop - padding ||
              tree.y - halfSize > viewBottom + padding
            ) {
              continue;
            }

            ctx.save();
            ctx.translate(Math.round(tree.x) + 0.5, Math.round(tree.y) + 0.5);
            ctx.rotate(tree.rotation);

            // Draw shadow
            const shadowRadius = tree.size * 0.45;
            ctx.beginPath();
            ctx.ellipse(
              0,
              tree.size * 0.4,
              shadowRadius,
              tree.size * 0.2,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();

            // Draw tree
            if (treeSprite.complete && treeSprite.naturalWidth > 0) {
              const scale = tree.size / treeSprite.height; // Use actual sprite height for scaling
              ctx.scale(scale, scale);
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                treeSprite,
                -treeSprite.width / 2,
                -treeSprite.height / 2,
              );
            }
            ctx.restore();
          }

          ctx.restore();
        }

        function drawJoseph() {
          ctx.save();

          // Draw Joseph sprite
          if (shopkeeperSprite.complete && shopkeeperSprite.naturalWidth > 0) {
            // Use actual sprite dimensions for proper scaling
            const spriteWidth = shopkeeperSprite.naturalWidth;
            const spriteHeight = shopkeeperSprite.naturalHeight;
            const maxDimension = Math.max(spriteWidth, spriteHeight, 1); // Ensure at least 1 to avoid division by zero
            const scale = 43 / maxDimension; // Scale to match player size (43px)
            const scaledWidth = spriteWidth * scale;
            const scaledHeight = spriteHeight * scale;

            // Joseph shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              joseph.x,
              joseph.y + scaledHeight * 0.35,
              scaledWidth * 0.5,
              scaledHeight * 0.22,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();

            const px = Math.round(joseph.x - scaledWidth / 2);
            const py = Math.round(joseph.y - scaledHeight / 2);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(shopkeeperSprite, px, py, scaledWidth, scaledHeight);

            // Draw Radar sprite next to Joseph (to the right)
            // Make radar bigger and add collision
            if (radarSprite.complete && radarSprite.naturalWidth > 0) {
              const radarSpriteSize = 43; // Same size as player/Joseph (was 32)
              const radarOffsetX = 50; // Position to the right of Joseph (increased from 35)
              const radarX = Math.round(joseph.x + radarOffsetX);
              const radarY = Math.round(joseph.y - radarSpriteSize / 2);

              // Radar shadow
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                radarX,
                radarY + radarSpriteSize * 0.35,
                radarSpriteSize * 0.5,
                radarSpriteSize * 0.22,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();

              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                radarSprite,
                radarX - radarSpriteSize / 2,
                radarY,
                radarSpriteSize,
                radarSpriteSize,
              );
            }
          } else {
            // Fallback while loading
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              joseph.x,
              joseph.y + joseph.radius * 0.4,
              joseph.radius * 0.6,
              joseph.radius * 0.2,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();

            ctx.fillStyle = '#8b6f47';
            ctx.beginPath();
            ctx.arc(joseph.x, joseph.y, joseph.radius, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        function drawOldGuy() {
          ctx.save();

          // Draw old guy sprite
          if (oldGuySprite.complete && oldGuySprite.naturalWidth > 0) {
            // Scale to match player size (43x43, 10% bigger than original 39x39)
            const spriteWidth = 43;
            const spriteHeight = 43;

            // Old guy shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              oldGuy.x,
              oldGuy.y + spriteHeight * 0.35,
              spriteWidth * 0.5,
              spriteHeight * 0.22,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();

            const px = Math.round(oldGuy.x - spriteWidth / 2);
            const py = Math.round(oldGuy.y - spriteHeight / 2);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(oldGuySprite, px, py, spriteWidth, spriteHeight);
          }

          ctx.restore();
        }

        // Warning Guy NPC rendering (uses same scale/shadow style as Old Guy)
        function drawWarningGuy() {
          ctx.save();

          if (warningGuySprite.complete && warningGuySprite.naturalWidth > 0) {
            // Match Old Guy's on-screen size for consistency
            const spriteWidth = 43;
            const spriteHeight = 43;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              warningGuy.x,
              warningGuy.y + spriteHeight * 0.35,
              spriteWidth * 0.5,
              spriteHeight * 0.22,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();

            // Draw sprite centered on NPC position
            const px = Math.round(warningGuy.x - spriteWidth / 2);
            const py = Math.round(warningGuy.y - spriteHeight / 2);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(warningGuySprite, px, py, spriteWidth, spriteHeight);
          } else {
            // Simple fallback circle while the sprite is loading/missing
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              warningGuy.x,
              warningGuy.y + warningGuy.radius * 0.4,
              warningGuy.radius * 0.6,
              warningGuy.radius * 0.2,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();

            ctx.fillStyle = '#8b6f47';
            ctx.beginPath();
            ctx.arc(
              warningGuy.x,
              warningGuy.y,
              warningGuy.radius,
              0,
              Math.PI * 2,
            );
            ctx.fill();
          }

          ctx.restore();
        }

        function drawRadar() {
          if (!radar.active) return;

          ctx.save();
          ctx.imageSmoothingEnabled = false;

          // Select radar sprite based on player's movement direction
          // Update sprite direction when moving, keep last direction when stopped
          const playerSpeed = Math.hypot(player.vx, player.vy);

          if (playerSpeed > 0.1) {
            // Player is moving - determine dominant direction and update
            const absVx = Math.abs(player.vx);
            const absVy = Math.abs(player.vy);

            if (absVx > absVy) {
              // Horizontal movement is dominant
              if (player.vx > 0) {
                radar.lastSpriteDirection = 'right';
              } else {
                radar.lastSpriteDirection = 'left';
              }
            } else if (absVy > absVx) {
              // Vertical movement is dominant
              if (player.vy > 0) {
                radar.lastSpriteDirection = 'down';
              } else {
                radar.lastSpriteDirection = 'up';
              }
            }
            // If absVx === absVy, keep current direction
          }

          // Use the stored sprite direction (persists when stopped)
          let currentRadarSprite = radarSprite; // Default: up
          if (radar.lastSpriteDirection === 'right') {
            currentRadarSprite = radarSpriteRight;
          } else if (radar.lastSpriteDirection === 'left') {
            currentRadarSprite = radarSpriteLeft;
          } else if (radar.lastSpriteDirection === 'down') {
            currentRadarSprite = radarSpriteDown;
          } else {
            currentRadarSprite = radarSprite; // up
          }

          // Draw radar sprite (appears in front of player, same size as player)
          const radarSize = player.width; // Same size as player (43x43)
          const px = Math.round(radar.x - radarSize / 2);
          const py = Math.round(radar.y - radarSize / 2);
          if (
            currentRadarSprite.complete &&
            currentRadarSprite.naturalWidth > 0
          ) {
            ctx.drawImage(currentRadarSprite, px, py, radarSize, radarSize);
          } else {
            // Fallback: draw grey square if sprite didn't load (for missing Radar-2, Radar-3, Radar-4 sprites)
            ctx.fillStyle = '#808080'; // Grey color
            ctx.fillRect(px, py, radarSize, radarSize);
            ctx.strokeStyle = '#606060'; // Darker grey border
            ctx.lineWidth = 2;
            ctx.strokeRect(px, py, radarSize, radarSize);
          }

          // Draw radar rings (bigger)
          if (radarRingSprite.complete && radarRingSprite.naturalWidth > 0) {
            for (let i = 0; i < radar.rings.length; i++) {
              const ring = radar.rings[i];
              const ringSize = 60; // Bigger ring size (doubled from 30)
              const alpha = ring.life; // Fade out as life decreases

              ctx.globalAlpha = alpha;
              const px = Math.round(ring.x - ringSize / 2);
              const py = Math.round(ring.y - ringSize / 2);
              ctx.drawImage(radarRingSprite, px, py, ringSize, ringSize);
            }
            ctx.globalAlpha = 1.0; // Reset alpha
          }

          // Draw markers for discovered secret X tiles (viewport culling for performance)
          ctx.imageSmoothingEnabled = false;
          const viewLeft = camera.x - canvas.width / 2;
          const viewTop = camera.y - canvas.height / 2;
          const viewRight = camera.x + canvas.width / 2;
          const viewBottom = camera.y + canvas.height / 2;

          for (let i = 0; i < radar.discoveredSecretX.length; i++) {
            const pos = radar.discoveredSecretX[i];
            const worldX = (pos.col + 0.5) * tileSize;
            const worldY = (pos.row + 0.5) * tileSize;

            // Viewport culling: only draw if visible
            if (
              worldX < viewLeft - tileSize ||
              worldX > viewRight + tileSize ||
              worldY < viewTop - tileSize ||
              worldY > viewBottom + tileSize
            ) {
              continue;
            }

            // Draw yellow X sprite directly (no tinting needed - sprite is already yellow)
            if (yellowXSprite.complete && yellowXSprite.naturalWidth > 0) {
              ctx.drawImage(
                yellowXSprite,
                worldX - tileSize / 2,
                worldY - tileSize / 2,
                tileSize,
                tileSize,
              );
            }
          }

          ctx.restore();
        }

        function drawMuseum() {
          ctx.save();
          ctx.imageSmoothingEnabled = false;

          const museumTileSize = tileSize;
          const museumWorldWidth = museum.width * museumTileSize;
          const museumWorldHeight = museum.height * museumTileSize;

          // Calculate offset to center museum horizontally and place it at bottom
          // Museum is 320x320, canvas is 800x500
          // To center horizontally: offsetX = (canvas.width - museumWorldWidth) / 2
          // To place at bottom: offsetY = canvas.height - museumWorldHeight
          const offsetX = (canvas.width - museumWorldWidth) / 2;
          const offsetY = canvas.height - museumWorldHeight;
          ctx.translate(offsetX, offsetY);

          // Draw floor tiles (10x10 grid)
          for (let row = 0; row < museum.height; row++) {
            for (let col = 0; col < museum.width; col++) {
              const tileX = col * museumTileSize;
              const tileY = row * museumTileSize;

              // Draw floor tile
              if (
                floorTileSprite.complete &&
                floorTileSprite.naturalWidth > 0
              ) {
                ctx.drawImage(
                  floorTileSprite,
                  tileX,
                  tileY,
                  museumTileSize,
                  museumTileSize,
                );
              } else {
                // Fallback grey floor
                ctx.fillStyle = '#808080';
                ctx.fillRect(tileX, tileY, museumTileSize, museumTileSize);
              }
            }
          }

          // Draw walls (top, left, right, bottom)
          // Top wall
          for (let col = 0; col < museum.width; col++) {
            const tileX = col * museumTileSize;
            const tileY = 0;
            if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
              ctx.drawImage(
                wallTileSprite,
                tileX,
                tileY,
                museumTileSize,
                museumTileSize,
              );
            }
          }
          // Left wall
          for (let row = 0; row < museum.height; row++) {
            const tileX = 0;
            const tileY = row * museumTileSize;
            if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
              ctx.drawImage(
                wallTileSprite,
                tileX,
                tileY,
                museumTileSize,
                museumTileSize,
              );
            }
          }
          // Right wall
          for (let row = 0; row < museum.height; row++) {
            const tileX = (museum.width - 1) * museumTileSize;
            const tileY = row * museumTileSize;
            if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
              ctx.drawImage(
                wallTileSprite,
                tileX,
                tileY,
                museumTileSize,
                museumTileSize,
              );
            }
          }
          // Bottom wall (with door in middle)
          for (let col = 0; col < museum.width; col++) {
            const tileX = col * museumTileSize;
            const tileY = (museum.height - 1) * museumTileSize;

            if (col === museum.doorCol) {
              // Draw door sprite
              if (wallDoorSprite.complete && wallDoorSprite.naturalWidth > 0) {
                ctx.drawImage(
                  wallDoorSprite,
                  tileX,
                  tileY,
                  museumTileSize,
                  museumTileSize,
                );
              } else {
                // Fallback door (different color)
                ctx.fillStyle = '#654321';
                ctx.fillRect(tileX, tileY, museumTileSize, museumTileSize);
              }
            } else {
              // Draw wall tile
              if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
                ctx.drawImage(
                  wallTileSprite,
                  tileX,
                  tileY,
                  museumTileSize,
                  museumTileSize,
                );
              }
            }
          }

          // Draw cannon display sprites in the center tiles (one flipped)
          // Position slightly above center (move up 2 rows)
          const cannonRow = Math.floor(museum.height / 2) - 2;
          const leftCannonCol = Math.floor(museum.width / 2) - 1;
          const rightCannonCol = leftCannonCol + 1;
          const cannonSize = Math.floor(museumTileSize * 1.5); // Make cannons 1.5x tile size
          const cannonOffsetX = (cannonSize - museumTileSize) / 2; // Center within tile
          const cannonOffsetY = (cannonSize - museumTileSize) / 2;
          const leftCannonX = leftCannonCol * museumTileSize - cannonOffsetX;
          const rightCannonX = rightCannonCol * museumTileSize - cannonOffsetX;
          const cannonY = cannonRow * museumTileSize - cannonOffsetY;

          if (
            cannonDisplaySprite.complete &&
            cannonDisplaySprite.naturalWidth > 0
          ) {
            ctx.drawImage(
              cannonDisplaySprite,
              leftCannonX,
              cannonY,
              cannonSize,
              cannonSize,
            );

            // Flip the right cannon horizontally inside its tile
            ctx.save();
            ctx.translate(rightCannonX + cannonSize, cannonY);
            ctx.scale(-1, 1);
            ctx.drawImage(cannonDisplaySprite, 0, 0, cannonSize, cannonSize);
            ctx.restore();

            // Draw cannon artifact if placed in cannon display
            if (
              museum.cannonDisplay &&
              museum.cannonDisplay.artifact &&
              museum.cannonDisplay.artifact.sprite &&
              museum.cannonDisplay.artifact.sprite.complete &&
              museum.cannonDisplay.artifact.sprite.naturalWidth > 0
            ) {
              const cannonArtifactSprite = museum.cannonDisplay.artifact.sprite;
              // Draw cannon artifact centered in the 1x2 cannon display (spans both tiles)
              // Preserve aspect ratio - cannon is wider than tall
              const cannonTileWidth = museumTileSize * 2; // 2 tiles wide for cannon display
              const cannonTileHeight = museumTileSize * 1.5; // 1.5 tiles tall
              const spriteAspectRatio =
                cannonArtifactSprite.naturalWidth /
                cannonArtifactSprite.naturalHeight;

              let artifactWidth = cannonTileWidth * 1.0; // Use 100% of width (bigger)
              let artifactHeight = artifactWidth / spriteAspectRatio; // Maintain aspect ratio

              // If height is too tall, scale down based on height instead
              if (artifactHeight > cannonTileHeight * 0.9) {
                artifactHeight = cannonTileHeight * 0.9; // Use 90% of height (bigger)
                artifactWidth = artifactHeight * spriteAspectRatio;
              }

              const cannonArtifactX =
                leftCannonCol * museumTileSize +
                (cannonTileWidth - artifactWidth) / 2; // Center horizontally
              const cannonArtifactY =
                cannonRow * museumTileSize +
                (museumTileSize - artifactHeight) / 2; // Center vertically

              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                cannonArtifactSprite,
                cannonArtifactX,
                cannonArtifactY,
                artifactWidth,
                artifactHeight,
              );
            }
          } else {
            // Fallback rectangles if the sprite isn't ready yet
            ctx.fillStyle = '#5a5a5a';
            ctx.fillRect(leftCannonX, cannonY, cannonSize, cannonSize);
            ctx.fillRect(rightCannonX, cannonY, cannonSize, cannonSize);
          }

          // Draw display cases and artifacts
          for (let i = 0; i < museum.displayCases.length; i++) {
            const displayCase = museum.displayCases[i];
            const caseX = displayCase.col * museumTileSize;
            const caseY = displayCase.row * museumTileSize;
            const displaySize = Math.round(museumTileSize * 1.265); // Increased by 15% (1.1 * 1.15 = 1.265)
            const displayOffset = (displaySize - museumTileSize) / 2;

            // Draw display case sprite
            if (displaySprite.complete && displaySprite.naturalWidth > 0) {
              ctx.drawImage(
                displaySprite,
                caseX - displayOffset,
                caseY - displayOffset,
                displaySize,
                displaySize,
              );
            } else {
              // Fallback: simple rectangle if sprite not loaded
              ctx.strokeStyle = museum.buildMode ? '#ffff00' : '#888888';
              ctx.lineWidth = 2;
              ctx.strokeRect(
                caseX + 4 - displayOffset,
                caseY + 4 - displayOffset,
                displaySize - 8,
                displaySize - 8,
              );
            }

            // Draw artifact if placed
            if (displayCase.artifact && displayCase.artifact.sprite) {
              const sprite = displayCase.artifact.sprite;
              if (sprite.complete && sprite.naturalWidth > 0) {
                const artifactSize = displaySize - 8;
                const artifactX = caseX + 4 - displayOffset;
                const artifactY = caseY + 4 - displayOffset;

                // Special handling for Arrowhead - rotate 90 degrees
                if (displayCase.artifact.name === 'Arrowhead') {
                  ctx.save();
                  ctx.translate(
                    artifactX + artifactSize / 2,
                    artifactY + artifactSize / 2,
                  );
                  ctx.rotate(Math.PI / 2); // 90 degrees
                  ctx.imageSmoothingEnabled = false;
                  ctx.drawImage(
                    sprite,
                    -artifactSize / 2,
                    -artifactSize / 2,
                    artifactSize,
                    artifactSize,
                  );
                  ctx.restore();
                } else {
                  ctx.drawImage(
                    sprite,
                    artifactX,
                    artifactY,
                    artifactSize,
                    artifactSize,
                  );
                }
              }
            }
          }

          ctx.restore();
        }

        function drawMuseumDoorPrompt() {
          ctx.save();

          // Background overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Prompt panel
          const panelWidth = 400;
          const panelHeight = 200;
          const panelX = (canvas.width - panelWidth) / 2;
          const panelY = (canvas.height - panelHeight) / 2;

          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

          // Prompt text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(
            'Continue to next day?',
            panelX + panelWidth / 2,
            panelY + 30,
          );

          // Continue button (green)
          const buttonWidth = 120;
          const buttonHeight = 50;
          const buttonSpacing = 40;
          const continueButtonX =
            panelX + panelWidth / 2 - buttonWidth - buttonSpacing / 2;
          const stayButtonX = panelX + panelWidth / 2 + buttonSpacing / 2;
          const buttonY = panelY + panelHeight - buttonHeight - 30;

          // Check if mouse is hovering over buttons
          const hoverContinue =
            mouseX >= continueButtonX &&
            mouseX <= continueButtonX + buttonWidth &&
            mouseY >= buttonY &&
            mouseY <= buttonY + buttonHeight;
          const hoverStay =
            mouseX >= stayButtonX &&
            mouseX <= stayButtonX + buttonWidth &&
            mouseY >= buttonY &&
            mouseY <= buttonY + buttonHeight;

          // Continue button (highlight when hovering)
          ctx.fillStyle = hoverContinue ? '#69db7c' : '#51cf66'; // Lighter green when hovering
          ctx.fillRect(continueButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = hoverContinue ? 3 : 2; // Thicker border when hovering
          ctx.strokeRect(continueButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(
            'Continue',
            continueButtonX + buttonWidth / 2,
            buttonY + buttonHeight / 2,
          );

          // Stay button (highlight when hovering)
          ctx.fillStyle = hoverStay ? '#ff8787' : '#ff6b6b'; // Lighter red when hovering
          ctx.fillRect(stayButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = hoverStay ? 3 : 2; // Thicker border when hovering
          ctx.strokeRect(stayButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText(
            'Stay',
            stayButtonX + buttonWidth / 2,
            buttonY + buttonHeight / 2,
          );

          ctx.restore();
        }

        function render() {
          // A full-screen fill clears the previous frame more efficiently than clearRect
          ctx.fillStyle = world.bg;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Check if in museum state
          if (gameState === 'museum') {
            // Fill background with black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw museum directly (no camera translation - positioned at bottom)
            drawMuseum();
            ctx.restore(); // Close the translate from drawMuseum

            // Draw player (need to apply same offset as museum)
            ctx.save();
            const museumTileSize = tileSize;
            const museumWorldWidth = museum.width * museumTileSize;
            const museumWorldHeight = museum.height * museumTileSize;
            const offsetX = (canvas.width - museumWorldWidth) / 2;
            const offsetY = canvas.height - museumWorldHeight;
            ctx.translate(offsetX, offsetY);

            // Player shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              player.x,
              player.y + player.height * 0.35,
              player.width * 0.5,
              player.height * 0.22,
              0,
              0,
              Math.PI * 2,
            );
            ctx.fill();

            // Player sprite (optimize: use squared distance)
            const speedSq = player.vx * player.vx + player.vy * player.vy;
            const isMoving = speedSq > 0.01; // 0.1^2 = 0.01
            const isMovingUp = player.vy < -0.1;
            let currentSprite;
            if (isMovingUp) {
              if (isMoving) {
                const walkFrame = Math.floor(walkAnimationFrame) % 2;
                currentSprite =
                  walkFrame === 0
                    ? playerSpriteBackWalk1
                    : playerSpriteBackWalk2;
              } else {
                currentSprite = playerSpriteBack;
              }
            } else if (isMoving) {
              const walkFrame = Math.floor(walkAnimationFrame) % 2;
              currentSprite =
                walkFrame === 0 ? playerSpriteWalk1 : playerSpriteWalk2;
            } else {
              currentSprite = playerSpriteIdle;
            }

            if (currentSprite.complete && currentSprite.naturalWidth > 0) {
              const px = Math.round(player.x - player.width / 2);
              const py = Math.round(player.y - player.height / 2);
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(currentSprite, px, py, player.width, player.height);
            }

            ctx.restore();

            // Draw curator (use same offset as player in museum)
            ctx.save();
            // Use same offset calculation as player drawing
            const curatorMuseumTileSize = tileSize;
            const curatorMuseumWorldWidth =
              museum.width * curatorMuseumTileSize;
            const curatorMuseumWorldHeight =
              museum.height * curatorMuseumTileSize;
            const curatorMuseumOffsetX =
              (canvas.width - curatorMuseumWorldWidth) / 2;
            const curatorMuseumOffsetY =
              canvas.height - curatorMuseumWorldHeight;
            ctx.translate(curatorMuseumOffsetX, curatorMuseumOffsetY);

            // Draw curator sprite (same pattern as shopkeeper/oldGuy/candyKid)
            if (curatorSprite.complete && curatorSprite.naturalWidth > 0) {
              const spriteWidth = 43; // Match player size
              const spriteHeight = 43;

              // Curator shadow
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                curator.x,
                curator.y + spriteHeight * 0.35,
                spriteWidth * 0.5,
                spriteHeight * 0.22,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();

              const px = Math.round(curator.x - spriteWidth / 2);
              const py = Math.round(curator.y - spriteHeight / 2);
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(curatorSprite, px, py, spriteWidth, spriteHeight);
            } else {
              // Fallback while loading (same pattern as shopkeeper)
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                curator.x,
                curator.y + curator.radius * 0.4,
                curator.radius * 0.6,
                curator.radius * 0.2,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();

              ctx.fillStyle = '#8b4caf'; // Purple color for curator placeholder
              ctx.strokeStyle = '#6a3d8c';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(curator.x, curator.y, curator.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            }

            ctx.restore();

            // Draw cannonBuff (use same offset as player in museum)
            ctx.save();
            // Use same offset calculation as player drawing
            const cannonBuffMuseumTileSize = tileSize;
            const cannonBuffMuseumWorldWidth =
              museum.width * cannonBuffMuseumTileSize;
            const cannonBuffMuseumWorldHeight =
              museum.height * cannonBuffMuseumTileSize;
            const cannonBuffMuseumOffsetX =
              (canvas.width - cannonBuffMuseumWorldWidth) / 2;
            const cannonBuffMuseumOffsetY =
              canvas.height - cannonBuffMuseumWorldHeight;
            ctx.translate(cannonBuffMuseumOffsetX, cannonBuffMuseumOffsetY);

            // Draw cannonBuff sprite (same pattern as curator)
            if (
              cannonBuffSprite.complete &&
              cannonBuffSprite.naturalWidth > 0
            ) {
              const spriteWidth = 43; // Match player size
              const spriteHeight = 43;

              // CannonBuff shadow
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                cannonBuff.x,
                cannonBuff.y + spriteHeight * 0.35,
                spriteWidth * 0.5,
                spriteHeight * 0.22,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();

              const px = Math.round(cannonBuff.x - spriteWidth / 2);
              const py = Math.round(cannonBuff.y - spriteHeight / 2);
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                cannonBuffSprite,
                px,
                py,
                spriteWidth,
                spriteHeight,
              );
            } else {
              // Fallback while loading (same pattern as curator)
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                cannonBuff.x,
                cannonBuff.y + cannonBuff.radius * 0.4,
                cannonBuff.radius * 0.6,
                cannonBuff.radius * 0.2,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();

              ctx.fillStyle = '#8b6914'; // Brown color for cannonBuff placeholder
              ctx.strokeStyle = '#654321';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(
                cannonBuff.x,
                cannonBuff.y,
                cannonBuff.radius,
                0,
                Math.PI * 2,
              );
              ctx.fill();
              ctx.stroke();
            }

            ctx.restore();

            // Draw door prompt if active
            if (museum.doorPrompt) {
              drawMuseumDoorPrompt();
            }

            // Draw dialogue box if curator or cannonBuff (or any NPC) has dialogue
            if (curator.dialogue || cannonBuff.dialogue) {
              drawDialogueBox();
            }

            // Draw build mode inventory panel
            if (museum.buildMode) {
              drawBuildModeInventoryPanel();
            }

            return; // Don't render normal game elements in museum
          }

          // World space: translate so that camera is centered
          ctx.save();
          ctx.translate(
            Math.round(canvas.width / 2 - camera.x),
            Math.round(canvas.height / 2 - camera.y),
          );

          drawTiles();
          drawFlora();

          // Old Guy NPC
          drawOldGuy();

          // Warning Guy NPC (new, to the left of spawn)
          drawWarningGuy();

          // Joseph NPC (shopkeeper with radar)
          drawJoseph();

          // Radar and radar rings
          drawRadar();

          // Player shadow
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
          ctx.ellipse(
            player.x,
            player.y + player.height * 0.35,
            player.width * 0.5,
            player.height * 0.22,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Player sprite - use back sprite when moving upward, walking sprites when moving (optimize: use squared distance)
          const playerSpeedSq = player.vx * player.vx + player.vy * player.vy;
          const isMoving = playerSpeedSq > 0.01; // 0.1^2 = 0.01
          const isMovingUp = player.vy < -0.1; // Small threshold to prevent flickering
          let currentSprite;

          // Show celebration animation when active (player holds artifact over head)
          if (celebrationAnimation.active) {
            // Use raised hands sprite during celebration
            currentSprite = playerSpriteRaisedHands;
          } else if (crouchAnimation.active) {
            // Show crouch animation when active (semi-rapidly switches between crouch sprites)
            // Switch between crouch sprites every 0.15 seconds (semi-rapid animation)
            const crouchFrame = Math.floor(crouchAnimation.timer / 0.15) % 2;
            currentSprite =
              crouchFrame === 0 ? playerSpriteCrouch1 : playerSpriteCrouch2;
          } else if (isMovingUp) {
            // Alternate between back walk sprites when moving up
            if (isMoving) {
              const walkFrame = Math.floor(walkAnimationFrame) % 2;
              currentSprite =
                walkFrame === 0 ? playerSpriteBackWalk1 : playerSpriteBackWalk2;
            } else {
              // Use idle back sprite when not moving but facing up
              currentSprite = playerSpriteBack;
            }
          } else if (isMoving) {
            // Alternate between walk sprites when moving
            const walkFrame = Math.floor(walkAnimationFrame) % 2;
            currentSprite =
              walkFrame === 0 ? playerSpriteWalk1 : playerSpriteWalk2;
          } else {
            // Use idle sprite when not moving
            currentSprite = playerSpriteIdle;
          }

          if (currentSprite.complete && currentSprite.naturalWidth > 0) {
            const px = Math.round(player.x - player.width / 2);
            const py = Math.round(player.y - player.height / 2);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(currentSprite, px, py, player.width, player.height);
          } else {
            // Fallback while loading
            ctx.fillStyle = player.color;
            ctx.strokeStyle = player.outline;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(
              Math.round(player.x - player.width / 2) + 0.5,
              Math.round(player.y - player.height / 2) + 0.5,
              player.width,
              player.height,
            );
            ctx.fill();
            ctx.stroke();
          }

          // Celebration animation: Draw spinning star and artifact above player's head
          if (celebrationAnimation.active && celebrationAnimation.artifact) {
            const artifact = celebrationAnimation.artifact;
            const artifactSprite = artifact.sprite;

            // Position above player's head
            const artifactY = player.y - player.height / 2 - 30; // 30 pixels above player
            const artifactX = player.x;

            // Draw spinning star behind artifact (white star)
            if (starSprite.complete && starSprite.naturalWidth > 0) {
              ctx.save();
              ctx.translate(artifactX, artifactY);
              ctx.rotate(celebrationAnimation.starRotation);
              ctx.imageSmoothingEnabled = false;
              // Draw star centered at origin (after translation)
              const starSize = 56; // Size of the star (increased from 32 for more visibility)
              ctx.drawImage(
                starSprite,
                -starSize / 2,
                -starSize / 2,
                starSize,
                starSize,
              );
              ctx.restore();
            }

            // Draw artifact in front of star
            if (artifactSprite.complete && artifactSprite.naturalWidth > 0) {
              ctx.imageSmoothingEnabled = false;
              const artifactSize = 40; // Size of artifact sprite (increased from 24 for more visibility)

              // Special handling for Arrowhead - rotate 90 degrees
              if (artifact.name === 'Arrowhead') {
                ctx.save();
                ctx.translate(artifactX, artifactY);
                ctx.rotate(Math.PI / 2); // 90 degrees
                ctx.drawImage(
                  artifactSprite,
                  -artifactSize / 2,
                  -artifactSize / 2,
                  artifactSize,
                  artifactSize,
                );
                ctx.restore();
              } else {
                ctx.drawImage(
                  artifactSprite,
                  artifactX - artifactSize / 2,
                  artifactY - artifactSize / 2,
                  artifactSize,
                  artifactSize,
                );
              }
            }
          }

          // Direction indicator - small black arrow triangle
          const dirX = player.vx;
          const dirY = player.vy;
          const dirSpeedSq = dirX * dirX + dirY * dirY;
          if (dirSpeedSq > 0.04) {
            // 0.2^2 = 0.04
            const speed = Math.sqrt(dirSpeedSq);
            const nx = dirX / speed;
            const ny = dirY / speed;

            // Position arrow outside player bounds (player radius + offset)
            const playerRadius = Math.max(player.width, player.height) / 2;
            const arrowDistance = playerRadius + 12; // Distance from player center
            const arrowX = player.x + nx * arrowDistance;
            const arrowY = player.y + ny * arrowDistance;

            // Draw small black triangle arrow
            const arrowSize = 6; // Size of the arrow
            const angle = Math.atan2(ny, nx);

            ctx.save();
            ctx.fillStyle = '#000000'; // Black arrow
            ctx.translate(arrowX, arrowY);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(arrowSize, 0); // Tip of arrow
            ctx.lineTo(-arrowSize * 0.6, -arrowSize * 0.6); // Bottom left
            ctx.lineTo(-arrowSize * 0.6, arrowSize * 0.6); // Bottom right
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          // Optional: draw world bounds
          ctx.strokeStyle = 'rgba(139,111,71,0.25)'; // Brown world bounds
          ctx.lineWidth = 2;
          ctx.strokeRect(0.5, 0.5, world.width - 1, world.height - 1);

          // End world space
          ctx.restore();

          // Draw crouch animation particles (screen space)
          if (crouchAnimation.active && crouchAnimation.particles.length > 0) {
            ctx.save();
            for (const p of crouchAnimation.particles) {
              ctx.globalAlpha = p.life; // Fade out as life decreases
              ctx.fillStyle = '#8b4513'; // Brown dirt color
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }

          // UI: Quest system (top-left, above stamina bar)
          let questUIHeight = 0;
          if (
            quests &&
            quests.findArtifactWithRadar &&
            quests.findArtifactWithRadar.active &&
            !quests.findArtifactWithRadar.completed
          ) {
            ctx.save();
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffffff';

            const questX = 16.5;
            const questY = 14.5;

            // Draw "Quests" label
            ctx.fillText('Quests', questX, questY);

            // Draw quest description below
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillStyle = '#e8eaf6';
            ctx.fillText(
              'Find an artifact using the Radar',
              questX,
              questY + 18,
            );

            questUIHeight = 36; // Height of quest UI (18 + 18 spacing)
            ctx.restore();
          }

          // Check for cannon buff quest
          if (
            quests &&
            quests.getCannonForCannonBuff &&
            quests.getCannonForCannonBuff.active &&
            !quests.getCannonForCannonBuff.completed
          ) {
            ctx.save();
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffffff';

            const questX = 16.5;
            const questY = 14.5 + questUIHeight;

            // Draw "Quests" label if this is the first quest
            if (questUIHeight === 0) {
              ctx.fillText('Quests', questX, questY);
            }

            // Draw quest description below
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillStyle = '#e8eaf6';
            ctx.fillText(
              'Get a cannon for the Cannon Buff',
              questX,
              questY + (questUIHeight === 0 ? 18 : 0),
            );

            questUIHeight += questUIHeight === 0 ? 36 : 18; // Add height for this quest
            ctx.restore();
          }

          // UI: Stamina bar (top-left, below quest if visible, otherwise at top)
          const staminaBarY = 14.5 + questUIHeight;
          const bar = {
            x: 16.5,
            y: staminaBarY,
            w: 220,
            h: 16,
          };
          // Background
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)'; // White UI borders
          ctx.fillStyle = 'rgba(10,20,14,0.8)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.rect(bar.x, bar.y, bar.w, bar.h);
          ctx.fill();
          ctx.stroke();

          // Fill (use cached gradients)
          if (!staminaBarGradients) initStaminaGradients();
          const ratio = stamina.current / stamina.max;
          const fillWidth = Math.round(bar.w * ratio);
          // Make stamina bar red when exhausted
          ctx.fillStyle = stamina.exhausted
            ? staminaBarGradients.exhausted
            : staminaBarGradients.normal;
          ctx.beginPath();
          ctx.rect(bar.x + 1, bar.y + 1, Math.max(0, fillWidth - 2), bar.h - 2);
          ctx.fill();

          // UI: Time and Day display (top-center, screen space)
          if (gameState === 'playing' || gameState === 'dayEnd') {
            ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Convert to 12-hour format with AM/PM (no minutes)
            let displayHour = dayTime.currentHour;
            let ampm = 'AM';
            if (displayHour >= 12) {
              ampm = 'PM';
              if (displayHour > 12) {
                displayHour -= 12;
              }
            }
            if (displayHour === 0) {
              displayHour = 12;
            }

            const timeText = `${
              dayTime.days[dayTime.currentDay]
            } - ${displayHour} ${ampm}`;
            ctx.fillStyle = '#e8eaf6';
            ctx.fillText(timeText, canvas.width / 2, 14.5);
          }

          // Draw brushing minigame
          if (brushingMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel - keep original size, but make brush and dirt fill it better
            const panelWidth = 500; // Fixed panel width
            const panelHeight = 400; // Fixed panel height
            const dirtSize = Math.min(panelWidth - 120, panelHeight - 120, 350); // Fill panel but leave padding
            const brushSize = dirtSize * 0.5; // Brush is half the size of dirt
            const maxOffset = 60; // Brush movement range
            const padding = 40; // Padding around content
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff'; // White menu borders
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Draw dirt sprite (in center, with red tint based on redness)
            // Note: dirtSize is now calculated above in panel dimensions
            const dirtX = canvas.width / 2;
            const dirtY = canvas.height / 2;

            if (dirtSprite.complete && dirtSprite.naturalWidth > 0) {
              ctx.save();
              ctx.imageSmoothingEnabled = false;

              // Transition from regular dirt to hot dirt based on redness
              const redness = brushingMinigame.redness;

              // Draw regular dirt sprite (fade out as redness increases)
              if (redness < 1.0) {
                ctx.globalAlpha = 1.0 - redness;
                ctx.drawImage(
                  dirtSprite,
                  dirtX - dirtSize / 2,
                  dirtY - dirtSize / 2,
                  dirtSize,
                  dirtSize,
                );
              }

              // Draw hot dirt sprite (fade in as redness increases)
              if (
                redness > 0 &&
                hotDirtSprite.complete &&
                hotDirtSprite.naturalWidth > 0
              ) {
                ctx.globalAlpha = redness;
                ctx.drawImage(
                  hotDirtSprite,
                  dirtX - dirtSize / 2,
                  dirtY - dirtSize / 2,
                  dirtSize,
                  dirtSize,
                );
              }

              // Add a subtle glow when fully red (hot dirt)
              if (redness >= 1.0) {
                const pulse = Math.sin(Date.now() / 150) * 0.2 + 0.8;
                ctx.globalAlpha = pulse * 0.15;
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(
                  dirtX - dirtSize / 2 - 5,
                  dirtY - dirtSize / 2 - 5,
                  dirtSize + 10,
                  dirtSize + 10,
                );
              }

              ctx.restore();
            } else {
              // Fallback while loading
              const redness = brushingMinigame.redness;
              // Blend from brown to red based on redness value
              const r = Math.round(139 + (255 - 139) * redness);
              const g = Math.round(69 * (1 - redness));
              const b = Math.round(19 * (1 - redness));
              ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
              ctx.beginPath();
              ctx.rect(
                dirtX - dirtSize / 2,
                dirtY - dirtSize / 2,
                dirtSize,
                dirtSize,
              );
              ctx.fill();
            }

            // Draw brush sprite - now animated with brushOffset
            // Check if player has speed brush
            let hasSpeedBrush = false;
            if (
              inventory.equipment &&
              inventory.equipment.name === 'Speed Brush'
            ) {
              hasSpeedBrush = true;
            }
            for (let i = 0; i < inventory.slots.length; i++) {
              if (
                inventory.slots[i] &&
                inventory.slots[i].name === 'Speed Brush'
              ) {
                hasSpeedBrush = true;
                break;
              }
            }
            // Note: brushSize is already declared above in panel dimensions
            const brushX = canvas.width / 2 + brushingMinigame.brushOffset; // Add offset for animation
            const brushY = brushingMinigame.brushY;

            // Use speed brush sprite if player has it, otherwise use regular brush
            const currentBrushSprite = hasSpeedBrush
              ? speedBrushSprite
              : brushSprite;
            if (
              currentBrushSprite.complete &&
              currentBrushSprite.naturalWidth > 0
            ) {
              ctx.save();
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                currentBrushSprite,
                brushX - brushSize / 2,
                brushY - brushSize / 2,
                brushSize,
                brushSize,
              );
              ctx.restore();
            } else {
              // Fallback while loading
              ctx.fillStyle = '#8b7355';
              ctx.beginPath();
              ctx.rect(
                brushX - brushSize / 2,
                brushY - brushSize / 2,
                brushSize,
                brushSize,
              );
              ctx.fill();
            }

            // Draw particles
            for (const p of brushingMinigame.particles) {
              ctx.save();
              ctx.globalAlpha = p.life; // Fade out as life decreases
              ctx.fillStyle = '#8b4513'; // Brown dirt color
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }

            // Question mark in bottom left - clickable to show instructions
            const questionMarkSize = 34; // Slightly bigger for visibility
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkPadding = 6;
            const questionMarkCenterX = questionMarkX + questionMarkSize / 2;
            const questionMarkCenterY = questionMarkY - questionMarkSize / 2;
            const questionMarkRadius = questionMarkSize / 2 + 6;
            const isHoveringQuestionMark =
              mouseX >= questionMarkX - questionMarkPadding &&
              mouseX <=
                questionMarkX + questionMarkSize + questionMarkPadding &&
              mouseY >=
                questionMarkY - questionMarkSize - questionMarkPadding &&
              mouseY <= questionMarkY + questionMarkPadding;

            // Draw a small badge so the icon is more obvious
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.arc(
              questionMarkCenterX,
              questionMarkCenterY,
              questionMarkRadius,
              0,
              Math.PI * 2,
            );
            ctx.fill();
            ctx.strokeStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the question mark
            ctx.fillStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', questionMarkCenterX, questionMarkCenterY + 1);

            // Draw instructions if question mark was clicked
            if (brushingMinigame.showInstructions) {
              // Instructions panel
              const instructionsPanelWidth = 400;
              const instructionsPanelHeight = 200;
              const instructionsPanelX =
                (canvas.width - instructionsPanelWidth) / 2;
              const instructionsPanelY =
                (canvas.height - instructionsPanelHeight) / 2;

              // Background
              ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
              ctx.fillRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Border
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Instructions text
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'top';

              const instructions = [
                'Brushing Instructions',
                '',
                'Hold SPACE to brush the dirt clean',
                'Wait for it to turn RED',
                'Release SPACE quickly when red',
                'Time it perfect to earn an Artifact!',
              ];

              let textY = instructionsPanelY + 20;
              for (let i = 0; i < instructions.length; i++) {
                ctx.font =
                  i === 0
                    ? 'bold 18px ui-monospace, Menlo, Consolas, monospace'
                    : '14px ui-monospace, Menlo, Consolas, monospace';
                ctx.fillText(instructions[i], canvas.width / 2, textY);
                textY += i === 0 ? 30 : 25; // Extra spacing after title
              }
            }

            ctx.restore();
          }

          // Draw Typo minigame (handles all text-based minigames: Declaration, Common Sense, Confederacy)
          if (typoMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff'; // White menu borders
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(
              'Document Authenticity Check',
              Math.round(canvas.width / 2),
              Math.round(panelY + 20),
            );

            // Close button removed

            // Divide panel into two columns
            const columnWidth = (panelWidth - 60) / 2; // Leave space for divider and padding
            const leftX = panelX + 20;
            const rightX = panelX + panelWidth / 2 + 10;
            const textY = panelY + 70;
            const textWidth = columnWidth - 20;

            // Left column label (Reference)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Reference',
              Math.round(leftX + columnWidth / 2),
              Math.round(textY - 25),
            );

            // Left column text (real excerpt)
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            // Enable better text rendering

            // Word wrap for left text
            const leftWords = typoMinigame.realExcerpt.split(' ');
            let leftLine = '';
            let leftY = textY;
            for (let i = 0; i < leftWords.length; i++) {
              const testLine = leftLine + leftWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > textWidth && i > 0) {
                ctx.fillText(leftLine, Math.round(leftX), Math.round(leftY));
                leftLine = leftWords[i] + ' ';
                leftY += 22;
              } else {
                leftLine = testLine;
              }
            }
            ctx.fillText(leftLine, Math.round(leftX), Math.round(leftY));

            // Divider line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelX + panelWidth / 2, panelY + 60);
            ctx.lineTo(panelX + panelWidth / 2, panelY + panelHeight - 100);
            ctx.stroke();

            // Right column label (Questionable)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Possible fake',
              Math.round(rightX + columnWidth / 2),
              Math.round(textY - 25),
            );

            // Right column text (test excerpt)
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            // Enable better text rendering

            // Word wrap for right text with typo highlighting
            const rightWords = typoMinigame.testExcerpt.split(' ');
            let rightLine = '';
            let rightY = textY;
            // Check if we should highlight the typo (answered wrong and is fake)
            const shouldHighlightTypo =
              typoMinigame.answered &&
              !typoMinigame.wasCorrect &&
              typoMinigame.isFake &&
              typoMinigame.selectedTypo;
            const typoWord = shouldHighlightTypo
              ? typoMinigame.selectedTypo.to
              : null;

            for (let i = 0; i < rightWords.length; i++) {
              const testLine = rightLine + rightWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > textWidth && i > 0) {
                // Draw the current line word by word to highlight typos
                const lineWords = rightLine.trim().split(' ');
                let xPos = rightX;
                for (let j = 0; j < lineWords.length; j++) {
                  const lineWord = lineWords[j].replace(/[.,;:]/g, '');
                  const wordText =
                    lineWords[j] + (j < lineWords.length - 1 ? ' ' : '');
                  if (shouldHighlightTypo && lineWord === typoWord) {
                    ctx.fillStyle = '#ff0000'; // Red for typo
                  } else {
                    ctx.fillStyle = '#ffffff';
                  }
                  ctx.fillText(wordText, Math.round(xPos), Math.round(rightY));
                  xPos += ctx.measureText(wordText).width;
                }
                rightLine = rightWords[i] + ' ';
                rightY += 22;
              } else {
                rightLine = testLine;
              }
            }
            // Draw the last line word by word to highlight typos
            const lineWords = rightLine.trim().split(' ');
            let xPos = rightX;
            for (let j = 0; j < lineWords.length; j++) {
              const lineWord = lineWords[j].replace(/[.,;:]/g, '');
              const wordText =
                lineWords[j] + (j < lineWords.length - 1 ? ' ' : '');
              if (shouldHighlightTypo && lineWord === typoWord) {
                ctx.fillStyle = '#ff0000'; // Red for typo
              } else {
                ctx.fillStyle = '#ffffff';
              }
              ctx.fillText(wordText, Math.round(xPos), Math.round(rightY));
              xPos += ctx.measureText(wordText).width;
            }

            // Buttons
            if (!typoMinigame.answered) {
              const buttonY = panelY + panelHeight - 80;
              const buttonWidth = 150;
              const buttonHeight = 40;
              const buttonSpacing = 20;
              const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
              const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

              // Display button (left) - brighter green
              const displayButtonX = buttonStartX;
              // Check if mouse is hovering over Display button
              const isHoveringDisplay =
                mouseX >= displayButtonX &&
                mouseX <= displayButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringDisplay
                ? 'rgba(0, 255, 0, 1.0)' // Even brighter green on hover
                : 'rgba(0, 200, 0, 0.9)'; // Brighter green
              ctx.fillRect(
                Math.round(displayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.strokeStyle = '#ffffff'; // White border (no yellow on hover)
              ctx.lineWidth = 2;
              ctx.strokeRect(
                Math.round(displayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'Keep',
                Math.round(displayButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2),
              );

              // Throw away button (right) - brighter red
              const throwAwayButtonX =
                buttonStartX + buttonWidth + buttonSpacing;
              // Check if mouse is hovering over Throw away button
              const isHoveringThrowAway =
                mouseX >= throwAwayButtonX &&
                mouseX <= throwAwayButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringThrowAway
                ? 'rgba(255, 0, 0, 1.0)' // Even brighter red on hover
                : 'rgba(200, 0, 0, 0.9)'; // Brighter red
              ctx.fillRect(
                Math.round(throwAwayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.strokeStyle = '#ffffff'; // White border (no yellow on hover)
              ctx.lineWidth = 2;
              ctx.strokeRect(
                Math.round(throwAwayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'Throw away',
                Math.round(throwAwayButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2),
              );
            } else {
              let resultText = '';
              let resultColor = '#ffffff';

              if (typoMinigame.wasCorrect) {
                resultText = 'Correct!';
                resultColor = '#00ff00';
              } else if (typoMinigame.actualReward === 0) {
                resultText = 'Incorrect! (No penalty)';
                resultColor = '#ffff00';
              } else {
                resultText = 'Incorrect!';
                resultColor = '#ff0000';
              }

              ctx.fillStyle = resultColor;
              ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center'; // Ensure text is centered
              ctx.textBaseline = 'middle'; // Center vertically too
              ctx.fillText(
                resultText,
                Math.round(canvas.width / 2),
                Math.round(panelY + panelHeight - 60),
              );
            }

            // Question mark in bottom left - clickable to show instructions
            const questionMarkSize = 34; // Slightly bigger for visibility
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkPadding = 6;
            const questionMarkCenterX = questionMarkX + questionMarkSize / 2;
            const questionMarkCenterY = questionMarkY - questionMarkSize / 2;
            const questionMarkRadius = questionMarkSize / 2 + 6;
            const isHoveringQuestionMark =
              mouseX >= questionMarkX - questionMarkPadding &&
              mouseX <=
                questionMarkX + questionMarkSize + questionMarkPadding &&
              mouseY >=
                questionMarkY - questionMarkSize - questionMarkPadding &&
              mouseY <= questionMarkY + questionMarkPadding;

            // Draw a small badge so the icon is more obvious
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.arc(
              questionMarkCenterX,
              questionMarkCenterY,
              questionMarkRadius,
              0,
              Math.PI * 2,
            );
            ctx.fill();
            ctx.strokeStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the question mark
            ctx.fillStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', questionMarkCenterX, questionMarkCenterY + 1);

            // Draw instructions if question mark was clicked
            if (typoMinigame.showInstructions) {
              const instructionsPanelWidth = 460;
              const instructionsPanelHeight = 200;
              const instructionsPanelX =
                (canvas.width - instructionsPanelWidth) / 2;
              const instructionsPanelY =
                (canvas.height - instructionsPanelHeight) / 2;

              // Background
              ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
              ctx.fillRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Border
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Instructions text
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'top';

              const instructions = [
                'Typo Instructions',
                '',
                'The document on the left is real,',
                'the document on the right might be a fake.',
                'Look for typos,',
                'Then choose whether to keep it or throw it away.',
              ];

              let textY = instructionsPanelY + 20;
              for (let i = 0; i < instructions.length; i++) {
                ctx.font =
                  i === 0
                    ? 'bold 18px ui-monospace, Menlo, Consolas, monospace'
                    : '14px ui-monospace, Menlo, Consolas, monospace';
                ctx.fillText(instructions[i], canvas.width / 2, textY);
                textY += i === 0 ? 30 : 22;
              }
            }

            ctx.restore();
          }

          // Draw Quiz minigame
          if (quizMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff'; // White menu borders
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(
              'Quiz',
              Math.round(canvas.width / 2),
              Math.round(panelY + 20),
            );

            // Question text
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Word wrap for question text
            const questionWords = quizMinigame.question.split(' ');
            const textWidth = panelWidth - 80;
            const textX = panelX + panelWidth / 2;
            let questionLine = '';
            // Calculate total question height to center it vertically
            let totalQuestionHeight = 0;
            let testLine = '';
            for (let i = 0; i < questionWords.length; i++) {
              const testLine2 = testLine + questionWords[i] + ' ';
              const metrics = ctx.measureText(testLine2);
              if (metrics.width > textWidth && i > 0) {
                totalQuestionHeight += 28;
                testLine = questionWords[i] + ' ';
              } else {
                testLine = testLine2;
              }
            }
            totalQuestionHeight += 28; // Last line
            // Center question vertically in the panel (between title and buttons)
            const availableHeight = panelHeight - 100 - 120; // Title area and button area
            let questionY =
              panelY + 100 + (availableHeight - totalQuestionHeight) / 2;
            for (let i = 0; i < questionWords.length; i++) {
              const testLine = questionLine + questionWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > textWidth && i > 0) {
                ctx.fillText(
                  questionLine,
                  Math.round(textX),
                  Math.round(questionY),
                );
                questionLine = questionWords[i] + ' ';
                questionY += 28;
              } else {
                questionLine = testLine;
              }
            }
            ctx.fillText(
              questionLine,
              Math.round(textX),
              Math.round(questionY),
            );

            // Buttons
            if (!quizMinigame.answered) {
              const buttonY = panelY + panelHeight - 80;
              const buttonWidth = 150;
              const buttonHeight = 40;
              const buttonSpacing = 20;
              const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
              const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

              // Yes button (left) - brighter green
              const yesButtonX = buttonStartX;
              // Check if mouse is hovering over Yes button
              const isHoveringYes =
                mouseX >= yesButtonX &&
                mouseX <= yesButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringYes
                ? 'rgba(0, 255, 0, 1.0)' // Even brighter green on hover
                : 'rgba(0, 200, 0, 0.9)'; // Brighter green
              ctx.fillRect(
                Math.round(yesButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.strokeStyle = '#ffffff'; // White border
              ctx.lineWidth = 2;
              ctx.strokeRect(
                Math.round(yesButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'Yes',
                Math.round(yesButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2),
              );

              // No button (right) - brighter red
              const noButtonX = buttonStartX + buttonWidth + buttonSpacing;
              // Check if mouse is hovering over No button
              const isHoveringNo =
                mouseX >= noButtonX &&
                mouseX <= noButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringNo
                ? 'rgba(255, 0, 0, 1.0)' // Even brighter red on hover
                : 'rgba(200, 0, 0, 0.9)'; // Brighter red
              ctx.fillRect(
                Math.round(noButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.strokeStyle = '#ffffff'; // White border
              ctx.lineWidth = 2;
              ctx.strokeRect(
                Math.round(noButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight,
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'No',
                Math.round(noButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2),
              );
            } else {
              let resultText = '';
              let resultColor = '#ffffff';

              if (quizMinigame.wasCorrect) {
                resultText = 'Correct!';
                resultColor = '#00ff00';
              } else {
                resultText = 'Incorrect!';
                resultColor = '#ff0000';
              }

              ctx.fillStyle = resultColor;
              ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                resultText,
                Math.round(canvas.width / 2),
                Math.round(panelY + panelHeight - 60),
              );
            }

            // Question mark in bottom left - clickable to show instructions
            const questionMarkSize = 34;
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkPadding = 6;
            const questionMarkCenterX = questionMarkX + questionMarkSize / 2;
            const questionMarkCenterY = questionMarkY - questionMarkSize / 2;
            const questionMarkRadius = questionMarkSize / 2 + 6;
            const isHoveringQuestionMark =
              mouseX >= questionMarkX - questionMarkPadding &&
              mouseX <=
                questionMarkX + questionMarkSize + questionMarkPadding &&
              mouseY >=
                questionMarkY - questionMarkSize - questionMarkPadding &&
              mouseY <= questionMarkY + questionMarkPadding;

            // Draw a small badge so the icon is more obvious
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.arc(
              questionMarkCenterX,
              questionMarkCenterY,
              questionMarkRadius,
              0,
              Math.PI * 2,
            );
            ctx.fill();
            ctx.strokeStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the question mark
            ctx.fillStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', questionMarkCenterX, questionMarkCenterY + 1);

            // Draw instructions if question mark was clicked
            if (quizMinigame.showInstructions) {
              const instructionsPanelWidth = 600;
              const instructionsPanelHeight = 240;
              const instructionsPanelX =
                (canvas.width - instructionsPanelWidth) / 2;
              const instructionsPanelY =
                (canvas.height - instructionsPanelHeight) / 2;

              // Background
              ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
              ctx.fillRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Border
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Instructions text
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'top';

              const instructions = [
                'Quiz Instructions',
                '',
                'Answer the yes or no questions with what you think is the best answer.',
                'Answer the question correctly to get rewards!',
                'Try to remember the answer for if you get the question again.',
              ];

              // Calculate total text height to center it vertically
              const titleHeight = 30;
              const lineHeight = 22;
              const totalTextHeight =
                titleHeight + (instructions.length - 1) * lineHeight;
              const startY =
                instructionsPanelY +
                (instructionsPanelHeight - totalTextHeight) / 2;

              let textY = startY;
              for (let i = 0; i < instructions.length; i++) {
                ctx.font =
                  i === 0
                    ? 'bold 18px ui-monospace, Menlo, Consolas, monospace'
                    : '14px ui-monospace, Menlo, Consolas, monospace';
                ctx.fillText(instructions[i], canvas.width / 2, textY);
                textY += i === 0 ? titleHeight : lineHeight;
              }
            }

            ctx.restore();
          }

          // Draw Minesweeper minigame
          if (minesweeperMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel - square (no text, so same width and height)
            const gridSize = minesweeperMinigame.gridSize;
            const cellSize = 50; // Size of each cell (increased from 40)
            const panelPadding = 40; // Padding around grid
            const gridAreaSize = gridSize * cellSize;
            const panelWidth = gridAreaSize + panelPadding * 2; // Square panel
            const panelHeight = panelWidth; // Make it square (same as width)
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Draw grid (centered in square panel - no title text)
            const gridWidth = gridSize * cellSize;
            const gridHeight = gridSize * cellSize;
            const gridStartX = panelX + panelPadding;
            const gridStartY = panelY + panelPadding;

            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const x = gridStartX + col * cellSize;
                const y = gridStartY + row * cellSize;

                const isRevealed = minesweeperMinigame.revealed[row][col];
                const isFlagged = minesweeperMinigame.flagged[row][col];
                const isMine = minesweeperMinigame.grid[row][col];

                // Draw cell background
                if (isRevealed) {
                  if (isMine) {
                    // Mine cell - red background
                    ctx.fillStyle = '#ff0000';
                  } else {
                    // Revealed safe cell - light gray
                    ctx.fillStyle = '#cccccc';
                  }
                } else {
                  // Unrevealed cell - dark gray
                  ctx.fillStyle = '#666666';
                }
                ctx.fillRect(x, y, cellSize - 2, cellSize - 2);

                // Draw border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, cellSize - 2, cellSize - 2);

                // Draw content
                if (isFlagged && !isRevealed) {
                  // Draw dirt tile sprite first (background)
                  if (
                    dirtTileSprite.complete &&
                    dirtTileSprite.naturalWidth > 0
                  ) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                      dirtTileSprite,
                      x + 1,
                      y + 1,
                      cellSize - 4,
                      cellSize - 4,
                    );
                  }
                  // Then draw flag sprite on top
                  if (flagSprite.complete && flagSprite.naturalWidth > 0) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                      flagSprite,
                      x + 2,
                      y + 2,
                      cellSize - 6,
                      cellSize - 6,
                    );
                  } else {
                    // Fallback flag
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(x + cellSize / 2, y + 5);
                    ctx.lineTo(x + cellSize / 2, y + cellSize - 8);
                    ctx.lineTo(x + cellSize / 2 - 3, y + cellSize - 5);
                    ctx.lineTo(x + cellSize / 2 + 3, y + cellSize - 5);
                    ctx.closePath();
                    ctx.fill();
                  }
                } else if (isRevealed) {
                  if (isMine) {
                    // Draw mine sprite
                    if (mineSprite.complete && mineSprite.naturalWidth > 0) {
                      ctx.imageSmoothingEnabled = false;
                      ctx.drawImage(
                        mineSprite,
                        x + 2,
                        y + 2,
                        cellSize - 4,
                        cellSize - 4,
                      );
                    } else {
                      // Fallback: draw filled circle if sprite not loaded
                      ctx.fillStyle = '#000000';
                      ctx.beginPath();
                      ctx.arc(
                        x + cellSize / 2,
                        y + cellSize / 2,
                        cellSize / 4,
                        0,
                        Math.PI * 2,
                      );
                      ctx.fill();
                    }
                  } else {
                    // Draw number (adjacent mine count)
                    const count = countAdjacentMines(
                      minesweeperMinigame,
                      row,
                      col,
                    );
                    if (count > 0) {
                      ctx.fillStyle = '#000000';
                      ctx.font =
                        'bold 16px ui-monospace, Menlo, Consolas, monospace';
                      ctx.textAlign = 'center';
                      ctx.textBaseline = 'middle';
                      ctx.fillText(
                        count.toString(),
                        x + cellSize / 2,
                        y + cellSize / 2,
                      );
                    }
                  }
                } else {
                  // Draw dirt tile sprite for unrevealed cells
                  if (
                    dirtTileSprite.complete &&
                    dirtTileSprite.naturalWidth > 0
                  ) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                      dirtTileSprite,
                      x + 1,
                      y + 1,
                      cellSize - 4,
                      cellSize - 4,
                    );
                  }
                }
              }
            }

            // Display "Good job!" in green when won
            if (minesweeperMinigame.won) {
              ctx.fillStyle = '#00ff00'; // Green color
              ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('Good job!', canvas.width / 2, panelY + 30);
            }

            // Display "Oops!" in red when game over (hit a bomb)
            if (
              minesweeperMinigame.gameOver &&
              minesweeperMinigame.gameOverMessage
            ) {
              ctx.fillStyle = '#ff0000'; // Red color
              ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                minesweeperMinigame.gameOverMessage,
                canvas.width / 2,
                panelY + 30,
              );
            }

            // Question mark in bottom left - clickable to show instructions
            const questionMarkSize = 34; // Slightly bigger for visibility
            const questionMarkX = 15;
            const questionMarkY = canvas.height - 15;
            const questionMarkPadding = 6;
            const questionMarkCenterX = questionMarkX + questionMarkSize / 2;
            const questionMarkCenterY = questionMarkY - questionMarkSize / 2;
            const questionMarkRadius = questionMarkSize / 2 + 6;
            const isHoveringQuestionMark =
              mouseX >= questionMarkX - questionMarkPadding &&
              mouseX <=
                questionMarkX + questionMarkSize + questionMarkPadding &&
              mouseY >=
                questionMarkY - questionMarkSize - questionMarkPadding &&
              mouseY <= questionMarkY + questionMarkPadding;

            // Draw a small badge so the icon is more obvious
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.arc(
              questionMarkCenterX,
              questionMarkCenterY,
              questionMarkRadius,
              0,
              Math.PI * 2,
            );
            ctx.fill();
            ctx.strokeStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the question mark
            ctx.fillStyle = isHoveringQuestionMark ? '#ffff66' : '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', questionMarkCenterX, questionMarkCenterY + 1);

            // Draw instructions if question mark was clicked
            if (minesweeperMinigame.showInstructions) {
              // Instructions panel
              const instructionsPanelWidth = 400;
              const instructionsPanelHeight = 200;
              const instructionsPanelX =
                (canvas.width - instructionsPanelWidth) / 2;
              const instructionsPanelY =
                (canvas.height - instructionsPanelHeight) / 2;

              // Background
              ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
              ctx.fillRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Border
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(
                instructionsPanelX,
                instructionsPanelY,
                instructionsPanelWidth,
                instructionsPanelHeight,
              );

              // Instructions text
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'top';

              const instructions = [
                'Minesweeper Instructions',
                '',
                'Left click to reveal tiles',
                'Right click to flag mines',
                'Numbers show adjacent mines',
                'Reveal all safe tiles to win!',
              ];

              let textY = instructionsPanelY + 20;
              for (let i = 0; i < instructions.length; i++) {
                ctx.font =
                  i === 0
                    ? 'bold 18px ui-monospace, Menlo, Consolas, monospace'
                    : '14px ui-monospace, Menlo, Consolas, monospace';
                ctx.fillText(instructions[i], canvas.width / 2, textY);
                textY += i === 0 ? 30 : 25; // Extra spacing after title
              }
            }

            ctx.restore();
          }

          // Draw inventory menu
          if (inventory.open) {
            drawInventory();
          }

          // Draw dialogue textbox (RPG style at top of screen)
          // Only show tutorial on first day (Monday = day 0)
          // System messages are also shown
          if (
            systemMessage.text ||
            (tutorial.active && dayTime.currentDay === 0) ||
            oldGuy.dialogue ||
            warningGuy.dialogue ||
            joseph.dialogue ||
            curator.dialogue ||
            cannonBuff.dialogue
          ) {
            drawDialogueBox();
          }

          // Draw day end warning (at 5 PM, bottom of screen)
          if (
            gameState === 'playing' &&
            dayTime.currentHour === dayTime.warningHour
          ) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'The day is ending',
              canvas.width / 2,
              canvas.height - 25,
            );
            ctx.restore();
          }

          // Draw day end screen
          if (gameState === 'dayEnd') {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e8eaf6';
            ctx.font = 'bold 36px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'The day has ended.',
              canvas.width / 2,
              canvas.height / 2 - 40,
            );

            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillText(
              'Press SPACE to continue',
              canvas.width / 2,
              canvas.height / 2 + 20,
            );
            ctx.restore();
          }

          // Draw week end screen
          if (gameState === 'weekEnd') {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e8eaf6';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'Your week is over!',
              canvas.width / 2,
              canvas.height / 2 - 100,
            );

            // Week end screen (museum ending rank)
            const endingRank = getMuseumEndingRank();

            // Check and unlock ending achievements
            if (endingRank.name === 'Nothing') {
              const nothingAchievement = achievements.list.find(
                (a) => a.id === 'nothing',
              );
              if (nothingAchievement && !nothingAchievement.completed) {
                nothingAchievement.completed = true;
                saveAchievements(); // Save achievements when unlocked
              }
            } else if (endingRank.name === 'Below Average') {
              const consolationAchievement = achievements.list.find(
                (a) => a.id === 'consolation_prize',
              );
              if (consolationAchievement && !consolationAchievement.completed) {
                consolationAchievement.completed = true;
                saveAchievements(); // Save achievements when unlocked
              }
            } else if (endingRank.name === 'Average') {
              const classicAchievement = achievements.list.find(
                (a) => a.id === 'classic',
              );
              if (classicAchievement && !classicAchievement.completed) {
                classicAchievement.completed = true;
                saveAchievements(); // Save achievements when unlocked
              }
            } else if (endingRank.name === 'Above Average') {
              const overachieverAchievement = achievements.list.find(
                (a) => a.id === 'overachiever',
              );
              if (
                overachieverAchievement &&
                !overachieverAchievement.completed
              ) {
                overachieverAchievement.completed = true;
                saveAchievements(); // Save achievements when unlocked
              }
            } else if (endingRank.name === 'Legendary') {
              const legendaryAchievement = achievements.list.find(
                (a) => a.id === 'legendary',
              );
              if (
                legendaryAchievement &&
                !legendaryAchievement.completed
              ) {
                legendaryAchievement.completed = true;
                saveAchievements(); // Save achievements when unlocked
              }
            }

            ctx.fillStyle = '#e8eaf6';
            ctx.font = 'bold 26px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillText(
              `Ending: ${endingRank.name}`,
              canvas.width / 2,
              canvas.height / 2 - 40,
            );

            ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
            const reasonLines = wrapTextLines(endingRank.reason, 500);
            for (let i = 0; i < reasonLines.length; i++) {
              ctx.fillText(
                reasonLines[i],
                canvas.width / 2,
                canvas.height / 2 - 5 + i * 20,
              );
            }

            ctx.fillStyle = '#e8eaf6';
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillText(
              'Press SPACE to return to title',
              canvas.width / 2,
              canvas.height / 2 + 100,
            );
            ctx.restore();
          }
        }

        function drawShopMenu() {
          // Shop system removed - function stub
          return;
        }

        function purchaseItem(itemIndex) {
          // Shop system removed - function stub
          return;

          // Check for artifact equipment FIRST (before general shovel handling)
          // Artifact items have type: 'shovel' and tier: 6, so they would match the general shovel condition
          if (
            item.type === 'shovel' &&
            item.tier === 6 &&
            (item.name === 'Artifact spade' ||
              item.name === 'Artifact shovel' ||
              item.name === 'Artifact scoop')
          ) {
            // Artifact equipment - can only have one total (not one of each)
            // Check if player already has any artifact equipment
            if (inventory.artifactEquipment) {
              return; // Already have artifact equipment, can't buy another
            }
            if (money.amount >= item.price) {
              money.amount -= item.price;
              // Mark as purchased
              item.purchased = true;
              // Equip this artifact tool with appropriate sprite
              let artifactSprite = artifactShovelSprite;
              if (item.name === 'Artifact spade') {
                artifactSprite = artifactSpadeSprite;
              } else if (item.name === 'Artifact shovel') {
                artifactSprite = artifactShovelSprite;
              } else if (item.name === 'Artifact scoop') {
                artifactSprite = artifactScoopSprite;
              }
              inventory.artifactEquipment = {
                name: item.name,
                sprite: artifactSprite,
              };
              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }
            }
          } else if (item.type === 'shovel') {
            // Check if already purchased
            if (item.purchased) {
              return; // Already purchased
            }

            // Check if previous tier is purchased (for tier > 1)
            if (item.tier > 1) {
              const prevTierItem = shop.items.find(
                (i) => i.type === 'shovel' && i.tier === item.tier - 1,
              );
              if (prevTierItem && !prevTierItem.purchased) {
                return; // Must buy previous tier first
              }
            }

            if (money.amount >= item.price) {
              money.amount -= item.price;
              // Mark as purchased
              item.purchased = true;

              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }

              // Get the appropriate sprite for this shovel tier
              // For tier 6 (Artifact shovel/spade/scoop), use the regular shovel sprite as placeholder
              let sprite = shovelSprites[item.tier];
              // If sprite not loaded yet, try to load it, or use a default
              if (!sprite) {
                if (item.tier === 6) {
                  // Use tier 5 sprite as placeholder for tier 6
                  sprite = shovelSprites[5] || shovelSprites[1];
                } else {
                  const spriteName =
                    'assets/sprites/' +
                    item.name.toLowerCase().replace(/\s+/g, '-') +
                    '.png';
                  sprite = loadShovelSprite(item.tier, spriteName);
                }
              }
              // Add shovel to equipment slot (use highest tier purchased)
              inventory.equipment = {
                name: item.name,
                tier: item.tier,
                sprite: sprite || shovelSprites[1], // Fallback to tier 1 sprite
                type: 'shovel',
              };
            }
          } else if (item.type === 'equipment' && item.name === 'Radar') {
            // Check if player already owns radar
            if (radar.active) {
              return; // Already own radar
            }

            if (money.amount >= item.price) {
              money.amount -= item.price;

              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }

              // Activate radar
              radar.active = true;
              radar.ringTimer = 0;
              radar.rings = [];

              // Mark as purchased
              item.purchased = true;
            }
          } else if (item.type === 'equipment' && item.name === 'Speed Brush') {
            // Check if already purchased
            if (item.purchased || inventory.speedBrush) {
              return; // Already purchased/owned
            }

            if (money.amount >= item.price) {
              money.amount -= item.price;

              // Mark as purchased and owned
              item.purchased = true;
              inventory.speedBrush = true;

              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }
            }
          }
        }

        function drawDialogueBox() {
          ctx.save();

          const boxHeight = 100;
          const boxY = 0; // Top of screen instead of bottom
          const boxPadding = 20;
          const boxMargin = 20;
          const boxX = boxMargin;
          const boxWidth = canvas.width - boxMargin * 2;

          // Background with slight transparency
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.beginPath();
          ctx.rect(boxX, boxY, boxWidth, boxHeight);
          ctx.fill();

          // Border
          ctx.strokeStyle = '#ffffff'; // White borders
          ctx.lineWidth = 3;
          ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

          // Inner border for depth
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Lighter white for inner border
          ctx.lineWidth = 1;
          ctx.strokeRect(boxX + 2, boxY + 2, boxWidth - 4, boxHeight - 4);

          // Dialogue text
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';

          // Determine which character is speaking and get their name
          // System messages have no character name
          let characterName = '';
          if (systemMessage.text) {
            characterName = ''; // System messages have no character name
          } else if (tutorial.active) {
            characterName = 'Candy Kid';
          } else if (oldGuy.dialogue) {
            characterName = 'Uncle Bernie';
          } else if (warningGuy.dialogue) {
            characterName = 'Jake';
          } else if (joseph.dialogue) {
            characterName = 'Joseph';
          } else if (curator.dialogue) {
            characterName = 'Museum Curator';
          } else if (cannonBuff.dialogue) {
            characterName = 'Cannon Buff';
          }

          // Draw character name above dialogue text
          let nameY = boxY + boxPadding;
          if (characterName) {
            ctx.fillStyle = '#ffffff'; // White for character names
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(characterName, boxX + boxPadding, nameY);

            // Draw line between name and text
            const lineY = nameY + 18;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(boxX + boxPadding, lineY);
            ctx.lineTo(boxX + boxWidth - boxPadding, lineY);
            ctx.stroke();
          }

          // Word wrap the dialogue text
          const maxWidth = boxWidth - boxPadding * 2;
          const dialogueText = systemMessage.text
            ? systemMessage.text
            : tutorial.active
              ? tutorial.dialogue
              : oldGuy.dialogue ||
                warningGuy.dialogue ||
                joseph.dialogue ||
                curator.dialogue ||
                cannonBuff.dialogue ||
                '';
          const words = dialogueText.split(' ');
          let line = '';
          // Start text below character name and line (add extra space if name exists)
          let y = boxY + boxPadding + (characterName ? 38 : 0);

          for (let i = 0; i < words.length; i++) {
            const testLine = line + words[i] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;

            if (testWidth > maxWidth && i > 0) {
              ctx.fillText(line, boxX + boxPadding, y);
              line = words[i] + ' ';
              y += 22; // Line height
            } else {
              line = testLine;
            }
          }
          ctx.fillText(line, boxX + boxPadding, y);

          // Draw help text in bottom right of textbox (only for tutorial)
          if (tutorial.active) {
            const helpText =
              'Press Spacebar to progress textboxes and talk to people';
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            // Move further down and to the right (reduce padding more)
            ctx.fillText(helpText, boxX + boxWidth - 10, boxY + boxHeight - 10);
          }

          ctx.restore();
        }

        function drawInventory() {
          ctx.save();

          // Equipment items that can be owned
          const equipmentItems = [
            {
              name: 'Radar',
              sprite: radarSprite,
              description: "Reveals hidden X's",
            },
            {
              name: 'Quick shoes',
              sprite: quickShoesSprite,
              description: 'Decreases stamina drain when sprinting',
            },
          ];

          // Artifacts panel dimensions
          const slotSize = 48;
          const slotSpacing = 4;
          const slotsPerRow = 5;
          const numRows = 5; // Increased from 2 to 5 rows to show 25 slots (5x5 grid)
          const panelPadding = 24;
          const equipmentSlotSize = 48;
          const equipmentRowSpacing = 4;
          const titleHeight = 40;
          const equipmentLabelHeight = 16;
          const equipmentSpacing = 30; // Increased spacing between equipment and artifacts
          const instructionsHeight = 30;

          // Calculate proper dimensions to fit all slots
          const equipmentRowWidth =
            equipmentItems.length * equipmentSlotSize +
            (equipmentItems.length - 1) * equipmentRowSpacing;
          const slotsAreaWidth =
            slotsPerRow * slotSize + (slotsPerRow - 1) * slotSpacing;
          const slotsAreaHeight =
            numRows * slotSize + (numRows - 1) * slotSpacing;
          const inventoryWidth =
            Math.max(equipmentRowWidth, slotsAreaWidth) + panelPadding * 2;
          const inventoryHeight =
            titleHeight +
            equipmentSlotSize +
            equipmentLabelHeight +
            equipmentSpacing +
            slotsAreaHeight +
            panelPadding * 2 +
            instructionsHeight;

          const panelX =
            Math.round(canvas.width / 2 - inventoryWidth / 2) + 0.5;
          const panelY =
            Math.round(canvas.height / 2 - inventoryHeight / 2) + 0.5;

          // Background with semi-transparent overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Main panel background
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.beginPath();
          ctx.rect(panelX, panelY, inventoryWidth, inventoryHeight);
          ctx.fill();

          // Panel border
          ctx.strokeStyle = '#ffffff'; // White borders
          ctx.lineWidth = 2;
          ctx.strokeRect(panelX, panelY, inventoryWidth, inventoryHeight);

          // Title
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText('Inventory', panelX + inventoryWidth / 2, panelY + 12);

          // Equipment row (at the top, centered)
          const equipmentRowStartX =
            panelX + inventoryWidth / 2 - equipmentRowWidth / 2;
          const equipmentY = panelY + titleHeight + 30; // Lower the equipment row by 30 pixels

          // Equipment label (above the equipment row)
          ctx.fillStyle = '#ffffff';
          ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Equipment',
            panelX + inventoryWidth / 2,
            equipmentY - 4,
          );

          let hoveredItemDescription = null;

          // Draw equipment items row
          for (let i = 0; i < equipmentItems.length; i++) {
            const item = equipmentItems[i];
            const equipmentX =
              equipmentRowStartX +
              i * (equipmentSlotSize + equipmentRowSpacing);

            // Check if player owns this item
            let isOwned = false;
            if (item.name === 'Radar') {
              isOwned = radar.active;
            } else if (item.name === 'Quick shoes') {
              // Quick shoes are owned when given by cannon buff
              isOwned = stamina.hasShoes;
            }

            // Check if hovering (only show description if owned)
            const isHovered =
              mouseX >= equipmentX &&
              mouseX <= equipmentX + equipmentSlotSize &&
              mouseY >= equipmentY &&
              mouseY <= equipmentY + equipmentSlotSize;

            if (isHovered && isOwned) {
              hoveredItemDescription = item.description;
            }

            // Slot background
            ctx.fillStyle = isOwned
              ? 'rgba(20, 40, 30, 0.8)'
              : 'rgba(0, 0, 0, 0.9)'; // Black if not owned
            ctx.strokeStyle = isOwned
              ? 'rgba(255, 255, 255, 0.9)'
              : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = isOwned ? 2 : 1.5;
            ctx.beginPath();
            ctx.rect(
              equipmentX,
              equipmentY,
              equipmentSlotSize,
              equipmentSlotSize,
            );
            ctx.fill();
            ctx.stroke();

            // Draw item sprite (only if owned, otherwise slot is black)
            if (isOwned) {
              // Draw sprite if available
              if (
                item.sprite &&
                item.sprite.complete &&
                item.sprite.naturalWidth > 0
              ) {
                const spriteSize = equipmentSlotSize - 8;
                const spriteX =
                  equipmentX + (equipmentSlotSize - spriteSize) / 2;
                const spriteY =
                  equipmentY + (equipmentSlotSize - spriteSize) / 2;
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                  item.sprite,
                  spriteX,
                  spriteY,
                  spriteSize,
                  spriteSize,
                );
                ctx.restore();
                ctx.textBaseline = 'bottom';
                // Draw with shadow for readability
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
              }
            }
          }

          // Artifacts label
          const artifactsLabelY =
            equipmentY +
            equipmentSlotSize +
            equipmentLabelHeight +
            equipmentSpacing;
          ctx.fillStyle = '#ffffff';
          ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Artifacts',
            panelX + inventoryWidth / 2,
            artifactsLabelY - 4,
          );

          // Artifact slots grid (below equipment row)
          const slotsStartX = panelX + panelPadding;
          const slotsStartY = artifactsLabelY;

          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < slotsPerRow; col++) {
              const slotIndex = row * slotsPerRow + col;
              const slotX = slotsStartX + col * (slotSize + slotSpacing);
              const slotY = slotsStartY + row * (slotSize + slotSpacing);

              // Slot background
              ctx.fillStyle = 'rgba(20, 40, 30, 0.8)';
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.rect(slotX, slotY, slotSize, slotSize);
              ctx.fill();

              // Check if hovering over this slot
              const isHovered =
                mouseX >= slotX &&
                mouseX <= slotX + slotSize &&
                mouseY >= slotY &&
                mouseY <= slotY + slotSize;

              // Draw item if present
              const item = inventory.slots[slotIndex];
              if (item) {
                // Draw item sprite
                if (
                  item.sprite &&
                  item.sprite.complete &&
                  item.sprite.naturalWidth > 0
                ) {
                  ctx.save();
                  ctx.imageSmoothingEnabled = false;

                  // Special handling for Cannon - make it bigger and preserve aspect ratio
                  if (item.name === 'Cannon') {
                    const spriteAspectRatio =
                      item.sprite.naturalWidth / item.sprite.naturalHeight;
                    const maxSize = slotSize - 4; // Use more of the slot

                    let spriteWidth = maxSize;
                    let spriteHeight = spriteWidth / spriteAspectRatio;

                    // If height is too tall, scale down based on height instead
                    if (spriteHeight > maxSize) {
                      spriteHeight = maxSize;
                      spriteWidth = spriteHeight * spriteAspectRatio;
                    }

                    const spriteX = slotX + (slotSize - spriteWidth) / 2;
                    const spriteY = slotY + (slotSize - spriteHeight) / 2;
                    ctx.drawImage(
                      item.sprite,
                      spriteX,
                      spriteY,
                      spriteWidth,
                      spriteHeight,
                    );
                  } else {
                    // Normal items use square size
                    const spriteSize = slotSize - 8; // Leave padding
                    const spriteX = slotX + (slotSize - spriteSize) / 2;
                    const spriteY = slotY + (slotSize - spriteSize) / 2;

                    // Special handling for Arrowhead - rotate 90 degrees
                    if (item.name === 'Arrowhead') {
                      ctx.translate(
                        spriteX + spriteSize / 2,
                        spriteY + spriteSize / 2,
                      );
                      ctx.rotate(Math.PI / 2); // 90 degrees
                      ctx.drawImage(
                        item.sprite,
                        -spriteSize / 2,
                        -spriteSize / 2,
                        spriteSize,
                        spriteSize,
                      );
                    } else {
                      ctx.drawImage(
                        item.sprite,
                        spriteX,
                        spriteY,
                        spriteSize,
                        spriteSize,
                      );
                    }
                  }
                  ctx.restore();
                }

                // Show description on hover
                if (isHovered) {
                  let description = '';
                  if (item.name === 'Speed Brush') {
                    description = 'Makes brushing minigame easier';
                  } else {
                    // Add tier label for artifacts (ex: "Rusty Nails (common)")
                    const tierLabel = item.tier ? ` (${item.tier})` : '';
                    description = item.name + tierLabel;

                    // Store tier color for artifacts
                    if (item.type === 'artifact' && item.tier) {
                      if (item.tier === 'common')
                        hoveredItemTierColor = '#9b9b9b'; // Gray
                      else if (item.tier === 'uncommon')
                        hoveredItemTierColor = '#7dff8a'; // Light green
                      else if (item.tier === 'rare')
                        hoveredItemTierColor = '#7dc7ff'; // Light blue
                      else if (item.tier === 'super rare')
                        hoveredItemTierColor = '#00008b'; // Dark blue
                      else if (item.tier === 'legendary')
                        hoveredItemTierColor = '#ffd700'; // Gold
                    }
                  }
                  if (!hoveredItemDescription) {
                    hoveredItemDescription = description;
                  }
                }
              }

              // Slot outline (tier colors for artifacts)
              let outlineColor = 'rgba(255, 255, 255, 0.7)'; // Default white
              if (item && item.type === 'artifact' && item.tier) {
                if (item.tier === 'common')
                  outlineColor = '#9b9b9b'; // Gray
                else if (item.tier === 'uncommon')
                  outlineColor = '#7dff8a'; // Light green
                else if (item.tier === 'rare')
                  outlineColor = '#7dc7ff'; // Light blue
                else if (item.tier === 'super rare')
                  outlineColor = '#00008b'; // Dark blue for super rare
                else if (item.tier === 'legendary') outlineColor = '#ffd700'; // Gold for legendary
              }

              // Highlight selected artifact for deletion
              if (
                inventory.selectedSlotIndex === slotIndex &&
                item &&
                item.type === 'artifact'
              ) {
                // Draw red highlight border for selected artifact
                ctx.strokeStyle = '#ff0000'; // Red
                ctx.lineWidth = 3;
                ctx.strokeRect(
                  slotX - 2,
                  slotY - 2,
                  slotSize + 4,
                  slotSize + 4,
                );
              }

              // Highlight eligible artifacts when selecting for Joseph
              if (
                joseph.selectingArtifact &&
                item &&
                item.type === 'artifact' &&
                item.name !== 'Cannon' &&
                (item.tier === 'rare' ||
                  item.tier === 'super rare' ||
                  item.tier === 'legendary')
              ) {
                // Draw yellow highlight border for eligible artifacts
                ctx.strokeStyle = '#ffff00'; // Yellow
                ctx.lineWidth = 3;
                ctx.strokeRect(
                  slotX - 2,
                  slotY - 2,
                  slotSize + 4,
                  slotSize + 4,
                );
              }

              ctx.strokeStyle = outlineColor;
              ctx.lineWidth = 1.5;
              ctx.stroke();
            }
          }

          // Draw hover tooltip
          if (hoveredItemDescription) {
            const tooltipPadding = 8;
            const tooltipX = mouseX + 10;
            const tooltipY = mouseY + 10;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const metrics = ctx.measureText(hoveredItemDescription);
            const tooltipWidth = metrics.width + tooltipPadding * 2;
            const tooltipHeight = 20;

            // Make sure tooltip stays on screen
            const finalTooltipX =
              tooltipX + tooltipWidth > canvas.width
                ? mouseX - tooltipWidth - 10
                : tooltipX;
            const finalTooltipY =
              tooltipY + tooltipHeight > canvas.height
                ? mouseY - tooltipHeight - 10
                : tooltipY;

            ctx.fillRect(
              finalTooltipX,
              finalTooltipY,
              tooltipWidth,
              tooltipHeight,
            );
            // Use tier color for border and text if artifact has tier, otherwise white
            const tooltipColor = hoveredItemTierColor || '#ffffff';
            ctx.strokeStyle = tooltipColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(
              finalTooltipX,
              finalTooltipY,
              tooltipWidth,
              tooltipHeight,
            );

            ctx.fillStyle = tooltipColor;
            ctx.fillText(
              hoveredItemDescription,
              finalTooltipX + tooltipPadding,
              finalTooltipY + 4,
            );
          }

          // Red X button for deleting artifacts (to the right of inventory panel)
          const deleteButtonSize = 40;
          const deleteButtonX = panelX + inventoryWidth + 60; // 60px spacing from inventory (moved right)
          const deleteButtonY = panelY + titleHeight; // Align with top of artifact slots

          // Check if hovering over delete button
          const isHoveringDelete =
            mouseX >= deleteButtonX &&
            mouseX <= deleteButtonX + deleteButtonSize &&
            mouseY >= deleteButtonY &&
            mouseY <= deleteButtonY + deleteButtonSize;

          // Draw delete button background
          ctx.fillStyle = isHoveringDelete
            ? 'rgba(255, 0, 0, 0.8)'
            : 'rgba(200, 0, 0, 0.6)';
          ctx.fillRect(
            deleteButtonX,
            deleteButtonY,
            deleteButtonSize,
            deleteButtonSize,
          );

          // Draw red X
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          const xPadding = 8;
          ctx.moveTo(deleteButtonX + xPadding, deleteButtonY + xPadding);
          ctx.lineTo(
            deleteButtonX + deleteButtonSize - xPadding,
            deleteButtonY + deleteButtonSize - xPadding,
          );
          ctx.moveTo(
            deleteButtonX + deleteButtonSize - xPadding,
            deleteButtonY + xPadding,
          );
          ctx.lineTo(
            deleteButtonX + xPadding,
            deleteButtonY + deleteButtonSize - xPadding,
          );
          ctx.stroke();

          // Label above delete button to make its purpose obvious
          ctx.fillStyle = '#ff5555'; // Bright red text
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Delete',
            deleteButtonX + deleteButtonSize / 2,
            deleteButtonY - 4,
          );

          // Instructions
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Press E to close',
            panelX + inventoryWidth / 2,
            panelY + inventoryHeight - 12,
          );

          ctx.restore();
        }

        // Build mode inventory panel (shows artifact choices)
        function getBuildModeInventoryLayout() {
          const slotSize = 40;
          const slotSpacing = 6;
          const slotsPerRow = 5;
          const panelPadding = 12;
          const titleHeight = 36; // Room for wrapped instruction text

          // Build a list of artifacts + their real inventory slot index
          const artifacts = [];
          for (let i = 0; i < inventory.slots.length; i++) {
            const item = inventory.slots[i];
            if (item && item.type === 'artifact') {
              artifacts.push({ item: item, slotIndex: i });
            }
          }

          const rows = Math.max(1, Math.ceil(artifacts.length / slotsPerRow));
          const panelWidth =
            slotsPerRow * slotSize +
            (slotsPerRow - 1) * slotSpacing +
            panelPadding * 2;
          const panelHeight =
            titleHeight +
            rows * slotSize +
            (rows - 1) * slotSpacing +
            panelPadding * 2;

          const panelX = Math.round(canvas.width / 2 - panelWidth / 2) + 0.5;
          const panelY = Math.round(canvas.height - panelHeight - 20) + 0.5;
          const slotsStartX = panelX + panelPadding;
          const slotsStartY = panelY + panelPadding + titleHeight;

          return {
            artifacts,
            rows,
            slotSize,
            slotSpacing,
            slotsPerRow,
            panelX,
            panelY,
            panelWidth,
            panelHeight,
            slotsStartX,
            slotsStartY,
            titleHeight,
            inventoryWidth: panelWidth, // Alias for compatibility
          };
        }

        // Wrap text into multiple lines that fit within a max width
        function wrapTextLines(text, maxWidth) {
          const words = text.split(' ');
          const lines = [];
          let currentLine = '';

          for (let i = 0; i < words.length; i++) {
            const testLine = currentLine
              ? currentLine + ' ' + words[i]
              : words[i];
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && currentLine) {
              lines.push(currentLine);
              currentLine = words[i];
            } else {
              currentLine = testLine;
            }
          }

          if (currentLine) {
            lines.push(currentLine);
          }

          return lines;
        }

        // Determine the week ending rank based on museum contents
        function getMuseumEndingRank() {
          const totalCases = museum.displayCases.length;
          const filledCases = museum.displayCases.filter(
            (displayCase) => displayCase.artifact,
          ).length;
          const museumArtifacts = museum.displayCases
            .filter((displayCase) => displayCase.artifact)
            .map((displayCase) => displayCase.artifact);

          // Check if cannon is placed
          const hasCannon =
            museum.cannonDisplay &&
            museum.cannonDisplay.artifact &&
            museum.cannonDisplay.artifact.name === 'Cannon';

          // Check if player has radar
          const hasRadar = radar.active;

          // Count total artifacts in museum (including cannon)
          const totalArtifacts = museumArtifacts.length + (hasCannon ? 1 : 0);

          // Check if museum is completely full (all display cases + cannon)
          const isFull = filledCases === totalCases && hasCannon;

          // Check if player has nothing (no artifacts, no items)
          if (totalArtifacts === 0 && !hasRadar) {
            return {
              name: 'Nothing',
              reason: 'Asleep at the wheel or something?',
            };
          }

          // Get all artifact names in museum (excluding cannon, which is separate)
          const museumNames = new Set(
            museumArtifacts.map((artifact) => artifact.name),
          );

          // Check if has all artifacts except cannon
          const artifactsWithoutCannon = ARTIFACT_NAMES.filter(
            (name) => name !== 'Cannon',
          );
          const hasAllArtifactsMinusCannon = artifactsWithoutCannon.every(
            (name) => museumNames.has(name),
          );

          // Check if has all artifacts including cannon
          const hasAllArtifactsWithCannon =
            hasAllArtifactsMinusCannon && hasCannon;

          // Legendary: Museum completely full + every artifact + cannon + radar
          if (isFull && hasAllArtifactsWithCannon && hasRadar) {
            return {
              name: 'Legendary',
              reason: 'You did everything that could be done, incredible!',
            };
          }

          // Above average: Museum completely full + every artifact + cannon
          if (isFull && hasAllArtifactsWithCannon) {
            return {
              name: 'Above Average',
              reason: "That's incredible! Almost to perfection!",
            };
          }

          // Average: Museum completely full OR has all artifacts (but museum not full)
          // If you have all artifacts but missed slots, you get Average
          if (isFull || hasAllArtifactsMinusCannon) {
            return {
              name: 'Average',
              reason: 'Good job!',
            };
          }

          // Below average: Museum not full and missing artifacts
          return {
            name: 'Below Average',
            reason: 'Your museum is staying afloat, barely.',
          };
        }

        function drawBuildModeInventoryPanel() {
          const layout = getBuildModeInventoryLayout();
          const artifacts = layout.artifacts;

          ctx.save();

          // Panel background
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.fillRect(
            layout.panelX,
            layout.panelY,
            layout.panelWidth,
            layout.panelHeight,
          );
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.lineWidth = 2;
          ctx.strokeRect(
            layout.panelX,
            layout.panelY,
            layout.panelWidth,
            layout.panelHeight,
          );

          // Title/instructions (wrapped to fit panel)
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          const instructionText =
            'Select an artifact, and then select a display case!';
          const instructionMaxWidth = layout.panelWidth - 16;
          const instructionLines = wrapTextLines(
            instructionText,
            instructionMaxWidth,
          );
          for (let i = 0; i < instructionLines.length; i++) {
            ctx.fillText(
              instructionLines[i],
              layout.panelX + layout.panelWidth / 2,
              layout.panelY + 4 + i * 16,
            );
          }

          // If no artifacts, show a hint
          if (artifacts.length === 0) {
            ctx.fillStyle = '#cccccc';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillText(
              'You have no artifacts',
              layout.panelX + layout.panelWidth / 2,
              layout.panelY + layout.panelHeight / 2,
            );
            ctx.restore();
            return;
          }

          let hoveredItemDescription = null;
          let hoveredItemTierColor = null; // Store tier color for hovered artifacts

          // Draw artifact slots
          for (let i = 0; i < artifacts.length; i++) {
            const row = Math.floor(i / layout.slotsPerRow);
            const col = i % layout.slotsPerRow;
            const slotX =
              layout.slotsStartX + col * (layout.slotSize + layout.slotSpacing);
            const slotY =
              layout.slotsStartY + row * (layout.slotSize + layout.slotSpacing);
            const artifact = artifacts[i];
            const item = artifact.item;

            // Slot background
            ctx.fillStyle = 'rgba(20, 40, 30, 0.8)';
            ctx.fillRect(slotX, slotY, layout.slotSize, layout.slotSize);

            // Slot outline (tier colors)
            let outlineColor = 'rgba(255, 255, 255, 0.7)';
            if (item.tier === 'common') outlineColor = '#9b9b9b';
            else if (item.tier === 'uncommon') outlineColor = '#7dff8a';
            else if (item.tier === 'rare') outlineColor = '#7dc7ff';
            else if (item.tier === 'super rare')
              outlineColor = '#00008b'; // Dark blue for super rare
            else if (item.tier === 'legendary') outlineColor = '#ffd700'; // Gold for legendary
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 1.5;
            ctx.strokeRect(slotX, slotY, layout.slotSize, layout.slotSize);

            // Highlight selected artifact
            if (museum.selectedArtifactIndex === artifact.slotIndex) {
              ctx.strokeStyle = '#ffff00';
              ctx.lineWidth = 2.5;
              ctx.strokeRect(
                slotX - 1,
                slotY - 1,
                layout.slotSize + 2,
                layout.slotSize + 2,
              );
            }

            // Draw sprite
            if (
              item.sprite &&
              item.sprite.complete &&
              item.sprite.naturalWidth
            ) {
              ctx.save();
              ctx.imageSmoothingEnabled = false;

              // Special handling for Cannon - make it bigger and preserve aspect ratio
              if (item.name === 'Cannon') {
                const spriteAspectRatio =
                  item.sprite.naturalWidth / item.sprite.naturalHeight;
                const maxSize = layout.slotSize - 2; // Use more of the slot

                let spriteWidth = maxSize;
                let spriteHeight = spriteWidth / spriteAspectRatio;

                // If height is too tall, scale down based on height instead
                if (spriteHeight > maxSize) {
                  spriteHeight = maxSize;
                  spriteWidth = spriteHeight * spriteAspectRatio;
                }

                const spriteX = slotX + (layout.slotSize - spriteWidth) / 2;
                const spriteY = slotY + (layout.slotSize - spriteHeight) / 2;
                ctx.drawImage(
                  item.sprite,
                  spriteX,
                  spriteY,
                  spriteWidth,
                  spriteHeight,
                );
              } else {
                // Normal items use square size
                const spriteSize = layout.slotSize - 6;
                const spriteX = slotX + (layout.slotSize - spriteSize) / 2;
                const spriteY = slotY + (layout.slotSize - spriteSize) / 2;

                // Special handling for Arrowhead - rotate 90 degrees
                if (item.name === 'Arrowhead') {
                  ctx.translate(
                    spriteX + spriteSize / 2,
                    spriteY + spriteSize / 2,
                  );
                  ctx.rotate(Math.PI / 2); // 90 degrees
                  ctx.drawImage(
                    item.sprite,
                    -spriteSize / 2,
                    -spriteSize / 2,
                    spriteSize,
                    spriteSize,
                  );
                } else {
                  ctx.drawImage(
                    item.sprite,
                    spriteX,
                    spriteY,
                    spriteSize,
                    spriteSize,
                  );
                }
              }
              ctx.restore();
            }

            // Hover tooltip
            const isHovered =
              mouseX >= slotX &&
              mouseX <= slotX + layout.slotSize &&
              mouseY >= slotY &&
              mouseY <= slotY + layout.slotSize;
            if (isHovered && !hoveredItemDescription) {
              const tierLabel = item.tier ? ` (${item.tier})` : '';
              hoveredItemDescription = item.name + tierLabel;

              // Store tier color for artifacts
              if (item.tier) {
                if (item.tier === 'common')
                  hoveredItemTierColor = '#9b9b9b'; // Gray
                else if (item.tier === 'uncommon')
                  hoveredItemTierColor = '#7dff8a'; // Light green
                else if (item.tier === 'rare')
                  hoveredItemTierColor = '#7dc7ff'; // Light blue
                else if (item.tier === 'super rare')
                  hoveredItemTierColor = '#00008b'; // Dark blue
                else if (item.tier === 'legendary')
                  hoveredItemTierColor = '#ffd700'; // Gold
              }
            }
          }

          if (hoveredItemDescription) {
            const tooltipPadding = 8;
            const tooltipX = mouseX + 10;
            const tooltipY = mouseY + 10;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const metrics = ctx.measureText(hoveredItemDescription);
            const tooltipWidth = metrics.width + tooltipPadding * 2;
            const tooltipHeight = 20;
            const finalTooltipX =
              tooltipX + tooltipWidth > canvas.width
                ? mouseX - tooltipWidth - 10
                : tooltipX;
            const finalTooltipY =
              tooltipY + tooltipHeight > canvas.height
                ? mouseY - tooltipHeight - 10
                : tooltipY;
            ctx.fillRect(
              finalTooltipX,
              finalTooltipY,
              tooltipWidth,
              tooltipHeight,
            );
            // Use tier color for border and text if artifact has tier, otherwise white
            const tooltipColor = hoveredItemTierColor || '#ffffff';
            ctx.strokeStyle = tooltipColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(
              finalTooltipX,
              finalTooltipY,
              tooltipWidth,
              tooltipHeight,
            );
            ctx.fillStyle = tooltipColor;
            ctx.fillText(
              hoveredItemDescription,
              finalTooltipX + tooltipPadding,
              finalTooltipY + 4,
            );
          }

          // Red X button for deleting artifacts (bottom right of panel)
          const deleteButtonSize = 32;
          const deleteButtonX =
            layout.panelX + layout.panelWidth - deleteButtonSize - 8; // 8px from right edge
          const deleteButtonY =
            layout.panelY + layout.panelHeight - deleteButtonSize - 8; // 8px from bottom edge

          // Check if hovering over delete button
          const isHoveringDelete =
            mouseX >= deleteButtonX &&
            mouseX <= deleteButtonX + deleteButtonSize &&
            mouseY >= deleteButtonY &&
            mouseY <= deleteButtonY + deleteButtonSize;

          // Draw delete button background
          ctx.fillStyle = isHoveringDelete
            ? 'rgba(255, 0, 0, 0.8)'
            : 'rgba(200, 0, 0, 0.6)';
          ctx.fillRect(
            deleteButtonX,
            deleteButtonY,
            deleteButtonSize,
            deleteButtonSize,
          );

          // Draw red X
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          const xPadding = 6;
          ctx.moveTo(deleteButtonX + xPadding, deleteButtonY + xPadding);
          ctx.lineTo(
            deleteButtonX + deleteButtonSize - xPadding,
            deleteButtonY + deleteButtonSize - xPadding,
          );
          ctx.moveTo(
            deleteButtonX + deleteButtonSize - xPadding,
            deleteButtonY + xPadding,
          );
          ctx.lineTo(
            deleteButtonX + xPadding,
            deleteButtonY + deleteButtonSize - xPadding,
          );
          ctx.stroke();

          // Label above delete button to make its purpose obvious
          ctx.fillStyle = '#ff5555'; // Bright red text
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Delete',
            deleteButtonX + deleteButtonSize / 2,
            deleteButtonY - 4,
          );

          ctx.restore();
        }

        // Title screen rendering
        function drawTitleScreen() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Save current camera position
          const savedCameraX = camera.x;
          const savedCameraY = camera.y;

          // Calculate smooth circular camera position
          const camX =
            titleScreenCamera.centerX +
            Math.cos(titleScreenCamera.angle) * titleScreenCamera.radiusX;
          const camY =
            titleScreenCamera.centerY +
            Math.sin(titleScreenCamera.angle) * titleScreenCamera.radiusY;

          // Set camera to title screen camera position for background rendering
          camera.x = camX;
          camera.y = camY;

          // Draw game world background (tiles, grid, flora) - no NPCs, player, or radar
          ctx.save();
          // World space: translate so that camera is centered
          ctx.translate(
            Math.round(canvas.width / 2 - camera.x),
            Math.round(canvas.height / 2 - camera.y),
          );

          // Draw background elements only
          drawTiles();
          drawFlora();

          ctx.restore();

          // Restore camera position
          camera.x = savedCameraX;
          camera.y = savedCameraY;

          // Draw semi-transparent overlay to darken background slightly and make text readable
          ctx.fillStyle = 'rgba(15, 26, 18, 0.6)'; // Dark green overlay with transparency
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Title text
          ctx.fillStyle = '#e8eaf6';
          ctx.font = 'bold 48px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(
            'Dig, Dig, Dig!',
            canvas.width / 2,
            canvas.height / 2 - 80,
          );

          // Play button
          const buttonX = canvas.width / 2;
          const buttonY = canvas.height / 2 + 40;
          const buttonWidth = 200;
          const buttonHeight = 60;

          // Check if mouse is hovering over play button
          const isHoveringPlay =
            mouseX >= buttonX - buttonWidth / 2 &&
            mouseX <= buttonX + buttonWidth / 2 &&
            mouseY >= buttonY - buttonHeight / 2 &&
            mouseY <= buttonY + buttonHeight / 2;

          // Button background (rounded rectangle) - brighter when hovering
          ctx.fillStyle = isHoveringPlay ? '#1f2f4a' : '#15193a'; // Brighter on hover
          ctx.strokeStyle = isHoveringPlay ? '#3b4f6f' : '#2b2f55'; // Brighter border on hover
          ctx.lineWidth = 3;
          const radius = 8;
          const btnX = buttonX - buttonWidth / 2;
          const btnY = buttonY - buttonHeight / 2;
          ctx.beginPath();
          ctx.moveTo(btnX + radius, btnY);
          ctx.lineTo(btnX + buttonWidth - radius, btnY);
          ctx.quadraticCurveTo(
            btnX + buttonWidth,
            btnY,
            btnX + buttonWidth,
            btnY + radius,
          );
          ctx.lineTo(btnX + buttonWidth, btnY + buttonHeight - radius);
          ctx.quadraticCurveTo(
            btnX + buttonWidth,
            btnY + buttonHeight,
            btnX + buttonWidth - radius,
            btnY + buttonHeight,
          );
          ctx.lineTo(btnX + radius, btnY + buttonHeight);
          ctx.quadraticCurveTo(
            btnX,
            btnY + buttonHeight,
            btnX,
            btnY + buttonHeight - radius,
          );
          ctx.lineTo(btnX, btnY + radius);
          ctx.quadraticCurveTo(btnX, btnY, btnX + radius, btnY);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Button text
          ctx.fillStyle = '#e8eaf6';
          ctx.font = '24px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText('Play', buttonX, buttonY);

          // Achievements button (under play button)
          const achievementsButtonX = canvas.width / 2;
          const achievementsButtonY = canvas.height / 2 + 120;
          const achievementsButtonWidth = 200;
          const achievementsButtonHeight = 60;

          // Back button (under achievements button)
          const backButtonX = canvas.width / 2;
          const backButtonY = canvas.height / 2 + 200;
          const backButtonWidth = 200;
          const backButtonHeight = 60;

          // Check if mouse is hovering over achievements button
          const isHoveringAchievements =
            mouseX >= achievementsButtonX - achievementsButtonWidth / 2 &&
            mouseX <= achievementsButtonX + achievementsButtonWidth / 2 &&
            mouseY >= achievementsButtonY - achievementsButtonHeight / 2 &&
            mouseY <= achievementsButtonY + achievementsButtonHeight / 2;

          // Button background (rounded rectangle) - brighter when hovering
          ctx.fillStyle = isHoveringAchievements ? '#1f2f4a' : '#15193a'; // Brighter on hover
          ctx.strokeStyle = isHoveringAchievements ? '#3b4f6f' : '#2b2f55'; // Brighter border on hover
          ctx.lineWidth = 3;
          const achievementsBtnX =
            achievementsButtonX - achievementsButtonWidth / 2;
          const achievementsBtnY =
            achievementsButtonY - achievementsButtonHeight / 2;
          ctx.beginPath();
          ctx.moveTo(achievementsBtnX + radius, achievementsBtnY);
          ctx.lineTo(
            achievementsBtnX + achievementsButtonWidth - radius,
            achievementsBtnY,
          );
          ctx.quadraticCurveTo(
            achievementsBtnX + achievementsButtonWidth,
            achievementsBtnY,
            achievementsBtnX + achievementsButtonWidth,
            achievementsBtnY + radius,
          );
          ctx.lineTo(
            achievementsBtnX + achievementsButtonWidth,
            achievementsBtnY + achievementsButtonHeight - radius,
          );
          ctx.quadraticCurveTo(
            achievementsBtnX + achievementsButtonWidth,
            achievementsBtnY + achievementsButtonHeight,
            achievementsBtnX + achievementsButtonWidth - radius,
            achievementsBtnY + achievementsButtonHeight,
          );
          ctx.lineTo(
            achievementsBtnX + radius,
            achievementsBtnY + achievementsButtonHeight,
          );
          ctx.quadraticCurveTo(
            achievementsBtnX,
            achievementsBtnY + achievementsButtonHeight,
            achievementsBtnX,
            achievementsBtnY + achievementsButtonHeight - radius,
          );
          ctx.lineTo(achievementsBtnX, achievementsBtnY + radius);
          ctx.quadraticCurveTo(
            achievementsBtnX,
            achievementsBtnY,
            achievementsBtnX + radius,
            achievementsBtnY,
          );
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Button text
          ctx.fillStyle = '#e8eaf6';
          ctx.font = '24px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText(
            'Achievements',
            achievementsButtonX,
            achievementsButtonY,
          );

          // Credits text
          ctx.fillStyle = '#a0a0a0'; // Lighter gray for credits
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Made by the FLL team "Potential Error", with the help of Bernie Durfee.',
            canvas.width / 2,
            canvas.height - 20,
          );
        }

        // Achievements screen rendering
        function drawAchievementsScreen() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Save current camera position
          const savedCameraX = camera.x;
          const savedCameraY = camera.y;

          // Calculate smooth circular camera position
          const camX =
            titleScreenCamera.centerX +
            Math.cos(titleScreenCamera.angle) * titleScreenCamera.radiusX;
          const camY =
            titleScreenCamera.centerY +
            Math.sin(titleScreenCamera.angle) * titleScreenCamera.radiusY;

          // Set camera to title screen camera position for background rendering
          camera.x = camX;
          camera.y = camY;

          // Draw game world background (tiles, grid, flora) - no NPCs, player, or radar
          ctx.save();
          // World space: translate so that camera is centered
          ctx.translate(
            Math.round(canvas.width / 2 - camera.x),
            Math.round(canvas.height / 2 - camera.y),
          );

          // Draw background elements only
          drawTiles();
          drawFlora();

          ctx.restore();

          // Restore camera position
          camera.x = savedCameraX;
          camera.y = savedCameraY;

          // Draw semi-transparent overlay to darken background slightly and make text readable
          ctx.fillStyle = 'rgba(15, 26, 18, 0.6)'; // Dark green overlay with transparency
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Title text
          ctx.fillStyle = '#e8eaf6';
          ctx.font = 'bold 48px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Achievements', canvas.width / 2, 60);

          // Back button (top left, same design as title screen buttons)
          const backButtonX = 50;
          const backButtonY = 30;
          const backButtonWidth = 120;
          const backButtonHeight = 40;

          // Check if mouse is hovering over back button
          const isHoveringBack =
            mouseX >= backButtonX - backButtonWidth / 2 &&
            mouseX <= backButtonX + backButtonWidth / 2 &&
            mouseY >= backButtonY - backButtonHeight / 2 &&
            mouseY <= backButtonY + backButtonHeight / 2;

          ctx.fillStyle = isHoveringBack ? '#1f2f4a' : '#15193a';
          ctx.strokeStyle = isHoveringBack ? '#3b4f6f' : '#2b2f55';
          ctx.lineWidth = 3;
          const backRadius = 8;
          const backBtnX = backButtonX - backButtonWidth / 2;
          const backBtnY = backButtonY - backButtonHeight / 2;
          ctx.beginPath();
          ctx.moveTo(backBtnX + backRadius, backBtnY);
          ctx.lineTo(backBtnX + backButtonWidth - backRadius, backBtnY);
          ctx.quadraticCurveTo(
            backBtnX + backButtonWidth,
            backBtnY,
            backBtnX + backButtonWidth,
            backBtnY + backRadius,
          );
          ctx.lineTo(
            backBtnX + backButtonWidth,
            backBtnY + backButtonHeight - backRadius,
          );
          ctx.quadraticCurveTo(
            backBtnX + backButtonWidth,
            backBtnY + backButtonHeight,
            backBtnX + backButtonWidth - backRadius,
            backBtnY + backButtonHeight,
          );
          ctx.lineTo(backBtnX + backRadius, backBtnY + backButtonHeight);
          ctx.quadraticCurveTo(
            backBtnX,
            backBtnY + backButtonHeight,
            backBtnX,
            backBtnY + backButtonHeight - backRadius,
          );
          ctx.lineTo(backBtnX, backBtnY + backRadius);
          ctx.quadraticCurveTo(
            backBtnX,
            backBtnY,
            backBtnX + backRadius,
            backBtnY,
          );
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = '#e8eaf6';
          ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText('Back', backButtonX, backButtonY);

          // Draw achievements list (smaller, in a grid)
          const startY = 120;
          const trophySize = 35; // Smaller trophies
          const achievementSpacingX = 200; // Horizontal spacing
          const achievementSpacingY = 70; // Vertical spacing (smaller)
          const achievementsPerRow = 3;
          const trophyX = 80;

          for (let i = 0; i < achievements.list.length; i++) {
            const achievement = achievements.list[i];
            const row = Math.floor(i / achievementsPerRow);
            const col = i % achievementsPerRow;
            const trophyXPos = trophyX + col * achievementSpacingX;
            const trophyYPos = startY + row * achievementSpacingY;

            // Draw achievement icon (trophy, radar, or cannon)
            // Determine which sprite to use based on achievement iconType
            let iconSprite = trophySprite; // Default to trophy
            if (achievement.iconType === 'radar') {
              iconSprite = radarIconSprite;
            } else if (achievement.iconType === 'cannon') {
              iconSprite = cannonIconSprite;
            }

            ctx.save();
            ctx.imageSmoothingEnabled = false;

            // Check if the appropriate sprite is loaded
            if (iconSprite.complete && iconSprite.naturalWidth > 0) {
              if (achievement.completed) {
                // Draw icon normally (colored)
                ctx.globalAlpha = 1.0;
                ctx.drawImage(
                  iconSprite,
                  trophyXPos - trophySize / 2,
                  trophyYPos - trophySize / 2,
                  trophySize,
                  trophySize,
                );
              } else {
                // Draw icon as silhouette (very dark, almost black)
                // Use a dark fill to create silhouette effect
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = '#000000'; // Black silhouette
                ctx.fillRect(
                  trophyXPos - trophySize / 2,
                  trophyYPos - trophySize / 2,
                  trophySize,
                  trophySize,
                );
                // Draw icon sprite with multiply blend mode to create dark silhouette
                ctx.globalCompositeOperation = 'multiply';
                ctx.globalAlpha = 0.3; // Very dark
                ctx.drawImage(
                  iconSprite,
                  trophyXPos - trophySize / 2,
                  trophyYPos - trophySize / 2,
                  trophySize,
                  trophySize,
                );
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1.0;
              }
            } else {
              // Fallback: simple shape if sprite not loaded
              ctx.fillStyle = achievement.completed ? '#ffd700' : '#333333';
              ctx.fillRect(
                trophyXPos - trophySize / 2,
                trophyYPos - trophySize / 2,
                trophySize,
                trophySize,
              );
            }

            // White border around achievement icon
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(
              trophyXPos - trophySize / 2,
              trophyYPos - trophySize / 2,
              trophySize,
              trophySize,
            );
            ctx.restore();

            // Draw achievement name and description
            // Names are always visible, descriptions show "???" when locked
            const nameText = achievement.name; // Always show name
            const descText = achievement.completed
              ? achievement.description
              : '???';

            ctx.fillStyle = achievement.completed ? '#ffd700' : '#888888';
            ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              nameText,
              trophyXPos + trophySize / 2 + 10,
              trophyYPos - 8,
            );

            ctx.fillStyle = achievement.completed ? '#ffffff' : '#666666';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillText(
              descText,
              trophyXPos + trophySize / 2 + 10,
              trophyYPos + 10,
            );
          }
        }

        // Save slot selection screen rendering
        // Shows 3 save slots that the player can choose from
        function drawSaveSelectScreen() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Save current camera position
          const savedCameraX = camera.x;
          const savedCameraY = camera.y;

          // Calculate smooth circular camera position
          const camX =
            titleScreenCamera.centerX +
            Math.cos(titleScreenCamera.angle) * titleScreenCamera.radiusX;
          const camY =
            titleScreenCamera.centerY +
            Math.sin(titleScreenCamera.angle) * titleScreenCamera.radiusY;

          // Set camera to title screen camera position for background rendering
          camera.x = camX;
          camera.y = camY;

          // Draw game world background
          ctx.save();
          ctx.translate(
            Math.round(canvas.width / 2 - camera.x),
            Math.round(canvas.height / 2 - camera.y),
          );
          drawTiles();
          drawFlora();
          ctx.restore();

          // Restore camera position
          camera.x = savedCameraX;
          camera.y = savedCameraY;

          // Draw semi-transparent overlay
          ctx.fillStyle = 'rgba(15, 26, 18, 0.85)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Back button (same position as Achievements screen Back)
          const backButtonX = 50;
          const backButtonY = 30;
          const backButtonWidth = 120;
          const backButtonHeight = 40;
          const isHoveringBack =
            mouseX >= backButtonX - backButtonWidth / 2 &&
            mouseX <= backButtonX + backButtonWidth / 2 &&
            mouseY >= backButtonY - backButtonHeight / 2 &&
            mouseY <= backButtonY + backButtonHeight / 2;
          ctx.fillStyle = isHoveringBack ? '#1f2f4a' : '#15193a';
          ctx.strokeStyle = isHoveringBack ? '#3b4f6f' : '#2b2f55';
          ctx.lineWidth = 3;
          const backRadius = 8;
          const backBtnX = backButtonX - backButtonWidth / 2;
          const backBtnY = backButtonY - backButtonHeight / 2;
          ctx.beginPath();
          ctx.moveTo(backBtnX + backRadius, backBtnY);
          ctx.lineTo(backBtnX + backButtonWidth - backRadius, backBtnY);
          ctx.quadraticCurveTo(
            backBtnX + backButtonWidth,
            backBtnY,
            backBtnX + backButtonWidth,
            backBtnY + backRadius,
          );
          ctx.lineTo(
            backBtnX + backButtonWidth,
            backBtnY + backButtonHeight - backRadius,
          );
          ctx.quadraticCurveTo(
            backBtnX + backButtonWidth,
            backBtnY + backButtonHeight,
            backBtnX + backButtonWidth - backRadius,
            backBtnY + backButtonHeight,
          );
          ctx.lineTo(backBtnX + backRadius, backBtnY + backButtonHeight);
          ctx.quadraticCurveTo(
            backBtnX,
            backBtnY + backButtonHeight,
            backBtnX,
            backBtnY + backButtonHeight - backRadius,
          );
          ctx.lineTo(backBtnX, backBtnY + backRadius);
          ctx.quadraticCurveTo(backBtnX, backBtnY, backBtnX + backRadius, backBtnY);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#e8eaf6';
          ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Back', backButtonX, backButtonY);

          // Draw 3 save slots
          const slotWidth = 500;
          const slotHeight = 100;
          const slotSpacing = 20;
          const startY = 120;
          const centerX = canvas.width / 2;

          for (let i = 0; i < SAVE_SLOTS; i++) {
            const slotY = startY + i * (slotHeight + slotSpacing);
            const slotInfo = getSaveSlotInfo(i);

            // Check if mouse is hovering over this slot
            const isHoveringSlot =
              mouseX >= centerX - slotWidth / 2 &&
              mouseX <= centerX + slotWidth / 2 &&
              mouseY >= slotY &&
              mouseY <= slotY + slotHeight;

            // Slot background
            ctx.fillStyle = slotInfo
              ? isHoveringSlot
                ? 'rgba(50, 60, 120, 0.9)'
                : 'rgba(40, 50, 100, 0.8)'
              : 'rgba(30, 30, 50, 0.6)';
            ctx.fillRect(centerX - slotWidth / 2, slotY, slotWidth, slotHeight);

            // Slot border
            ctx.strokeStyle = '#e8eaf6';
            ctx.lineWidth = 2;
            ctx.strokeRect(
              centerX - slotWidth / 2,
              slotY,
              slotWidth,
              slotHeight,
            );

            // Slot text (vertically centered in slot rectangle)
            const slotCenterY = slotY + slotHeight / 2;
            ctx.fillStyle = '#e8eaf6';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';

            if (slotInfo) {
              // Save exists - show info (two lines centered as a block)
              const dayName =
                dayTime.days[slotInfo.dayTime.currentDay] || 'Monday';
              const hour = slotInfo.dayTime.currentHour || 8;
              const status = slotInfo.completed ? 'Completed' : 'In Progress';

              ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(
                `Save Slot ${i + 1}`,
                centerX - slotWidth / 2 + 15,
                slotCenterY - 15,
              );

              ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(
                `${dayName}, ${hour}:00 - ${status}`,
                centerX - slotWidth / 2 + 15,
                slotCenterY + 15,
              );
            } else {
              // Empty slot (single line centered)
              ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(
                `Save Slot ${i + 1}`,
                centerX - slotWidth / 2 + 15,
                slotCenterY,
              );
            }

            // Delete button (only if save exists)
            if (slotInfo) {
              const deleteButtonSize = 30;
              const deleteButtonX =
                centerX + slotWidth / 2 - deleteButtonSize - 10;
              const deleteButtonY = slotY + 10;

              // Check if hovering over delete button
              const isHoveringDelete =
                mouseX >= deleteButtonX &&
                mouseX <= deleteButtonX + deleteButtonSize &&
                mouseY >= deleteButtonY &&
                mouseY <= deleteButtonY + deleteButtonSize;

              // Delete button background
              ctx.fillStyle = isHoveringDelete
                ? 'rgba(200, 50, 50, 0.9)'
                : 'rgba(150, 30, 30, 0.8)';
              ctx.fillRect(
                deleteButtonX,
                deleteButtonY,
                deleteButtonSize,
                deleteButtonSize,
              );

              // Delete button border
              ctx.strokeStyle = '#ff6666';
              ctx.lineWidth = 1;
              ctx.strokeRect(
                deleteButtonX,
                deleteButtonY,
                deleteButtonSize,
                deleteButtonSize,
              );

              // Delete button text
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'X',
                deleteButtonX + deleteButtonSize / 2,
                deleteButtonY + deleteButtonSize / 2,
              );
            }
          }
        }

        // Starting screen rendering (shown while heavy setup runs)
        function drawStartingScreen() {
          // Simple screen so the player sees instant feedback on Space
          ctx.fillStyle = world.bg;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = 'rgba(15, 26, 18, 0.9)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = '#e8eaf6';
          ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Starting game...', canvas.width / 2, canvas.height / 2);
        }

        // Controls screen rendering
        function drawControlsScreen() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Fill canvas with world background color
          ctx.fillStyle = world.bg;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Draw semi-transparent overlay
          ctx.fillStyle = 'rgba(15, 26, 18, 0.9)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Title text
          ctx.fillStyle = '#e8eaf6';
          ctx.font = 'bold 36px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Controls', canvas.width / 2, canvas.height / 2 - 120);

          // Controls text
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const controlsText = [
            'Use the WASD keys or the Arrow keys on your keyboard to move',
            'Press the space bar when close to a person to talk to them. Try to talk to as many as you can!',
            'Hold down the shift key to move faster. Keep an eye on your stamina on the top left!',
            'Press E to open your inventory to check your artifacts. Click on an artifact, then the delete button to delete it.',
          ];

          let textY = canvas.height / 2 - 40;
          for (let i = 0; i < controlsText.length; i++) {
            ctx.fillText(controlsText[i], canvas.width / 2, textY);
            textY += 30; // Spacing between lines (reduced from 35)
          }

          // Continue instruction
          ctx.fillStyle = '#e8eaf6';
          ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText(
            'Press space to continue to the game',
            canvas.width / 2,
            canvas.height / 2 + 100,
          );
        }

        // Handle mouse clicks for title screen and achievements screen
        canvas.addEventListener('click', (e) => {
          if (gameState === 'achievements') {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Back button (top left, same size as drawn)
            const backButtonX = 50;
            const backButtonY = 30;
            const backButtonWidth = 120;
            const backButtonHeight = 40;

            if (
              x >= backButtonX - backButtonWidth / 2 &&
              x <= backButtonX + backButtonWidth / 2 &&
              y >= backButtonY - backButtonHeight / 2 &&
              y <= backButtonY + backButtonHeight / 2
            ) {
              // Go back to title screen
              gameState = 'title';
              e.stopPropagation();
              return;
            }
          } else if (gameState === 'title') {
            const rect = canvas.getBoundingClientRect();
            // Account for canvas scaling - convert display coordinates to internal canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Check if click is on achievements button
            const achievementsButtonX = canvas.width / 2;
            const achievementsButtonY = canvas.height / 2 + 120;
            const achievementsButtonWidth = 200;
            const achievementsButtonHeight = 60;

            if (
              x >= achievementsButtonX - achievementsButtonWidth / 2 &&
              x <= achievementsButtonX + achievementsButtonWidth / 2 &&
              y >= achievementsButtonY - achievementsButtonHeight / 2 &&
              y <= achievementsButtonY + achievementsButtonHeight / 2
            ) {
              // Go to achievements screen
              gameState = 'achievements';
              e.stopPropagation();
              return;
            }

            // Check if click is on play button
            const buttonX = canvas.width / 2;
            const buttonY = canvas.height / 2 + 40;
            const buttonWidth = 200;
            const buttonHeight = 60;

            if (
              x >= buttonX - buttonWidth / 2 &&
              x <= buttonX + buttonWidth / 2 &&
              y >= buttonY - buttonHeight / 2 &&
              y <= buttonY + buttonHeight / 2
            ) {
              // Go to save selection screen
              gameState = 'saveSelect';
              e.stopPropagation(); // Prevent other handlers from processing
            }
          } else if (gameState === 'saveSelect') {
            // Handle clicks on save selection screen
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const slotWidth = 500;
            const slotHeight = 100;
            const slotSpacing = 20;
            const startY = 120;
            const centerX = canvas.width / 2;

            // Check save slot clicks
            for (let i = 0; i < SAVE_SLOTS; i++) {
              const slotY = startY + i * (slotHeight + slotSpacing);
              const slotInfo = getSaveSlotInfo(i);

              // Check if clicking on the slot (but not delete button)
              const deleteButtonSize = 30;
              const deleteButtonX =
                centerX + slotWidth / 2 - deleteButtonSize - 10;
              const deleteButtonY = slotY + 10;

              // Check delete button first (if save exists)
              if (
                slotInfo &&
                x >= deleteButtonX &&
                x <= deleteButtonX + deleteButtonSize &&
                y >= deleteButtonY &&
                y <= deleteButtonY + deleteButtonSize
              ) {
                // Delete this save slot
                if (confirm(`Delete Save Slot ${i + 1}?`)) {
                  deleteSaveSlot(i);
                }
                return;
              }

              // Check if clicking on the slot itself
              if (
                x >= centerX - slotWidth / 2 &&
                x <= centerX + slotWidth / 2 &&
                y >= slotY &&
                y <= slotY + slotHeight
              ) {
                // Load or start new game in this slot
                if (slotInfo) {
                  // Load existing save
                  if (loadGame(i)) {
                    // Successfully loaded - go to playing state
                    gameState = 'playing';
                  }
                } else {
                  // Start new game in this slot
                  currentSaveSlot = i;
                  gameState = 'controls';
                }
                return;
              }
            }

            // Check back button (same position as Achievements Back)
            const backButtonX = 50;
            const backButtonY = 30;
            const backButtonWidth = 120;
            const backButtonHeight = 40;
            if (
              x >= backButtonX - backButtonWidth / 2 &&
              x <= backButtonX + backButtonWidth / 2 &&
              y >= backButtonY - backButtonHeight / 2 &&
              y <= backButtonY + backButtonHeight / 2
            ) {
              // Go back to title screen
              gameState = 'title';
            }
          }
        });

        let lastTime = performance.now();
        function loop(now) {
          try {
            const dt = Math.min(33, now - lastTime);
            lastTime = now;
            const dtSeconds = dt / 1000;

            if (gameState === 'loading') {
              // Draw loading screen first to ensure it shows
              drawLoadingScreen();

              // Update loading progress (pass dt in milliseconds)
              updateLoadingProgress(dt);

              // Only proceed to title screen when:
              // 1. Progress bar has reached 100% (7.5 seconds have passed)
              // 2. All assets are loaded (or at least we've waited long enough)
              if (
                loadingState.displayProgress >= 0.99 &&
                loadingState.allLoaded
              ) {
                // Load achievements from localStorage (global, not per-save)
                loadAchievements();

                // Ensure tiles are regenerated with sprites before starting
                tileRegenerationScheduled = false;
                doRegenerateTiles(); // Regenerate all tiles with loaded sprites
                gameState = 'title'; // Transition to title screen instead of directly to playing
              }
            } else if (gameState === 'title') {
              // Update title screen camera for smooth circular scrolling
              titleScreenCamera.angle += titleScreenCamera.speed * dtSeconds;
              // Keep angle in reasonable range to prevent overflow
              if (titleScreenCamera.angle > Math.PI * 2) {
                titleScreenCamera.angle -= Math.PI * 2;
              }
              drawTitleScreen();
            } else if (gameState === 'achievements') {
              // Update achievements screen camera for smooth circular scrolling
              titleScreenCamera.angle += titleScreenCamera.speed * dtSeconds;
              // Keep angle in reasonable range to prevent overflow
              if (titleScreenCamera.angle > Math.PI * 2) {
                titleScreenCamera.angle -= Math.PI * 2;
              }
              drawAchievementsScreen();
            } else if (gameState === 'saveSelect') {
              // Update title screen camera for save selection screen too
              titleScreenCamera.angle += titleScreenCamera.speed * dtSeconds;
              if (titleScreenCamera.angle > Math.PI * 2) {
                titleScreenCamera.angle -= Math.PI * 2;
              }
              drawSaveSelectScreen();
            } else if (gameState === 'controls') {
              // Draw controls screen
              drawControlsScreen();
            } else if (gameState === 'starting') {
              // Show a quick transition screen while heavy setup runs
              drawStartingScreen();

              if (startGamePending) {
                startGamePending = false;
                // Defer the heavy setup so the screen can render first
                setTimeout(startNewGameFromControls, 0);
              }
            } else {
              update(dt);
              render();
            }
          } catch (error) {
            console.error('Game loop error:', error);
            // Draw error screen
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ff0000';
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Error: ' + error.message,
              canvas.width / 2,
              canvas.height / 2,
            );
          }

          requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
