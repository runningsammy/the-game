<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Simple Player Movement</title>
    <style>
    html, body {
      height: 100%;
            margin: 0;
      background: #0f1a12;
      color: #e8eaf6;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100%;
    }
    header, footer {
      padding: 6px 14px;
      background: #15193a;
      border-bottom: 1px solid #2b2f55;
    }
    header {
      position: sticky;
            top: 0;
      z-index: 1;
    }
    footer {
      border-top: 1px solid #2b2f55;
      border-bottom: none;
    }
    main {
      display: grid;
      place-items: center;
      padding: 0;
      overflow: hidden;
    }
    canvas {
      background: #1c7f2d;
      border: 1px solid #2b2f55;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.03);
      image-rendering: pixelated;
      max-width: 100%;
      height: 100%;
      width: auto;
    }
    .hint {
      opacity: 0.8;
      font-size: 11px;
    }
    kbd {
      background: #202659;
      border: 1px solid #303776;
      border-bottom-width: 2px;
      border-radius: 4px;
      padding: 1px 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
        }
    </style>
</head>
<body>
  <div class="wrap">
    <header>
      <strong>Simple Player Movement</strong>
    </header>
    <main>
      <canvas id="game" width="800" height="500" aria-label="Game canvas"></canvas>
    </main>
    </div>
    
    <script>
    (function() {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // Make the world larger than the canvas so a camera makes sense
      const world = {
        width: 2400,
        height: 2000, // Increased height to prevent bottom tiles from being cut off
        bg: '#0f1226'
      };

      // Camera centered on a target (the player), smooth follow
      const camera = {
        x: world.width / 2,
        y: world.height / 2,
        followLerp: 0.12 // smaller = slower, larger = snappier
      };

      const tileSize = 32;
      const tileCols = Math.ceil(world.width / tileSize);
      const tileRows = Math.ceil(world.height / tileSize);
      const tileCell = 4;
      const cellsPerTile = tileSize / tileCell;

      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      function createScatter(count, minSize, maxSize, margin = 60, minDistance = 120) {
        const sprites = [];
        const maxAttempts = 50; // Reduced attempts for faster generation
        const cellSize = minDistance * 2; // Use spatial grid for faster lookups
        const gridCols = Math.ceil(world.width / cellSize);
        const gridRows = Math.ceil(world.height / cellSize);
        const grid = Array.from({ length: gridRows }, () => Array(gridCols).fill(null).map(() => []));
        
        function getGridCell(x, y) {
          const col = Math.floor(x / cellSize);
          const row = Math.floor(y / cellSize);
          return { row: Math.max(0, Math.min(gridRows - 1, row)), col: Math.max(0, Math.min(gridCols - 1, col)) };
        }
        
        for (let i = 0; i < count; i++) {
          const size = randomRange(minSize, maxSize);
          const colliderRadius = size * 0.42;
          const requiredDistance = minDistance + colliderRadius;
          const requiredDistanceSq = requiredDistance * requiredDistance;
          
          let x, y, valid = false;
          let placementAttempts = 0;
          
          while (!valid && placementAttempts < maxAttempts) {
            placementAttempts++;
            x = randomRange(margin, world.width - margin);
            y = randomRange(margin, world.height - margin);
            
            // Check only nearby cells in spatial grid
            const cell = getGridCell(x, y);
            valid = true;
            
            // Check cells in 3x3 area around the placement
            for (let dr = -1; dr <= 1 && valid; dr++) {
              for (let dc = -1; dc <= 1 && valid; dc++) {
                const checkRow = cell.row + dr;
                const checkCol = cell.col + dc;
                if (checkRow >= 0 && checkRow < gridRows && checkCol >= 0 && checkCol < gridCols) {
                  for (const existing of grid[checkRow][checkCol]) {
                    const dx = x - existing.x;
                    const dy = y - existing.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < requiredDistanceSq) {
                      valid = false;
                      break;
                    }
                  }
                }
              }
            }
          }
          
          if (valid) {
            const tree = {
              x,
              y,
              size,
              rotation: randomRange(-Math.PI / 8, Math.PI / 8),
              colliderRadius
            };
            sprites.push(tree);
            const cell = getGridCell(x, y);
            grid[cell.row][cell.col].push(tree);
          }
        }
        return sprites;
      }

      const flora = {
        trees: createScatter(65, 78, 102, 140, 180) // Reduced count from 110 to 65, increased spacing to 180
      };

      // Balancing minigame state
      const balancingMinigame = {
        active: false,
        potAngle: 0, // Current angle of the pot (in radians, 0 = balanced)
        potAngularVelocity: 0, // How fast the pot is rotating
        timeRemaining: 15, // Seconds remaining
        baseReward: 10, // Base money reward
        stickX: 0, // X position of the stick (center of screen)
        stickY: 0, // Y position of the stick
        potSprite: null,
        tileRow: null,
        tileCol: null,
        breaking: false, // Whether the pot is currently breaking
        breakTimer: 0, // Timer for breaking animation
        pieces: [] // Array of pot pieces flying off
      };

      // Brushing minigame state
      const brushingMinigame = {
        active: false,
        dirtLevel: 1.0, // 0 = clean, 1.0 = fully dirty
        redness: 0, // 0 = normal, 1.0 = broken (red)
        timeHoldingSpace: 0, // Time spent holding space (in seconds)
        redTriggerTime: 0, // Random time between 5-10 seconds when dirt will turn red
        baseReward: 10, // Base money reward
        tileRow: null,
        tileCol: null,
        brushX: 0, // X position of brush
        brushY: 0, // Y position of brush
        completed: false, // Whether the minigame was completed successfully
        broken: false // Whether the dirt broke (turned too red)
      };
      
      // Load pot sprite from PNG image
      const potSprite = new Image();
      potSprite.src = 'pot.png';
      potSprite.imageSmoothingEnabled = false; // Pixelated rendering
      
      // Load brush sprite from PNG image
      const brushSprite = new Image();
      brushSprite.src = 'brush.png';
      brushSprite.imageSmoothingEnabled = false; // Pixelated rendering
      
      // Load dirt sprite from PNG image
      const dirtSprite = new Image();
      dirtSprite.src = 'dirt.png';
      dirtSprite.imageSmoothingEnabled = false; // Pixelated rendering
      
      // Load money border sprite from PNG image
      const moneyBorderSprite = new Image();
      moneyBorderSprite.src = 'money_border.png';
      moneyBorderSprite.imageSmoothingEnabled = false; // Pixelated rendering
      
      // Load old guy sprite from PNG image
      const oldGuySprite = new Image();
      oldGuySprite.src = 'oldguy.png';
      oldGuySprite.imageSmoothingEnabled = false; // Pixelated rendering
      
      // Load shopkeeper sprite from PNG image
      const shopkeeperSprite = new Image();
      shopkeeperSprite.src = 'shopkeeper.png';
      shopkeeperSprite.imageSmoothingEnabled = false; // Pixelated rendering
      
      // Load player sprites from PNG images
      const playerSpriteIdle = new Image();
      playerSpriteIdle.src = 'player.png';
      playerSpriteIdle.imageSmoothingEnabled = false; // Pixelated rendering
      
      const playerSpriteBack = new Image();
      playerSpriteBack.src = 'player_back.png';
      playerSpriteBack.imageSmoothingEnabled = false; // Pixelated rendering
      
      const playerSpriteBackWalk1 = new Image();
      playerSpriteBackWalk1.src = 'player_back_walk1.png';
      playerSpriteBackWalk1.imageSmoothingEnabled = false; // Pixelated rendering
      
      const playerSpriteBackWalk2 = new Image();
      playerSpriteBackWalk2.src = 'player_back_walk2.png';
      playerSpriteBackWalk2.imageSmoothingEnabled = false; // Pixelated rendering
      
      const playerSpriteWalk1 = new Image();
      playerSpriteWalk1.src = 'player_walk1.png';
      playerSpriteWalk1.imageSmoothingEnabled = false; // Pixelated rendering
      
      const playerSpriteWalk2 = new Image();
      playerSpriteWalk2.src = 'player_walk2.png';
      playerSpriteWalk2.imageSmoothingEnabled = false; // Pixelated rendering
      
      // Walking animation state
      let walkAnimationFrame = 0;
      const walkAnimationSpeed = 0.15; // How fast the animation cycles (lower = faster)

      function createTileCanvas(drawFn) {
        const buffer = document.createElement('canvas');
        buffer.width = tileSize;
        buffer.height = tileSize;
        const bctx = buffer.getContext('2d');
        drawFn(bctx);
        return buffer;
      }

      const colors = {
        grassBase: '#28a933',
        grassBright: '#36c843',
        grassDark: '#1e902a',
        outline: '#0c0c0c',
        rockLight: '#c2c2c2',
        rockMid: '#959595',
        rockDark: '#5f5f5f',
        rockShadow: '#3f3f3f',
        moundOuter: '#0c3f16',
        moundInner: '#0f5c1f',
        moundHighlight: '#157f2d',
        logLight: '#147429',
        logDark: '#0e5a20',
        logShadow: '#094217',
        redDark: '#780808',
        redBase: '#c40f0f',
        redBright: '#ff2a2a'
      };

      function fillCell(ctx, cx, cy, color) {
        ctx.fillStyle = color;
        ctx.fillRect(cx * tileCell, cy * tileCell, tileCell, tileCell);
      }

      function drawPlus(ctx, cx, cy, color) {
        fillCell(ctx, cx, cy, color);
        fillCell(ctx, cx - 1, cy, color);
        fillCell(ctx, cx + 1, cy, color);
        fillCell(ctx, cx, cy - 1, color);
        fillCell(ctx, cx, cy + 1, color);
      }

      function paintGrassBase(ctx, plusLayout) {
        ctx.fillStyle = colors.grassBase;
        ctx.fillRect(0, 0, tileSize, tileSize);
        const layout = plusLayout || [
          { x: 2, y: 2, color: colors.grassBright },
          { x: 5, y: 4, color: colors.grassBright },
          { x: 1, y: 5, color: colors.grassDark },
          { x: 6, y: 1, color: colors.grassDark }
        ];
        layout.forEach((plus) => drawPlus(ctx, plus.x, plus.y, plus.color));
      }

      const tileDefinitions = [
        {
          name: 'grass',
          weight: 110,
          draw(ctx) {
            paintGrassBase(ctx);
          }
        },
        {
          name: 'singleRock',
          weight: 10,
          draw(ctx) {
            paintGrassBase(ctx);
            const x = tileCell * 1;
            const y = tileCell * 1;
            const width = tileCell * 6;
            const height = tileCell * 6;
            ctx.fillStyle = colors.outline;
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = colors.rockDark;
            ctx.fillRect(x + tileCell, y + tileCell, width - tileCell * 2, height - tileCell * 2);
            ctx.fillStyle = colors.rockMid;
            ctx.fillRect(x + tileCell * 2, y + tileCell * 2, width - tileCell * 4, height - tileCell * 3);
            ctx.fillStyle = colors.rockLight;
            ctx.fillRect(x + tileCell * 2, y + tileCell * 2, width - tileCell * 5, height - tileCell * 5);
            ctx.fillStyle = colors.rockShadow;
            ctx.fillRect(x + tileCell * 2, y + tileCell * 4, width - tileCell * 4, tileCell * 2);
          }
        },
        {
          name: 'rockCluster',
          weight: 8,
          draw(ctx) {
            paintGrassBase(ctx, [
              { x: 1, y: 1, color: colors.grassBright },
              { x: 5, y: 2, color: colors.grassDark }
            ]);
            const cluster = [
              { x: 1, y: 2, w: 3, h: 3, light: colors.rockMid },
              { x: 4, y: 1, w: 3, h: 3, light: colors.rockLight },
              { x: 3, y: 4, w: 4, h: 3, light: colors.rockDark },
              { x: 0, y: 4, w: 3, h: 3, light: colors.rockMid }
            ];
            cluster.forEach((rock) => {
              ctx.fillStyle = colors.outline;
              ctx.fillRect((rock.x) * tileCell, (rock.y) * tileCell, rock.w * tileCell, rock.h * tileCell);
              ctx.fillStyle = rock.light;
              ctx.fillRect((rock.x + 0.5) * tileCell, (rock.y + 0.5) * tileCell, (rock.w - 1) * tileCell, (rock.h - 1) * tileCell);
              ctx.fillStyle = colors.rockShadow;
              ctx.fillRect((rock.x + 0.5) * tileCell, (rock.y + rock.h - 1) * tileCell, (rock.w - 1.2) * tileCell, tileCell);
            });
          }
        },
        {
          name: 'moundedBush',
          weight: 7,
          draw(ctx) {
            paintGrassBase(ctx, [
              { x: 2, y: 2, color: colors.grassBright },
              { x: 5, y: 4, color: colors.grassDark }
            ]);
            const x = tileCell;
            const y = tileCell * 2;
            const w = tileCell * 6;
            const h = tileCell * 4;
            ctx.fillStyle = colors.outline;
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = colors.moundOuter;
            ctx.fillRect(x + tileCell, y + tileCell, w - tileCell * 2, h - tileCell * 2);
            ctx.fillStyle = colors.moundInner;
            ctx.fillRect(x + tileCell * 1.5, y + tileCell * 1.5, w - tileCell * 3, h - tileCell * 3);
            ctx.fillStyle = colors.moundHighlight;
            ctx.fillRect(x + tileCell * 2, y + tileCell * 1.5, w - tileCell * 4, tileCell * 2);
          }
        },
        {
          name: 'logRows',
          weight: 5,
          draw(ctx) {
            paintGrassBase(ctx, [
              { x: 2, y: 1, color: colors.grassBright },
              { x: 5, y: 5, color: colors.grassDark }
            ]);
            const startX = tileCell;
            const width = tileCell * 6;
            const logHeight = tileCell * 2;
            const spacing = tileCell * 2;
            for (let i = 0; i < 2; i++) {
              const y = tileCell + i * (logHeight + spacing);
              ctx.fillStyle = colors.outline;
              ctx.fillRect(startX, y, width, logHeight);
              ctx.fillStyle = colors.logDark;
              ctx.fillRect(startX + tileCell, y + tileCell / 2, width - tileCell * 2, logHeight - tileCell);
              ctx.fillStyle = colors.logLight;
              ctx.fillRect(startX + tileCell, y + tileCell / 2, width - tileCell * 2, logHeight - tileCell * 1.5);
              for (let notch = startX + tileCell; notch < startX + width - tileCell; notch += tileCell * 1.5) {
                ctx.fillStyle = colors.logShadow;
                ctx.fillRect(notch, y + tileCell / 2, tileCell / 2, logHeight - tileCell);
              }
            }
          }
        },
        {
          name: 'redX',
          weight: 1,
          draw(ctx) {
            paintGrassBase(ctx, [
              { x: 2, y: 1, color: colors.grassBright },
              { x: 5, y: 6, color: colors.grassDark }
            ]);
            const maxIndex = cellsPerTile - 1;
            for (let y = 0; y < cellsPerTile; y++) {
              for (let x = 0; x < cellsPerTile; x++) {
                const diag1 = Math.abs(x - y);
                const diag2 = Math.abs(x + y - maxIndex);
                const onX = diag1 <= 1 || diag2 <= 1;
                if (!onX) continue;
                let color = colors.redBase;
                if (diag1 === 0 && diag2 === 0) {
                  color = colors.redBright;
                } else if (diag1 === 1 || diag2 === 1 || x === 0 || y === 0 || x === maxIndex || y === maxIndex) {
                  color = colors.redDark;
                }
                fillCell(ctx, x, y, color);
              }
            }
          }
        }
      ];

      const tileWeightTotal = tileDefinitions.reduce((sum, t) => sum + t.weight, 0);

      function pickTileDefinition() {
        let roll = Math.random() * tileWeightTotal;
        for (const def of tileDefinitions) {
          if ((roll -= def.weight) <= 0) {
            return def;
          }
        }
        return tileDefinitions[0];
      }

      // Helper function to check if a tile position overlaps with any tree
      function isTreeAtTile(row, col) {
        const tileCenterX = (col + 0.5) * tileSize;
        const tileCenterY = (row + 0.5) * tileSize;
        
        for (let i = 0; i < flora.trees.length; i++) {
          const tree = flora.trees[i];
          const dx = tree.x - tileCenterX;
          const dy = tree.y - tileCenterY;
          const distSq = dx * dx + dy * dy;
          const treeRadius = tree.colliderRadius || tree.size * 0.42;
          const minDistSq = (tileSize / 2 + treeRadius) * (tileSize / 2 + treeRadius);
          
          if (distSq < minDistSq) {
            return true;
          }
        }
        return false;
      }

      // Generate tiles with check for trees
      const tileMap = [];
      for (let row = 0; row < tileRows; row++) {
        tileMap[row] = [];
        for (let col = 0; col < tileCols; col++) {
          let def = pickTileDefinition();
          
          // If redX tile was picked and there's a tree at this position, replace with grass
          if (def.name === 'redX' && isTreeAtTile(row, col)) {
            def = tileDefinitions.find(d => d.name === 'grass');
          }
          
          tileMap[row][col] = {
            name: def.name,
            canvas: createTileCanvas(def.draw)
          };
        }
      }

      const player = {
        x: world.width / 2,
        y: world.height - 40,
        width: 43,
        height: 43,
        color: '#7cffb3', // Original teal/green player color
        outline: '#0c2a19',
        vx: 0,
        vy: 0,
        maxSpeed: 2.0,
        accel: 0.25,
        friction: 0.86,
        sprintMultiplier: 1.6,
        radius: Math.max(39, 39) * 0.5 // Cache radius calculation
      };

      // Stamina system for sprinting
      const stamina = {
        current: 100,
        max: 100,
        drainPerSecond: 35,   // how fast stamina drains while sprinting
        regenPerSecond: 22,   // how fast stamina regenerates when not sprinting
        minToSprint: 8,       // must have at least this much to initiate sprint
        exhausted: false      // when true, cannot sprint until fully recovered
      };

      // Cache gradients for stamina bar (created once, reused)
      let staminaBarGradients = null;
      function initStaminaGradients() {
        if (staminaBarGradients) return; // Already initialized
        const barW = 220;
        const barX = 16.5;
        const normalGradient = ctx.createLinearGradient(barX, 0, barX + barW, 0);
        normalGradient.addColorStop(0, '#51ff8a'); // Original teal/green
        normalGradient.addColorStop(1, '#7cffb3'); // Original teal/green
        const exhaustedGradient = ctx.createLinearGradient(barX, 0, barX + barW, 0);
        exhaustedGradient.addColorStop(0, '#ff4d4f');
        exhaustedGradient.addColorStop(1, '#ff7875');
        staminaBarGradients = { normal: normalGradient, exhausted: exhaustedGradient };
      }

      // Money system
      const money = {
        amount: 0
      };

      // Shop system
      const shop = {
        open: false,
        items: [
          { name: "Simple shovel", tier: 1, price: 25 },
          { name: "Iron Shovel", tier: 2, price: 200 },
          { name: "Steel Shovel", tier: 3, price: 150 },
          { name: "Diamond Shovel", tier: 4, price: 500 },
          { name: "Legendary Shovel", tier: 5, price: 2000 }
        ]
      };

      // Shopkeeper NPC
      const shopkeeper = {
        x: world.width - 100,
        y: world.height - 100,
        radius: 20,
        dialogue: null, // Current dialogue text
        dialogueStage: 0, // 0 = none, 1 = "Hello", 2 = "What would you like?"
        dialogueTimer: 0
      };

      // Tutorial dialogue system
      const tutorial = {
        active: true, // Show tutorial dialogue when game starts
        dialogue: "Hey! Over here!"
      };

      // Old Guy NPC (positioned to the right of spawn)
      const oldGuy = {
        x: world.width / 2 + 150, // To the right of spawn
        y: world.height - 40, // Same Y as spawn
        radius: 20,
        dialogue: null // Current dialogue text
      };

      // Inventory system
      const inventory = {
        open: false,
        slots: Array(15).fill(null), // 15 inventory slots
        equipment: null // 1 equipment slot
      };

      const keys = Object.create(null);
      const keyJustPressed = Object.create(null); // Track keys that were just pressed this frame
      const pressed = (code) => keys[code] === true;

      window.addEventListener('keydown', (e) => {
        if (!keys[e.code]) {
          keyJustPressed[e.code] = true; // Mark as just pressed
        }
        keys[e.code] = true;
        // Prevent arrow keys from scrolling
        if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) {
          e.preventDefault();
        }
        // Toggle inventory with E
        if (e.code === 'KeyE') {
          e.preventDefault();
          // Don't allow opening inventory during minigame
          if (balancingMinigame.active || brushingMinigame.active) {
            return;
          }
          // Close shop if open
          if (shop.open) {
            shop.open = false;
            shopkeeper.dialogue = null;
            shopkeeper.dialogueStage = 0;
          }
          const wasOpen = inventory.open;
          inventory.open = !inventory.open;
          // Kill momentum when opening inventory
          if (!wasOpen && inventory.open) {
            player.vx = 0;
            player.vy = 0;
          }
        }
        
        // Interaction key Q
        if (e.code === 'KeyQ') {
          e.preventDefault();
          // Don't allow closing shop during minigame (minigame handles its own closing)
          if (balancingMinigame.active || brushingMinigame.active) {
            return;
          }
          // If shop is open, close it
          if (shop.open) {
            shop.open = false;
            shopkeeper.dialogue = null;
            shopkeeper.dialogueStage = 0;
            player.vx = 0;
            player.vy = 0;
          }
          // If dialogue is showing, close it
          else if (tutorial.active) {
            tutorial.active = false; // Close tutorial
            player.vx = 0;
            player.vy = 0;
          } else if (shopkeeper.dialogue || oldGuy.dialogue) {
            if (shopkeeper.dialogue) {
              advanceShopkeeperDialogue();
            } else if (oldGuy.dialogue) {
              oldGuy.dialogue = null; // Close old guy dialogue
              player.vx = 0;
              player.vy = 0;
            }
          } else {
            // Otherwise, try to interact
            handleInteraction();
          }
        }
        
        // Number keys for shop purchases
        if (shop.open) {
          const keyNum = parseInt(e.key);
          if (keyNum >= 1 && keyNum <= 5) {
            e.preventDefault();
            purchaseItem(keyNum - 1);
          }
        }
      }, { passive: false });

      window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
        keyJustPressed[e.code] = false;
      });

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function update(dtMs) {
        const dt = (dtMs || 16.67) / 1000; // seconds
        
        // Only update player movement if inventory is closed, shop is closed, dialogue is not showing, tutorial is not active, and minigame is not active
        if (!inventory.open && !shop.open && !shopkeeper.dialogue && !oldGuy.dialogue && !tutorial.active && !balancingMinigame.active && !brushingMinigame.active) {
          const wantsSprint = pressed('ShiftLeft') || pressed('ShiftRight');

          // Decouple boost from draining so the bar can reach 0
          const hasInput = (pressed('ArrowLeft') || pressed('KeyA') || pressed('ArrowRight') || pressed('KeyD') || pressed('ArrowUp') || pressed('KeyW') || pressed('ArrowDown') || pressed('KeyS'));
          const allowBoost = wantsSprint && !stamina.exhausted && stamina.current >= stamina.minToSprint;
          const shouldDrain = wantsSprint && !stamina.exhausted && hasInput && stamina.current > 0;

          const accel = allowBoost ? player.accel * player.sprintMultiplier : player.accel;
          const maxSpeed = allowBoost ? player.maxSpeed * player.sprintMultiplier : player.maxSpeed;

          // Input axes
          let ax = 0;
          let ay = 0;
          if (pressed('ArrowLeft') || pressed('KeyA')) ax -= accel;
          if (pressed('ArrowRight') || pressed('KeyD')) ax += accel;
          if (pressed('ArrowUp') || pressed('KeyW')) ay -= accel;
          if (pressed('ArrowDown') || pressed('KeyS')) ay += accel;

          player.vx += ax;
          player.vy += ay;

          // Apply friction only when no input along that axis to keep controls snappy
          if (ax === 0) player.vx *= player.friction;
          if (ay === 0) player.vy *= player.friction;

          // Cap speed
          const speed = Math.hypot(player.vx, player.vy);
          if (speed > maxSpeed) {
            const s = maxSpeed / speed;
            player.vx *= s;
            player.vy *= s;
          }

        player.x += player.vx;
        player.y += player.vy;

        resolveTreeCollisions();
        resolveShopkeeperCollision();
        resolveOldGuyCollision();
        
        // Update walking animation with speed based on sprinting
        const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
        if (isMoving) {
          // 75% slower when walking, 125% faster when sprinting
          const animationMultiplier = allowBoost ? 1.25 : 0.75;
          walkAnimationFrame += dt * 60 * walkAnimationSpeed * animationMultiplier; // Normalize to 60fps
        } else {
          walkAnimationFrame = 0; // Reset to idle when not moving
        }

          // Stamina update
          if (shouldDrain) {
            stamina.current -= stamina.drainPerSecond * dt;
          } else {
            stamina.current += stamina.regenPerSecond * dt;
          }
          stamina.current = clamp(stamina.current, 0, stamina.max);

          // Exhaustion rules: lock sprint when empty until fully refilled
          if (stamina.current <= 0.0001) {
            stamina.exhausted = true;
          } else if (stamina.current >= stamina.max - 0.0001) {
            stamina.exhausted = false;
          }

          // World bounds (keep player fully inside)
          const halfW = player.width / 2;
          const halfH = player.height / 2;
          player.x = clamp(player.x, halfW, world.width - halfW);
          player.y = clamp(player.y, halfH, world.height - halfH);
        }
        
        // Clear keyJustPressed at end of frame
        Object.keys(keyJustPressed).forEach(key => keyJustPressed[key] = false);

        // Camera follow (smoothly move camera toward player)
        const targetX = player.x;
        const targetY = player.y;
        camera.x += (targetX - camera.x) * camera.followLerp;
        camera.y += (targetY - camera.y) * camera.followLerp;

        // Clamp camera so it doesn't show outside world
        const halfViewW = canvas.width / 2;
        const halfViewH = canvas.height / 2;
        camera.x = clamp(camera.x, halfViewW, world.width - halfViewW);
        camera.y = clamp(camera.y, halfViewH, world.height - halfViewH);
        
        // Round camera to integer pixels to prevent sub-pixel jitter
        // This ensures the translate() call produces consistent pixel-aligned results
        camera.x = Math.round(camera.x);
        camera.y = Math.round(camera.y);

        updateBalancingMinigame(dtMs);
        updateBrushingMinigame(dtMs);
      }

      function drawGrid() {
        // Performance: Only draw grid if visible (optional - can be disabled entirely if still laggy)
        // For now, keeping it but optimizing viewport calculations
        const step = 50;
        ctx.save();
        ctx.lineWidth = 1;
        
        // Viewport culling: only draw grid lines visible on screen
        const halfCanvasW = canvas.width / 2;
        const halfCanvasH = canvas.height / 2;
        const viewLeft = camera.x - halfCanvasW;
        const viewTop = camera.y - halfCanvasH;
        const viewRight = camera.x + halfCanvasW;
        const viewBottom = camera.y + halfCanvasH;
        
        const startX = Math.max(0, Math.floor(viewLeft / step) * step);
        const endX = Math.min(world.width, Math.ceil(viewRight / step) * step);
        const startY = Math.max(0, Math.floor(viewTop / step) * step);
        const endY = Math.min(world.height, Math.ceil(viewBottom / step) * step);
        
        // Batch strokes by color to reduce state changes
        for (let x = startX; x <= endX; x += step) {
          ctx.strokeStyle = x % 200 === 0 ? 'rgba(139,111,71,0.18)' : 'rgba(139,111,71,0.08)'; // Brown grid
          ctx.beginPath();
          ctx.moveTo(x + 0.5, viewTop);
          ctx.lineTo(x + 0.5, viewBottom);
          ctx.stroke();
        }
        for (let y = startY; y <= endY; y += step) {
          ctx.strokeStyle = y % 200 === 0 ? 'rgba(139,111,71,0.18)' : 'rgba(139,111,71,0.08)'; // Brown grid
          ctx.beginPath();
          ctx.moveTo(viewLeft, y + 0.5);
          ctx.lineTo(viewRight, y + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawTiles() {
        ctx.save();
        // Viewport culling: only draw tiles visible on screen
        const viewLeft = camera.x - canvas.width / 2;
        const viewTop = camera.y - canvas.height / 2;
        const viewRight = camera.x + canvas.width / 2;
        const viewBottom = camera.y + canvas.height / 2;
        
        const startRow = Math.max(0, Math.floor(viewTop / tileSize) - 1);
        const endRow = Math.min(tileRows - 1, Math.ceil(viewBottom / tileSize) + 1);
        const startCol = Math.max(0, Math.floor(viewLeft / tileSize) - 1);
        const endCol = Math.min(tileCols - 1, Math.ceil(viewRight / tileSize) + 1);
        
        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            const tile = tileMap[row][col];
            if (tile && tile.canvas) {
              // Draw tiles at exact integer pixel positions to prevent seams
              const tileX = Math.floor(col * tileSize);
              const tileY = Math.floor(row * tileSize);
              ctx.drawImage(tile.canvas, tileX, tileY);
            }
          }
        }
        ctx.restore();
      }

      function resolveTreeCollisions() {
        const playerRadius = player.radius; // Use cached radius
        const maxCheckDistance = 150;
        const maxCheckDistanceSq = maxCheckDistance * maxCheckDistance;
        
        // Early exit optimization: use squared distances to avoid sqrt
        for (let i = 0; i < flora.trees.length; i++) {
          const tree = flora.trees[i];
          const dx = player.x - tree.x;
          const dy = player.y - tree.y;
          const distSq = dx * dx + dy * dy;
          
          // Quick distance check first (no sqrt needed)
          if (distSq > maxCheckDistanceSq) continue;
          
          const treeRadius = tree.colliderRadius;
          const minDist = treeRadius + playerRadius;
          const minDistSq = minDist * minDist;
          
          if (distSq < minDistSq && distSq > 0) { // Avoid division by zero
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }
      }

      function resolveShopkeeperCollision() {
        const playerRadius = player.radius; // Use cached radius
        const dx = player.x - shopkeeper.x;
        const dy = player.y - shopkeeper.y;
        const distSq = dx * dx + dy * dy;
        const minDist = shopkeeper.radius + playerRadius;
        const minDistSq = minDist * minDist;
        
        if (distSq < minDistSq && distSq > 0) {
          const dist = Math.sqrt(distSq);
          const overlap = minDist - dist;
          const invDist = 1 / dist; // Cache inverse distance
          player.x += dx * invDist * overlap;
          player.y += dy * invDist * overlap;
        }
      }

      function resolveOldGuyCollision() {
        const playerRadius = player.radius; // Use cached radius
        const dx = player.x - oldGuy.x;
        const dy = player.y - oldGuy.y;
        const distSq = dx * dx + dy * dy;
        const minDist = oldGuy.radius + playerRadius;
        const minDistSq = minDist * minDist;
        
        if (distSq < minDistSq && distSq > 0) {
          const dist = Math.sqrt(distSq);
          const overlap = minDist - dist;
          const invDist = 1 / dist; // Cache inverse distance
          player.x += dx * invDist * overlap;
          player.y += dy * invDist * overlap;
        }
      }

      function advanceShopkeeperDialogue() {
        if (shopkeeper.dialogueStage === 1) {
          // After "Hello", show "What would you like?"
          shopkeeper.dialogue = "What would you like?";
          shopkeeper.dialogueStage = 2;
        } else if (shopkeeper.dialogueStage === 2) {
          // After "What would you like?", open shop menu
          // Close inventory if open
          if (inventory.open) {
            inventory.open = false;
          }
          shop.open = true;
          shopkeeper.dialogue = null;
          shopkeeper.dialogueStage = 0;
        }
      }

      function handleInteraction() {
        // Don't interact if inventory is open
        if (inventory.open) {
          return;
        }
        
        // Don't start new dialogue if one is already showing
        if (shopkeeper.dialogue || oldGuy.dialogue) {
          return;
        }
        
        // Check if player is touching old guy (collision-based)
        const playerRadius = player.radius; // Use cached radius
        let dx = player.x - oldGuy.x;
        let dy = player.y - oldGuy.y;
        let distSq = dx * dx + dy * dy;
        let minDist = oldGuy.radius + playerRadius;
        let minDistSq = minDist * minDist;
        
        // Allow interaction when very close (within collision distance + small buffer)
        if (distSq <= minDistSq * 1.2) {
          oldGuy.dialogue = "Hi";
          // Kill momentum when opening dialogue
          player.vx = 0;
          player.vy = 0;
          return;
        }
        
        // Check if player is touching shopkeeper (collision-based)
        dx = player.x - shopkeeper.x;
        dy = player.y - shopkeeper.y;
        distSq = dx * dx + dy * dy;
        minDist = shopkeeper.radius + playerRadius;
        minDistSq = minDist * minDist;
        
        // Allow interaction when very close (within collision distance + small buffer)
        if (distSq <= minDistSq * 1.2) {
          shopkeeper.dialogue = "Hello";
          shopkeeper.dialogueStage = 1;
          shopkeeper.dialogueTimer = 0; // Don't auto-close, wait for Q press
          // Kill momentum when opening dialogue
          player.vx = 0;
          player.vy = 0;
          return;
        }
        
        // Check if player is on red X tile
        const col = Math.floor(player.x / tileSize);
        const row = Math.floor(player.y / tileSize);
        
        if (row >= 0 && row < tileRows && col >= 0 && col < tileCols) {
          const tile = tileMap[row][col];
          if (tile && tile.name === 'redX') {
            // 50% chance for each minigame
            if (Math.random() < 0.5) {
              // Start balancing minigame
              balancingMinigame.active = true;
              balancingMinigame.potAngle = 0;
              // Random initial direction: start teetering left or right
              const randomDirection = Math.random() < 0.5 ? -1 : 1;
              balancingMinigame.potAngularVelocity = 0.02 * randomDirection; // Start with slight movement in random direction
              balancingMinigame.timeRemaining = 15;
              balancingMinigame.stickX = canvas.width / 2;
              balancingMinigame.stickY = canvas.height / 2 + 60; // Lower the stick/pot position
              balancingMinigame.tileRow = row;
              balancingMinigame.tileCol = col;
            } else {
              // Start brushing minigame
              brushingMinigame.active = true;
              brushingMinigame.dirtLevel = 1.0; // Start fully dirty
              brushingMinigame.redness = 0; // Start with no redness
              brushingMinigame.timeHoldingSpace = 0; // Reset time counter
              brushingMinigame.redTriggerTime = 5.0 + Math.random() * 5.0; // Random time between 5-10 seconds
              brushingMinigame.tileRow = row;
              brushingMinigame.tileCol = col;
              brushingMinigame.brushX = canvas.width / 2;
              brushingMinigame.brushY = canvas.height / 2;
              brushingMinigame.completed = false;
              brushingMinigame.broken = false;
            }
            // Kill momentum and stop player movement
            player.vx = 0;
            player.vy = 0;
            return;
          }
        }
      }

      function updateBalancingMinigame(dtMs) {
        if (!balancingMinigame.active) return;
        
        const dt = dtMs / 1000; // Convert to seconds
        
        // Player input affects angular velocity
        const leftInput = pressed('ArrowLeft') || pressed('KeyA');
        const rightInput = pressed('ArrowRight') || pressed('KeyD');
        
        if (leftInput && !rightInput) {
          balancingMinigame.potAngularVelocity -= 0.2 * dt; // Lean left
        } else if (rightInput && !leftInput) {
          balancingMinigame.potAngularVelocity += 0.2 * dt; // Lean right
        }
        
        // Natural physics: pot wants to fall (very strong teetering force)
        const gravity = 0.6; // How fast it wants to fall (very strong - requires constant input)
        const damping = 0.985; // Less friction to allow stronger movement
        
        // Apply gravity based on current angle (very strong)
        balancingMinigame.potAngularVelocity += Math.sin(balancingMinigame.potAngle) * gravity * dt;
        
        // Add constant teetering force to make it much harder
        balancingMinigame.potAngularVelocity += Math.sin(balancingMinigame.potAngle * 2) * 0.18 * dt;
        
        // Add additional random-like teetering force
        balancingMinigame.potAngularVelocity += Math.sin(balancingMinigame.potAngle * 3 + Date.now() * 0.001) * 0.12 * dt;
        
        // Apply damping
        balancingMinigame.potAngularVelocity *= Math.pow(damping, dt * 60); // Normalize to 60fps
        
        // Update angle
        balancingMinigame.potAngle += balancingMinigame.potAngularVelocity * dt;
        
        // Check if pot fell off (angle too extreme - make it easier to lose)
        const maxAngle = Math.PI / 4.5; // About 40 degrees (easier to lose)
        if (Math.abs(balancingMinigame.potAngle) > maxAngle && !balancingMinigame.breaking) {
          // Start breaking animation
          balancingMinigame.breaking = true;
          balancingMinigame.breakTimer = 0.5; // 0.5 seconds of breaking animation
          
          // Create pot pieces flying off
          const potSize = 100;
          const stickX = balancingMinigame.stickX;
          const stickTipY = balancingMinigame.stickY - 25;
          const potContactY = stickTipY;
          const potCenterX = stickX;
          const potCenterY = potContactY - potSize / 2;
          
          // Create 8-12 pieces
          const numPieces = 10;
          balancingMinigame.pieces = [];
          for (let i = 0; i < numPieces; i++) {
            const angle = (Math.PI * 2 * i) / numPieces + balancingMinigame.potAngle;
            const speed = 2 + Math.random() * 3;
            balancingMinigame.pieces.push({
              x: potCenterX,
              y: potCenterY,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed - 1, // Slight upward bias
              rotation: Math.random() * Math.PI * 2,
              rotationSpeed: (Math.random() - 0.5) * 0.3,
              size: 8 + Math.random() * 12,
              opacity: 1.0
            });
          }
        }
        
        // Update breaking animation
        if (balancingMinigame.breaking) {
          balancingMinigame.breakTimer -= dt;
          
          // Update pieces
          for (let i = 0; i < balancingMinigame.pieces.length; i++) {
            const piece = balancingMinigame.pieces[i];
            piece.x += piece.vx * dt * 60;
            piece.y += piece.vy * dt * 60;
            piece.vy += 0.5 * dt * 60; // Gravity
            piece.rotation += piece.rotationSpeed * dt * 60;
            piece.opacity -= dt * 2; // Fade out
          }
          
          // End minigame after breaking animation
          if (balancingMinigame.breakTimer <= 0) {
            // Failed - give base reward with shovel multiplier
            let multiplier = 1.0;
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1) multiplier = 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2) multiplier = 2.0; // Iron shovel
            }
            money.amount += Math.round(balancingMinigame.baseReward * multiplier);
            const grassDef = tileDefinitions.find(def => def.name === 'grass');
            if (grassDef && balancingMinigame.tileRow !== null && balancingMinigame.tileCol !== null) {
              tileMap[balancingMinigame.tileRow][balancingMinigame.tileCol] = {
                name: grassDef.name,
                canvas: createTileCanvas(grassDef.draw)
              };
            }
            balancingMinigame.active = false;
            balancingMinigame.breaking = false;
            balancingMinigame.pieces = [];
            return;
          }
        }
        
        // Update timer
        balancingMinigame.timeRemaining -= dt;
        
        // Check if succeeded (15 seconds passed)
        if (balancingMinigame.timeRemaining <= 0) {
          // Success - give 3x reward with shovel multiplier
          let multiplier = 3.0; // Base success multiplier (3x)
          if (inventory.equipment) {
            if (inventory.equipment.tier === 1) multiplier = 4.5; // Simple shovel: 1.5x * 3 = 4.5x
            else if (inventory.equipment.tier === 2) multiplier = 6.0; // Iron shovel: 2x * 3 = 6x
          }
          money.amount += Math.round(balancingMinigame.baseReward * multiplier);
          const grassDef = tileDefinitions.find(def => def.name === 'grass');
          if (grassDef && balancingMinigame.tileRow !== null && balancingMinigame.tileCol !== null) {
            tileMap[balancingMinigame.tileRow][balancingMinigame.tileCol] = {
              name: grassDef.name,
              canvas: createTileCanvas(grassDef.draw)
            };
          }
          balancingMinigame.active = false;
        }
      }

      function updateBrushingMinigame(dtMs) {
        if (!brushingMinigame.active) return;
        
        const dt = dtMs / 1000; // Convert to seconds
        const spacePressed = pressed('Space');
        
        if (spacePressed) {
          // Track time holding space
          brushingMinigame.timeHoldingSpace += dt;
          
          // Brushing reduces dirt level (makes it cleaner)
          brushingMinigame.dirtLevel -= 0.2 * dt;
          brushingMinigame.dirtLevel = Math.max(0, brushingMinigame.dirtLevel);
          
          // After at least 5 seconds, dirt is cleaned
          if (brushingMinigame.timeHoldingSpace >= 5.0) {
            // Dirt is now clean
            brushingMinigame.dirtLevel = 0;
            
            // After the random trigger time (5-10 seconds), dirt turns red instantly
            if (brushingMinigame.timeHoldingSpace >= brushingMinigame.redTriggerTime && brushingMinigame.redness === 0) {
              brushingMinigame.redness = 1.0; // Instantly turn red
            }
            
            // If dirt is red and still holding space, you lose
            if (brushingMinigame.redness >= 1.0 && !brushingMinigame.broken) {
              brushingMinigame.broken = true;
            }
          }
        } else {
          // When not brushing, reset time counter
          brushingMinigame.timeHoldingSpace = 0;
          
          // If dirt is clean and redness is present, release means success
          if (brushingMinigame.dirtLevel <= 0 && brushingMinigame.redness > 0 && !brushingMinigame.completed && !brushingMinigame.broken) {
            brushingMinigame.completed = true;
          }
          
          // Reset redness when not brushing (dirt returns to normal)
          brushingMinigame.redness = 0;
          
          // Dirt slowly returns if not fully cleaned
          if (brushingMinigame.dirtLevel < 1.0 && !brushingMinigame.completed && !brushingMinigame.broken) {
            brushingMinigame.dirtLevel += 0.15 * dt;
            brushingMinigame.dirtLevel = Math.min(1.0, brushingMinigame.dirtLevel);
          }
        }
        
        // End minigame if completed or broken
        if (brushingMinigame.completed || brushingMinigame.broken) {
          // Give reward
          let multiplier = brushingMinigame.completed ? 3.0 : 1.0; // 3x for success, 1x for failure
          if (inventory.equipment) {
            if (inventory.equipment.tier === 1) multiplier *= 1.5; // Simple shovel
            else if (inventory.equipment.tier === 2) multiplier *= 2.0; // Iron shovel
          }
          money.amount += Math.round(brushingMinigame.baseReward * multiplier);
          
          // Convert tile to grass
          const grassDef = tileDefinitions.find(def => def.name === 'grass');
          if (grassDef && brushingMinigame.tileRow !== null && brushingMinigame.tileCol !== null) {
            tileMap[brushingMinigame.tileRow][brushingMinigame.tileCol] = {
              name: grassDef.name,
              canvas: createTileCanvas(grassDef.draw)
            };
          }
          
          brushingMinigame.active = false;
        }
      }

      const treeSprite = (() => {
        const canvasEl = document.createElement('canvas');
        canvasEl.width = tileCell * 8;
        canvasEl.height = tileCell * 8;
        const c = canvasEl.getContext('2d');
        const treeLayout = [
          { x: 1, y: 0, color: '#0a3c0f' }, { x: 2, y: 0, color: '#0a3c0f' }, { x: 3, y: 0, color: '#0a3c0f' }, { x: 4, y: 0, color: '#0a3c0f' }, { x: 5, y: 0, color: '#0a3c0f' },
          { x: 0, y: 1, color: '#0a3c0f' }, { x: 1, y: 1, color: '#075018' }, { x: 2, y: 1, color: '#0a5f1f' }, { x: 3, y: 1, color: '#0a5f1f' }, { x: 4, y: 1, color: '#075018' }, { x: 5, y: 1, color: '#075018' }, { x: 6, y: 1, color: '#0a3c0f' },
          { x: 0, y: 2, color: '#0a3c0f' }, { x: 1, y: 2, color: '#0a5f1f' }, { x: 2, y: 2, color: '#0c6b24' }, { x: 3, y: 2, color: '#0c6b24' }, { x: 4, y: 2, color: '#0a5f1f' }, { x: 5, y: 2, color: '#075018' }, { x: 6, y: 2, color: '#0a3c0f' },
          { x: 0, y: 3, color: '#0a3c0f' }, { x: 1, y: 3, color: '#0a5f1f' }, { x: 2, y: 3, color: '#0c6b24' }, { x: 3, y: 3, color: '#0c6b24' }, { x: 4, y: 3, color: '#0a5f1f' }, { x: 5, y: 3, color: '#075018' }, { x: 6, y: 3, color: '#0a3c0f' },
          { x: 0, y: 4, color: '#0a3c0f' }, { x: 1, y: 4, color: '#0a5f1f' }, { x: 2, y: 4, color: '#0c6b24' }, { x: 3, y: 4, color: '#0c6b24' }, { x: 4, y: 4, color: '#0a5f1f' }, { x: 5, y: 4, color: '#075018' }, { x: 6, y: 4, color: '#0a3c0f' },
          { x: 1, y: 5, color: '#0a3c0f' }, { x: 2, y: 5, color: '#0a5f1f' }, { x: 3, y: 5, color: '#0a5f1f' }, { x: 4, y: 5, color: '#075018' }, { x: 5, y: 5, color: '#0a3c0f' },
          { x: 2, y: 6, color: '#0a3c0f' }, { x: 3, y: 6, color: '#063310' }, { x: 4, y: 6, color: '#0a3c0f' },
          { x: 2, y: 7, color: '#0a3c0f' }, { x: 3, y: 7, color: '#063310' }, { x: 4, y: 7, color: '#0a3c0f' }
        ];
        treeLayout.forEach(({ x, y, color }) => fillCell(c, x, y, color));
        return canvasEl;
      })();

      // Load shovel sprites from PNG images
      const shovelSprites = {};
      function loadShovelSprite(tier, filename) {
        const sprite = new Image();
        sprite.src = filename;
        sprite.imageSmoothingEnabled = false; // Pixelated rendering
        shovelSprites[tier] = sprite;
        return sprite;
      }
      
      // Load shovel sprites for each tier
      loadShovelSprite(1, 'shovel.png'); // Simple shovel
      loadShovelSprite(2, 'iron-shovel.png'); // Iron Shovel
      // Add more shovel sprites as needed for other tiers

      function drawFlora() {
        // Viewport culling: only draw trees visible on screen
        const halfCanvasW = canvas.width / 2;
        const halfCanvasH = canvas.height / 2;
        const viewLeft = camera.x - halfCanvasW;
        const viewTop = camera.y - halfCanvasH;
        const viewRight = camera.x + halfCanvasW;
        const viewBottom = camera.y + halfCanvasH;
        const padding = 120; // Extra padding to account for tree size
        const spriteHalfW = treeSprite.width / 2;
        const spriteHalfH = treeSprite.height / 2;
        const tileCell8 = tileCell * 8;

        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Set once outside loop

        for (let i = 0; i < flora.trees.length; i++) {
          const tree = flora.trees[i];
          const halfSize = tree.size / 2;
          
          // Skip trees outside viewport (optimized bounds check)
          if (tree.x + halfSize < viewLeft - padding ||
              tree.x - halfSize > viewRight + padding ||
              tree.y + halfSize < viewTop - padding ||
              tree.y - halfSize > viewBottom + padding) {
            continue;
          }

          ctx.save();
          ctx.translate(Math.round(tree.x) + 0.5, Math.round(tree.y) + 0.5);
          ctx.rotate(tree.rotation);

          // Draw shadow
          const shadowRadius = tree.size * 0.45;
          ctx.beginPath();
          ctx.ellipse(0, tree.size * 0.4, shadowRadius, tree.size * 0.2, 0, 0, Math.PI * 2);
          ctx.fill();

          // Draw tree
          const scale = tree.size / tileCell8;
          ctx.scale(scale, scale);
          ctx.drawImage(treeSprite, -spriteHalfW, -spriteHalfH);
          ctx.restore();
        }

        ctx.restore();
      }

      function drawShopkeeper() {
        ctx.save();
        
        // Draw shopkeeper sprite
        if (shopkeeperSprite.complete && shopkeeperSprite.naturalWidth > 0) {
          const spriteWidth = 43; // Match player size
          const spriteHeight = 43;
          
          // Shopkeeper shadow
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
          ctx.ellipse(shopkeeper.x, shopkeeper.y + spriteHeight * 0.35, spriteWidth * 0.5, spriteHeight * 0.22, 0, 0, Math.PI * 2);
          ctx.fill();
          
          const px = Math.round(shopkeeper.x - spriteWidth / 2);
          const py = Math.round(shopkeeper.y - spriteHeight / 2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(shopkeeperSprite, px, py, spriteWidth, spriteHeight);
        } else {
          // Fallback while loading
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
          ctx.ellipse(shopkeeper.x, shopkeeper.y + shopkeeper.radius * 0.4, shopkeeper.radius * 0.6, shopkeeper.radius * 0.2, 0, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = '#ffd700'; // Yellow/gold color
          ctx.strokeStyle = '#ffaa00';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(shopkeeper.x, shopkeeper.y, shopkeeper.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
        
        ctx.restore();
      }

      function drawOldGuy() {
        ctx.save();
        
        // Draw old guy sprite
        if (oldGuySprite.complete && oldGuySprite.naturalWidth > 0) {
          // Scale to match player size (43x43, 10% bigger than original 39x39)
          const spriteWidth = 43;
          const spriteHeight = 43;
          
          // Old guy shadow
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
          ctx.ellipse(oldGuy.x, oldGuy.y + spriteHeight * 0.35, spriteWidth * 0.5, spriteHeight * 0.22, 0, 0, Math.PI * 2);
          ctx.fill();
          
          const px = Math.round(oldGuy.x - spriteWidth / 2);
          const py = Math.round(oldGuy.y - spriteHeight / 2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(oldGuySprite, px, py, spriteWidth, spriteHeight);
        }
        
        ctx.restore();
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // World space: translate so that camera is centered
        ctx.save();
        ctx.translate(Math.round(canvas.width / 2 - camera.x), Math.round(canvas.height / 2 - camera.y));

        drawTiles();
        drawGrid();
        drawFlora();
        
        // Shopkeeper NPC
        drawShopkeeper();
        
        // Old Guy NPC
        drawOldGuy();

        // Player shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.ellipse(player.x, player.y + player.height * 0.35, player.width * 0.5, player.height * 0.22, 0, 0, Math.PI * 2);
        ctx.fill();

        // Player sprite - use back sprite when moving upward, walking sprites when moving
        const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
        const isMovingUp = player.vy < -0.1; // Small threshold to prevent flickering
        let currentSprite;
        
        if (isMovingUp) {
          // Alternate between back walk sprites when moving up
          if (isMoving) {
            const walkFrame = Math.floor(walkAnimationFrame) % 2;
            currentSprite = walkFrame === 0 ? playerSpriteBackWalk1 : playerSpriteBackWalk2;
          } else {
            // Use idle back sprite when not moving but facing up
            currentSprite = playerSpriteBack;
          }
        } else if (isMoving) {
          // Alternate between walk sprites when moving
          const walkFrame = Math.floor(walkAnimationFrame) % 2;
          currentSprite = walkFrame === 0 ? playerSpriteWalk1 : playerSpriteWalk2;
        } else {
          // Use idle sprite when not moving
          currentSprite = playerSpriteIdle;
        }
        
        if (currentSprite.complete && currentSprite.naturalWidth > 0) {
          const px = Math.round(player.x - player.width / 2);
          const py = Math.round(player.y - player.height / 2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(currentSprite, px, py, player.width, player.height);
        } else {
          // Fallback while loading
          ctx.fillStyle = player.color;
          ctx.strokeStyle = player.outline;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(Math.round(player.x - player.width / 2) + 0.5, Math.round(player.y - player.height / 2) + 0.5, player.width, player.height);
          ctx.fill();
          ctx.stroke();
        }

        // Direction indicator - small black arrow triangle
        const dirX = player.vx;
        const dirY = player.vy;
        const speedSq = dirX * dirX + dirY * dirY;
        if (speedSq > 0.04) { // 0.2^2 = 0.04
          const speed = Math.sqrt(speedSq);
          const nx = dirX / speed;
          const ny = dirY / speed;
          
          // Position arrow outside player bounds (player radius + offset)
          const playerRadius = Math.max(player.width, player.height) / 2;
          const arrowDistance = playerRadius + 12; // Distance from player center
          const arrowX = player.x + nx * arrowDistance;
          const arrowY = player.y + ny * arrowDistance;
          
          // Draw small black triangle arrow
          const arrowSize = 6; // Size of the arrow
          const angle = Math.atan2(ny, nx);
          
          ctx.save();
          ctx.fillStyle = '#000000'; // Black arrow
          ctx.translate(arrowX, arrowY);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(arrowSize, 0); // Tip of arrow
          ctx.lineTo(-arrowSize * 0.6, -arrowSize * 0.6); // Bottom left
          ctx.lineTo(-arrowSize * 0.6, arrowSize * 0.6); // Bottom right
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }

        // Optional: draw world bounds
        ctx.strokeStyle = 'rgba(139,111,71,0.25)'; // Brown world bounds
        ctx.lineWidth = 2;
        ctx.strokeRect(0.5, 0.5, world.width - 1, world.height - 1);

        // End world space
        ctx.restore();

        // UI: Stamina bar (top-left, screen space)
        const bar = {
          x: 16.5,
          y: 14.5,
          w: 220,
          h: 16
        };
        // Background
        ctx.strokeStyle = 'rgba(139,111,71,0.35)'; // Brown UI borders
        ctx.fillStyle = 'rgba(10,20,14,0.8)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(bar.x, bar.y, bar.w, bar.h);
        ctx.fill();
        ctx.stroke();

        // Fill (use cached gradients)
        if (!staminaBarGradients) initStaminaGradients();
        const ratio = stamina.current / stamina.max;
        const fillWidth = Math.round(bar.w * ratio);
        ctx.fillStyle = stamina.exhausted ? staminaBarGradients.exhausted : staminaBarGradients.normal;
        ctx.beginPath();
        ctx.rect(bar.x + 1, bar.y + 1, Math.max(0, fillWidth - 2), bar.h - 2);
        ctx.fill();

        // UI: Money counter (top-right, screen space)
        ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        const moneyText = `$${money.amount}`;
        const moneyTextWidth = ctx.measureText(moneyText).width;
        const moneyX = canvas.width - 16.5;
        const moneyY = 14.5;
        
        // Money border sprite (centered on money text)
        if (moneyBorderSprite.complete && moneyBorderSprite.naturalWidth > 0) {
          // Calculate size to fully enclose the text with generous padding
          const borderPadding = 50; // Increased padding for better centering
          const borderWidth = moneyTextWidth + borderPadding;
          const borderHeight = 40; // Increased height to better center around text
          
          // Center the border on the money text
          // moneyX is the right edge of the text, so center is at moneyX - moneyTextWidth/2
          const textCenterX = moneyX - moneyTextWidth / 2;
          const borderX = textCenterX - borderWidth / 2 - 4; // Moved left by 4 pixels
          const textCenterY = moneyY + 8; // Approximate center of text vertically
          const borderY = textCenterY - borderHeight / 2 + 6; // Moved down by 6 pixels (was 4)
          
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(moneyBorderSprite, borderX, borderY, borderWidth, borderHeight);
        } else {
          // Fallback while loading
          ctx.fillStyle = 'rgba(10,20,14,0.8)';
          ctx.strokeStyle = 'rgba(139,111,71,0.35)';
          ctx.lineWidth = 1;
          const moneyPadding = 8;
          const moneyHeight = 18;
          ctx.beginPath();
          ctx.rect(moneyX - moneyTextWidth - moneyPadding, moneyY, moneyTextWidth + moneyPadding, moneyHeight);
          ctx.fill();
          ctx.stroke();
        }
        
        // Money text (drawn on top of border, centered vertically)
        ctx.fillStyle = '#ffffff';
        ctx.fillText(moneyText, moneyX, moneyY + 8);

        // Draw balancing minigame
        if (balancingMinigame.active) {
          ctx.save();
          
          // Background overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Minigame panel (bigger to fit text)
          const panelWidth = 450;
          const panelHeight = 350;
          const panelX = (canvas.width - panelWidth) / 2;
          const panelY = (canvas.height - panelHeight) / 2;
          
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
          
          ctx.strokeStyle = '#8b6f47'; // Brown menu borders
          ctx.lineWidth = 3;
          ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
          
          // Draw vertical stick with tip at top (shorter stick)
          const stickX = balancingMinigame.stickX;
          const stickBaseY = balancingMinigame.stickY + 25; // Bottom of stick (even shorter)
          const stickTipY = balancingMinigame.stickY - 25; // Top of stick (tip) (even shorter)
          const stickWidth = 6;
          
          // Draw stick body (vertical line)
          ctx.strokeStyle = '#8b4513'; // Brown
          ctx.lineWidth = stickWidth;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(stickX, stickBaseY);
          ctx.lineTo(stickX, stickTipY);
          ctx.stroke();
          
          // Draw stick tip (small point at top)
          ctx.fillStyle = '#654321'; // Darker brown for tip
          ctx.beginPath();
          ctx.arc(stickX, stickTipY, 3, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw pot balancing on tip of stick (larger pot) - only if not breaking
          const potSize = 100; // Increased from 80 to 100 for better visibility
          const potContactY = stickTipY; // Pot contacts stick at tip
          
          if (!balancingMinigame.breaking) {
            ctx.save();
            // Translate to the contact point (where pot touches stick tip)
            ctx.translate(stickX, potContactY);
            // Rotate around the contact point
            ctx.rotate(balancingMinigame.potAngle);
            
            // Draw pot sprite from PNG, offset upward so bottom is at rotation point
            if (potSprite.complete && potSprite.naturalWidth > 0) {
              ctx.imageSmoothingEnabled = false;
              // Draw with bottom at origin (0, 0), so pot extends upward
              ctx.drawImage(potSprite, -potSize / 2, -potSize, potSize, potSize);
            } else {
              // Placeholder while loading
              ctx.fillStyle = '#8b4513';
              ctx.beginPath();
              ctx.ellipse(0, -potSize / 2, potSize / 2, potSize / 2.5, 0, 0, Math.PI * 2);
              ctx.fill();
            }
            
            ctx.restore();
          }
          
          // Draw breaking pot pieces
          if (balancingMinigame.breaking && balancingMinigame.pieces.length > 0) {
            for (let i = 0; i < balancingMinigame.pieces.length; i++) {
              const piece = balancingMinigame.pieces[i];
              if (piece.opacity > 0) {
                ctx.save();
                ctx.globalAlpha = piece.opacity;
                ctx.translate(piece.x, piece.y);
                ctx.rotate(piece.rotation);
                
                // Draw pot piece (brown fragment)
                ctx.fillStyle = '#8b4513';
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.rect(-piece.size / 2, -piece.size / 2, piece.size, piece.size);
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
              }
            }
          }
          
          // Timer text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 72px ui-monospace, Menlo, Consolas, monospace'; // 3x bigger (24 * 3)
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          const timeText = Math.ceil(balancingMinigame.timeRemaining).toString();
          ctx.fillText(`Time: ${timeText}s`, canvas.width / 2, panelY + 20);
          
          // Instructions
          ctx.fillStyle = '#ffffff';
          ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
          ctx.textBaseline = 'bottom';
          ctx.fillText('Use arrow keys to keep the pot from tipping!', canvas.width / 2, panelY + panelHeight - 20);
          
          ctx.restore();
        }

        // Draw brushing minigame
        if (brushingMinigame.active) {
          ctx.save();
          
          // Background overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Minigame panel
          const panelWidth = 450;
          const panelHeight = 350;
          const panelX = (canvas.width - panelWidth) / 2;
          const panelY = (canvas.height - panelHeight) / 2;
          
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
          
          ctx.strokeStyle = '#8b6f47'; // Brown menu borders
          ctx.lineWidth = 3;
          ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
          
          // Draw dirt sprite (in center, with red tint based on redness)
          const dirtSize = 150;
          const dirtX = canvas.width / 2;
          const dirtY = canvas.height / 2;
          
          if (dirtSprite.complete && dirtSprite.naturalWidth > 0) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            // Draw dirt sprite - stays fully visible and same color until it turns red
            ctx.globalAlpha = 1.0; // Always full opacity, don't fade
            ctx.drawImage(dirtSprite, dirtX - dirtSize / 2, dirtY - dirtSize / 2, dirtSize, dirtSize);
            
            // Add red overlay only when redness is at maximum (dirt turns red instantly)
            const redness = brushingMinigame.redness;
            if (redness >= 1.0) {
              ctx.globalAlpha = 0.7; // Red tint intensity
              ctx.fillStyle = '#ff0000';
              ctx.fillRect(dirtX - dirtSize / 2, dirtY - dirtSize / 2, dirtSize, dirtSize);
            }
            
            ctx.restore();
          } else {
            // Fallback while loading - stays same color until red
            const redness = brushingMinigame.redness;
            if (redness >= 1.0) {
              ctx.fillStyle = '#ff0000'; // Red when broken
            } else {
              ctx.fillStyle = '#8b4513'; // Brown (stays same color)
            }
            ctx.beginPath();
            ctx.rect(dirtX - dirtSize / 2, dirtY - dirtSize / 2, dirtSize, dirtSize);
            ctx.fill();
          }
          
          // Draw brush sprite (follows mouse or centered)
          const brushSize = 80;
          const brushX = brushingMinigame.brushX;
          const brushY = brushingMinigame.brushY;
          
          if (brushSprite.complete && brushSprite.naturalWidth > 0) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(brushSprite, brushX - brushSize / 2, brushY - brushSize / 2, brushSize, brushSize);
            ctx.restore();
          } else {
            // Fallback while loading
            ctx.fillStyle = '#8b7355';
            ctx.beginPath();
            ctx.rect(brushX - brushSize / 2, brushY - brushSize / 2, brushSize, brushSize);
            ctx.fill();
          }
          
          // Instructions
          ctx.fillStyle = '#ffffff';
          ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText('Hold SPACE to brush the dirt clean!', canvas.width / 2, panelY + 20);
          
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textBaseline = 'bottom';
          ctx.fillText('After 5 seconds, release SPACE before it turns red!', canvas.width / 2, panelY + panelHeight - 20);
          
          ctx.restore();
        }

        // Draw inventory menu
        if (inventory.open) {
          drawInventory();
        }

        // Draw shop menu
        if (shop.open) {
          drawShopMenu();
        }

        // Draw dialogue textbox (RPG style at top of screen)
        if (tutorial.active || shopkeeper.dialogue || oldGuy.dialogue) {
          drawDialogueBox();
        }
      }

      function drawShopMenu() {
        ctx.save();
        
        const shopWidth = 400;
        const itemHeight = 50;
        const itemPadding = 10;
        const titleHeight = 40;
        const instructionsHeight = 25;
        const topPadding = 15;
        const bottomPadding = 15;
        const shopHeight = titleHeight + topPadding + (shop.items.length * itemHeight) + ((shop.items.length - 1) * itemPadding) + bottomPadding + instructionsHeight;
        const shopX = Math.round(canvas.width / 2 - shopWidth / 2) + 0.5;
        const shopY = Math.round(canvas.height / 2 - shopHeight / 2) + 0.5;
        
        // Background overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Shop panel background
        ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
        ctx.beginPath();
        ctx.rect(shopX, shopY, shopWidth, shopHeight);
        ctx.fill();
        
        // Shop panel border
        ctx.strokeStyle = '#8b6f47'; // Brown borders
        ctx.lineWidth = 3;
        ctx.strokeRect(shopX, shopY, shopWidth, shopHeight);
        
        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Shop', shopX + shopWidth / 2, shopY + 12);
        
        // Draw shop items
        const startY = shopY + titleHeight + topPadding;
        for (let i = 0; i < shop.items.length; i++) {
          const item = shop.items[i];
          const itemY = startY + i * (itemHeight + itemPadding);
          const itemRectX = shopX + 20;
          const itemRectY = itemY;
          const itemRectW = shopWidth - 40;
          const itemRectH = itemHeight;
          
          // Check if player already owns this tier
          const alreadyOwned = inventory.equipment && inventory.equipment.tier === item.tier;
          
          // Item background
          ctx.fillStyle = alreadyOwned ? 'rgba(15, 30, 20, 0.6)' : 'rgba(20, 40, 30, 0.8)';
          ctx.strokeStyle = '#6b4e37'; // Darker brown borders
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(itemRectX, itemRectY, itemRectW, itemRectH);
          ctx.fill();
          ctx.stroke();
          
          // Item name
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(item.name, itemRectX + 10, itemRectY + 6);
          
          // Item tier
          ctx.fillStyle = '#ffffff';
          ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText(`Tier ${item.tier}`, itemRectX + 10, itemRectY + 22);
          
          if (alreadyOwned) {
            // Show "Sold" for already owned items
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText('SOLD', itemRectX + itemRectW - 10, itemRectY + itemRectH / 2);
          } else {
            // Price
            const priceText = `$${item.price}`;
            const canAfford = money.amount >= item.price;
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'right';
            ctx.fillText(priceText, itemRectX + itemRectW - 10, itemRectY + 14);
            
            // Buy button indicator
            if (canAfford) {
              ctx.fillStyle = '#ffffff';
              ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'right';
              ctx.fillText('Press ' + (i + 1) + ' to buy', itemRectX + itemRectW - 10, itemRectY + 32);
            } else {
              ctx.fillStyle = '#ffffff';
              ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'right';
              ctx.fillText('Cannot afford', itemRectX + itemRectW - 10, itemRectY + 32);
            }
          }
        }
        
        // Instructions
        ctx.fillStyle = '#ffffff';
        ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('Press Q to close | Press 1-5 to buy', shopX + shopWidth / 2, shopY + shopHeight - 10);
        
        ctx.restore();
      }

      function purchaseItem(itemIndex) {
        if (itemIndex < 0 || itemIndex >= shop.items.length) return;
        
        const item = shop.items[itemIndex];
        
        // Check if player already owns a shovel of this tier
        if (inventory.equipment && inventory.equipment.tier === item.tier) {
          return; // Already own this type of shovel
        }
        
        if (money.amount >= item.price) {
          money.amount -= item.price;
          // Get the appropriate sprite for this shovel tier
          let sprite = shovelSprites[item.tier];
          // If sprite not loaded yet, load it now
          if (!sprite) {
            const spriteName = item.name.toLowerCase().replace(/\s+/g, '-') + '.png';
            sprite = loadShovelSprite(item.tier, spriteName);
          }
          // Add shovel to equipment slot
          inventory.equipment = {
            name: item.name,
            tier: item.tier,
            sprite: sprite
          };
        }
      }

      function drawDialogueBox() {
        ctx.save();
        
        const boxHeight = 100;
        const boxY = 0; // Top of screen instead of bottom
        const boxPadding = 20;
        const boxMargin = 20;
        const boxX = boxMargin;
        const boxWidth = canvas.width - boxMargin * 2;
        
        // Background with slight transparency
        ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
        ctx.beginPath();
        ctx.rect(boxX, boxY, boxWidth, boxHeight);
        ctx.fill();
        
        // Border
        ctx.strokeStyle = '#8b6f47'; // Brown borders
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Inner border for depth
        ctx.strokeStyle = '#6b4e37'; // Darker brown
        ctx.lineWidth = 1;
        ctx.strokeRect(boxX + 2, boxY + 2, boxWidth - 4, boxHeight - 4);
        
        // Dialogue text
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        // Word wrap the dialogue text
        const maxWidth = boxWidth - boxPadding * 2;
        const dialogueText = tutorial.active ? tutorial.dialogue : (shopkeeper.dialogue || oldGuy.dialogue || '');
        const words = dialogueText.split(' ');
        let line = '';
        let y = boxY + boxPadding;
        
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + ' ';
          const metrics = ctx.measureText(testLine);
          const testWidth = metrics.width;
          
          if (testWidth > maxWidth && i > 0) {
            ctx.fillText(line, boxX + boxPadding, y);
            line = words[i] + ' ';
            y += 22; // Line height
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, boxX + boxPadding, y);
        
        // Draw help text in bottom right of textbox (only for tutorial)
        if (tutorial.active) {
          const helpText = "Press Q to progress textboxes and talk to people like your uncle";
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'bottom';
          // Move further down and to the right (reduce padding more)
          ctx.fillText(helpText, boxX + boxWidth - 10, boxY + boxHeight - 10);
        }
        
        ctx.restore();
      }

      function drawInventory() {
        ctx.save();
        
        // Artifacts panel dimensions
        const slotSize = 48;
        const slotSpacing = 4;
        const slotsPerRow = 5;
        const numRows = 3;
        const panelPadding = 24;
        const equipmentSlotSize = 64;
        const titleHeight = 40;
        const equipmentLabelHeight = 16;
        const equipmentSpacing = 20;
        const instructionsHeight = 30;
        
        // Calculate proper dimensions to fit all slots
        const slotsAreaWidth = slotsPerRow * slotSize + (slotsPerRow - 1) * slotSpacing;
        const slotsAreaHeight = numRows * slotSize + (numRows - 1) * slotSpacing;
        const inventoryWidth = slotsAreaWidth + panelPadding * 2;
        const inventoryHeight = titleHeight + equipmentSlotSize + equipmentLabelHeight + equipmentSpacing + slotsAreaHeight + panelPadding * 2 + instructionsHeight;
        
        const panelX = Math.round(canvas.width / 2 - inventoryWidth / 2) + 0.5;
        const panelY = Math.round(canvas.height / 2 - inventoryHeight / 2) + 0.5;
        
        // Background with semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Main panel background
        ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
        ctx.beginPath();
        ctx.rect(panelX, panelY, inventoryWidth, inventoryHeight);
        ctx.fill();
        
        // Panel border
        ctx.strokeStyle = '#8b6f47'; // Brown borders
        ctx.lineWidth = 2;
        ctx.strokeRect(panelX, panelY, inventoryWidth, inventoryHeight);
        
        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Artifacts', panelX + inventoryWidth / 2, panelY + 12);
        
        // Equipment slot (at the top, centered)
        const equipmentX = panelX + inventoryWidth / 2 - equipmentSlotSize / 2;
        const equipmentY = panelY + titleHeight;
        ctx.fillStyle = 'rgba(20, 40, 30, 0.8)';
        ctx.strokeStyle = '#6b4e37'; // Darker brown
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.rect(equipmentX, equipmentY, equipmentSlotSize, equipmentSlotSize);
        ctx.fill();
        ctx.stroke();
        
        // Draw equipment sprite if equipped
        if (inventory.equipment && inventory.equipment.sprite) {
          const sprite = inventory.equipment.sprite;
          // Only draw if image is loaded
          if (sprite.complete && sprite.naturalWidth > 0) {
            const spriteSize = equipmentSlotSize - 8; // Leave some padding
            const spriteX = equipmentX + (equipmentSlotSize - spriteSize) / 2;
            const spriteY = equipmentY + (equipmentSlotSize - spriteSize) / 2;
            ctx.save();
            ctx.imageSmoothingEnabled = false; // Pixelated rendering
            ctx.drawImage(sprite, spriteX, spriteY, spriteSize, spriteSize);
            ctx.restore();
          }
        }
        
        // Equipment label (below the equipment slot)
        ctx.fillStyle = '#ffffff';
        ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Equipment', equipmentX + equipmentSlotSize / 2, equipmentY + equipmentSlotSize + 4);
        
        // Artifact slots grid (below equipment label)
        const slotsStartX = panelX + panelPadding;
        const slotsStartY = equipmentY + equipmentSlotSize + equipmentLabelHeight + equipmentSpacing;
        
        for (let row = 0; row < numRows; row++) {
          for (let col = 0; col < slotsPerRow; col++) {
            const slotIndex = row * slotsPerRow + col;
            const slotX = slotsStartX + col * (slotSize + slotSpacing);
            const slotY = slotsStartY + row * (slotSize + slotSpacing);
            
            // Slot background
            ctx.fillStyle = 'rgba(20, 40, 30, 0.8)';
            ctx.strokeStyle = '#6b4e37'; // Darker brown borders
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.rect(slotX, slotY, slotSize, slotSize);
            ctx.fill();
            ctx.stroke();
            
            // Draw item if present (currently all slots are empty)
            if (inventory.slots[slotIndex]) {
              // Item rendering would go here when items are added
            }
          }
        }
        
        // Instructions
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('Press E to close', panelX + inventoryWidth / 2, panelY + inventoryHeight - 12);
        
        ctx.restore();
                    }

      let lastTime = performance.now();
      function loop(now) {
        const dt = Math.min(33, now - lastTime);
        lastTime = now;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    })();
    </script>
</body>
</html>

