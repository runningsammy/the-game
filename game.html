<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dig, Dig, Dig!</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0f1a12;
        color: #e8eaf6;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, Noto Sans, Helvetica, Arial, 'Apple Color Emoji',
          'Segoe UI Emoji';
      }
      .wrap {
        display: grid;
        grid-template-rows: auto 1fr auto;
        min-height: 100%;
      }
      header,
      footer {
        padding: 6px 14px;
        background: #15193a;
        border-bottom: 1px solid #2b2f55;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 1;
      }
      footer {
        border-top: 1px solid #2b2f55;
        border-bottom: none;
      }
      main {
        display: grid;
        place-items: center;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        background: #1c7f2d;
        border: 1px solid #2b2f55;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        image-rendering: -moz-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        max-width: 100%;
        height: 100%;
        width: auto;
      }
      .hint {
        opacity: 0.8;
        font-size: 11px;
      }
      kbd {
        background: #202659;
        border: 1px solid #303776;
        border-bottom-width: 2px;
        border-radius: 4px;
        padding: 1px 6px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          'Liberation Mono', monospace;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <strong>Dig, Dig, Dig!</strong>
      </header>
      <main>
        <canvas
          id="game"
          width="800"
          height="500"
          aria-label="Game canvas"
        ></canvas>
      </main>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // Disable smoothing for crisp pixel art

        const world = {
          width: 2400,
          height: 2064,
          bg: '#0f1226',
        };

        const camera = {
          x: world.width / 2,
          y: world.height / 2,
          followLerp: 0.12,
        };

        // Title screen camera for scrolling background
        const titleScreenCamera = {
          centerX: world.width / 2, // Center of circular movement
          centerY: world.height / 2,
          radiusX: world.width * 0.2, // Horizontal radius of movement
          radiusY: world.height * 0.15, // Vertical radius of movement
          angle: 0, // Current angle in radians (for smooth circular movement)
          speed: 0.3, // radians per second (slow, smooth rotation)
        };

        // Game state: 'title', 'playing', 'dayEnd', 'museum', or 'weekEnd'
        let gameState = 'loading';

        // Loading screen state
        const loadingState = {
          progress: 0,
          allLoaded: false,
          postLoadTimer: 0,
          postLoadDelay: 1000, // 1 second after everything loads
        };

        // Track all sprites for loading progress
        let allSprites = [];

        // Function to check loading progress
        function updateLoadingProgress() {
          // If allSprites isn't populated yet, wait
          if (allSprites.length === 0) {
            loadingState.progress = 0;
            return;
          }

          // Count loaded sprites (including failed loads - they're "done" too)
          let loaded = 0;
          let failed = 0;
          for (let i = 0; i < allSprites.length; i++) {
            const sprite = allSprites[i];
            // Sprite is loaded if it's complete with valid dimensions
            if (sprite.complete && sprite.naturalWidth > 0) {
              loaded++;
            } else if (sprite.complete && sprite.naturalWidth === 0) {
              // Image failed to load (404, etc) - count as "done" so we don't wait forever
              failed++;
            }
          }
          // Progress is based on how many have finished loading (success or failure)
          loadingState.progress = (loaded + failed) / allSprites.length;

          // All sprites are "done" if they've all completed (either loaded or failed)
          const allDone = allSprites.every((sprite) => sprite.complete);

          if (allDone && !loadingState.allLoaded) {
            loadingState.allLoaded = true;
            loadingState.postLoadTimer = 0;
          }
        }

        // Draw loading screen
        function drawLoadingScreen() {
          try {
            // Clear canvas and draw background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f1a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'Loading...',
              canvas.width / 2,
              canvas.height / 2 - 60
            );

            // Progress bar background
            const barWidth = 400;
            const barHeight = 30;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = canvas.height / 2;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Progress bar fill
            const progressWidth =
              barWidth * Math.min(Math.max(loadingState.progress, 0), 1);
            ctx.fillStyle = '#51ff8a';
            ctx.fillRect(barX, barY, progressWidth, barHeight);

            // Progress bar border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Progress text
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
            const percentText =
              Math.round((loadingState.progress || 0) * 100) + '%';
            ctx.fillText(percentText, canvas.width / 2, barY + barHeight + 30);
          } catch (error) {
            console.error('Loading screen draw error:', error);
            // Fallback: just fill with dark background
            ctx.fillStyle = '#0f1a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }

        // Museum system
        const museum = {
          width: 16, // 16 tiles wide
          height: 16, // 16 tiles tall
          doorRow: 15, // Bottom row (0-indexed)
          doorCol: 7, // Middle column (16/2 - 1 = 7, 0-indexed)
          doorPrompt: false, // Whether door prompt is showing
          wasNearDoor: false, // Track if player was near door (for one-time prompt activation)
        };

        // Day/Time system
        const dayTime = {
          currentDay: 0, // 0 = Monday, 1 = Tuesday, ..., 6 = Sunday
          currentHour: 8, // Current hour (8 AM to 5 PM = 8 to 17)
          hourTimer: 0, // Timer that accumulates seconds, resets when >= 45
          secondsPerHour: 45, // Each in-game hour = 45 seconds
          dayEndHour: 18, // 6 PM (day ends when hour reaches this)
          warningHour: 17, // 5 PM (1 hour before end)
          days: [
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday',
            'Sunday',
          ],
        };

        const tileSize = 32;
        const tileCols = Math.ceil(world.width / tileSize);
        const tileRows = Math.ceil(world.height / tileSize);
        const tileCell = 4;
        const cellsPerTile = tileSize / tileCell;

        function randomRange(min, max) {
          return Math.random() * (max - min) + min;
        }

        function createScatter(
          count,
          minSize,
          maxSize,
          margin = 60,
          minDistance = 120
        ) {
          const sprites = [];
          const maxAttempts = 50;
          const cellSize = minDistance * 2;
          const gridCols = Math.ceil(world.width / cellSize);
          const gridRows = Math.ceil(world.height / cellSize);
          const grid = Array.from({ length: gridRows }, () =>
            Array(gridCols)
              .fill(null)
              .map(() => [])
          );

          function getGridCell(x, y) {
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            return {
              row: Math.max(0, Math.min(gridRows - 1, row)),
              col: Math.max(0, Math.min(gridCols - 1, col)),
            };
          }

          for (let i = 0; i < count; i++) {
            const size = randomRange(minSize, maxSize);
            const colliderRadius = size * 0.42;
            const requiredDistance = minDistance + colliderRadius;
            const requiredDistanceSq = requiredDistance * requiredDistance;

            let x,
              y,
              valid = false;
            let placementAttempts = 0;

            while (!valid && placementAttempts < maxAttempts) {
              placementAttempts++;
              x = randomRange(margin, world.width - margin);
              y = randomRange(margin, world.height - margin);

              const cell = getGridCell(x, y);
              valid = true;
              for (let dr = -1; dr <= 1 && valid; dr++) {
                for (let dc = -1; dc <= 1 && valid; dc++) {
                  const checkRow = cell.row + dr;
                  const checkCol = cell.col + dc;
                  if (
                    checkRow >= 0 &&
                    checkRow < gridRows &&
                    checkCol >= 0 &&
                    checkCol < gridCols
                  ) {
                    for (const existing of grid[checkRow][checkCol]) {
                      const dx = x - existing.x;
                      const dy = y - existing.y;
                      const distSq = dx * dx + dy * dy;
                      if (distSq < requiredDistanceSq) {
                        valid = false;
                        break;
                      }
                    }
                  }
                }
              }
            }

            if (valid) {
              const tree = {
                x,
                y,
                size,
                rotation: randomRange(-Math.PI / 8, Math.PI / 8),
                colliderRadius,
              };
              sprites.push(tree);
              const cell = getGridCell(x, y);
              grid[cell.row][cell.col].push(tree);
            }
          }
          return sprites;
        }

        const flora = {
          trees: createScatter(65, 78, 102, 140, 180),
        };

        const balancingMinigame = {
          active: false,
          potAngle: 0,
          potAngularVelocity: 0,
          timeRemaining: 15,
          baseReward: 10,
          stickX: 0,
          stickY: 0,
          potSprite: null,
          potType: 'regular',
          tileRow: null,
          tileCol: null,
          breaking: false,
          breakTimer: 0,
          pieces: [],
          isSecretX: false, // Track if this minigame came from a secret X tile
        };

        const brushingMinigame = {
          active: false,
          dirtLevel: 1.0,
          redness: 0,
          timeHoldingSpace: 0,
          redTriggerTime: 0,
          timeSinceRed: 0,
          redTransitionTime: 1.0,
          perfectReleaseWindow: 0.5,
          baseReward: 10,
          tileRow: null,
          tileCol: null,
          brushX: 0,
          brushY: 0,
          brushOffset: 0,
          brushDirection: 1,
          particles: [],
          completed: false,
          broken: false,
          isSecretX: false, // Track if this minigame came from a secret X tile
        };

        const declarationMinigame = {
          active: false,
          baseReward: 50,
          penalty: 30,
          tileRow: null,
          tileCol: null,
          realExcerpt:
            'We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the pursuit of Happiness.',
          testExcerpt: '',
          isFake: false,
          answered: false,
          wasCorrect: false,
          actualReward: 0,
          isSecretX: false, // Track if this minigame came from a secret X tile
        };

        // Optimize sprite loading: set imageSmoothingEnabled before src for faster rendering
        const potSprite = new Image();
        potSprite.imageSmoothingEnabled = false;
        potSprite.src = 'assets/sprites/pot.png';

        const potTallTanSprite = new Image();
        potTallTanSprite.imageSmoothingEnabled = false;
        potTallTanSprite.src = 'assets/sprites/tall-pot.png';

        const potShortGreySprite = new Image();
        potShortGreySprite.imageSmoothingEnabled = false;
        potShortGreySprite.src = 'assets/sprites/short-pot.png';

        const potPoleSprite = new Image();
        potPoleSprite.imageSmoothingEnabled = false;
        potPoleSprite.src = 'assets/sprites/pot-pole.png';

        const brushSprite = new Image();
        brushSprite.imageSmoothingEnabled = false;
        brushSprite.src = 'assets/sprites/brush.png';

        const speedBrushSprite = new Image();
        speedBrushSprite.imageSmoothingEnabled = false;
        speedBrushSprite.src = 'assets/sprites/Speed_Brush.png';

        // Candy Kid sprite (kept for potential future use)
        // const candyKidSprite = new Image();
        // candyKidSprite.imageSmoothingEnabled = false;
        // candyKidSprite.src = 'assets/sprites/Candy_Kid.png';

        const dirtSprite = new Image();
        dirtSprite.imageSmoothingEnabled = false;
        dirtSprite.src = 'assets/sprites/dirt.png';

        const grassSprite = new Image();
        grassSprite.imageSmoothingEnabled = false;
        grassSprite.src = 'assets/sprites/Grass.png';

        const flowerSprite = new Image();
        flowerSprite.imageSmoothingEnabled = false;
        flowerSprite.src = 'assets/sprites/New_Flower.png';

        const rock1Sprite = new Image();
        rock1Sprite.imageSmoothingEnabled = false;
        rock1Sprite.src = 'assets/sprites/Rock_1.png';

        const rock2Sprite = new Image();
        rock2Sprite.imageSmoothingEnabled = false;
        rock2Sprite.src = 'assets/sprites/Rock_2.png';

        const newXSprite = new Image();
        newXSprite.imageSmoothingEnabled = false;
        newXSprite.src = 'assets/sprites/New_New_X.png';

        const yellowXSprite = new Image();
        yellowXSprite.imageSmoothingEnabled = false;
        yellowXSprite.src = 'assets/sprites/Yellow_X.png';

        const newBushSprite = new Image();
        newBushSprite.imageSmoothingEnabled = false;
        newBushSprite.src = 'assets/sprites/New_Bush.png';

        const tallGrassSprite = new Image();
        tallGrassSprite.imageSmoothingEnabled = false;
        tallGrassSprite.src = 'assets/sprites/Tall_Grass.png';

        // Function to regenerate tiles that use sprites (optimized - only regenerates when needed)
        // Deferred to avoid blocking the main thread during load
        let tileRegenerationScheduled = false;
        function regenerateTiles() {
          // Defer regeneration to avoid blocking during sprite load
          if (tileRegenerationScheduled) return;
          tileRegenerationScheduled = true;

          // Use requestAnimationFrame to defer to next frame, allowing page to be interactive
          requestAnimationFrame(() => {
            // Check if tileMap exists (it's created later in the code)
            if (typeof tileMap === 'undefined') {
              return; // tileMap not created yet, skip regeneration
            }

            // Only regenerate tiles that use sprites (grass, flowers, and tiles with grass base)
            const spriteTileNames = [
              'grass',
              'moundedBush',
              'singleRock',
              'rockCluster',
              'redX',
              'secretX',
              'logRows',
            ];

            for (let row = 0; row < tileRows; row++) {
              for (let col = 0; col < tileCols; col++) {
                const tile = tileMap[row][col];
                if (tile && spriteTileNames.includes(tile.name)) {
                  // Find the original tile definition
                  const def = tileDefinitions.find((d) => d.name === tile.name);
                  if (def) {
                    // Regenerate the canvas with the now-loaded sprites
                    // Preserve rotation for grass tiles
                    const oldTile = tileMap[row][col];
                    const rotation =
                      oldTile && oldTile.grassRotation !== undefined
                        ? oldTile.grassRotation
                        : 0;
                    tileMap[row][col] = {
                      name: def.name,
                      canvas: createTileCanvas((ctx) =>
                        def.draw(ctx, rotation)
                      ),
                      grassRotation: rotation, // Preserve rotation
                    };
                  }
                }
              }
            }
            tileRegenerationScheduled = false;
          });
        }

        // Regenerate tiles when grass sprite loads (deferred)
        grassSprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when flower sprite loads (deferred)
        flowerSprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when rock sprites load (deferred)
        rock1Sprite.onload = function () {
          regenerateTiles();
        };

        rock2Sprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when New_X sprite loads (deferred)
        newXSprite.onload = function () {
          regenerateTiles();
        };

        newBushSprite.onload = function () {
          regenerateTiles();
        };

        // Regenerate tiles when tall grass sprite loads (deferred)
        tallGrassSprite.onload = function () {
          regenerateTiles();
        };

        // If sprite is already loaded (cached), regenerate tiles immediately
        if (grassSprite.complete && grassSprite.naturalWidth > 0) {
          // Sprite already loaded, but tiles haven't been created yet
          // We'll regenerate after tiles are created (see below)
        }

        // Optimize sprite loading: set imageSmoothingEnabled before src
        const oldGuySprite = new Image();
        oldGuySprite.imageSmoothingEnabled = false;
        oldGuySprite.src = 'assets/sprites/oldguy.png';

        const shopkeeperSprite = new Image();
        shopkeeperSprite.imageSmoothingEnabled = false;
        shopkeeperSprite.src = 'assets/sprites/shopkeeper.png';

        const curatorSprite = new Image();
        curatorSprite.imageSmoothingEnabled = false;
        curatorSprite.src = 'assets/sprites/Museum_Curator.png';

        // Vending Machine sprite (kept for potential future use)
        // const vendingMachineSprite = new Image();
        // vendingMachineSprite.imageSmoothingEnabled = false;
        // vendingMachineSprite.src = 'assets/sprites/Vending_Machine.png';

        const chocolateBarSprite = new Image();
        chocolateBarSprite.imageSmoothingEnabled = false;
        chocolateBarSprite.src = 'assets/sprites/Chocolate_Bar.png';

        // Minigame reward sprites
        const bulletsSprite = new Image();
        bulletsSprite.imageSmoothingEnabled = false;
        bulletsSprite.src = 'assets/sprites/Bullets.png';

        const grapeshotSprite = new Image();
        grapeshotSprite.imageSmoothingEnabled = false;
        grapeshotSprite.src = 'assets/sprites/Grapeshot.png';

        const rustyNailsSprite = new Image();
        rustyNailsSprite.imageSmoothingEnabled = false;
        rustyNailsSprite.src = 'assets/sprites/Rusty_Nails.png';

        // Museum sprites
        const floorTileSprite = new Image();
        floorTileSprite.imageSmoothingEnabled = false;
        floorTileSprite.src = 'assets/sprites/Floor_Tile.png';

        const wallTileSprite = new Image();
        wallTileSprite.imageSmoothingEnabled = false;
        wallTileSprite.src = 'assets/sprites/Wall_Tile.png';

        const wallDoorSprite = new Image();
        wallDoorSprite.imageSmoothingEnabled = false;
        wallDoorSprite.src = 'assets/sprites/Wall_Door.png';

        // Load player sprites from PNG images
        const playerSpriteIdle = new Image();
        playerSpriteIdle.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteIdle.src = 'assets/sprites/player.png';

        const playerSpriteBack = new Image();
        playerSpriteBack.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteBack.src = 'assets/sprites/player_back.png';

        const playerSpriteBackWalk1 = new Image();
        playerSpriteBackWalk1.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteBackWalk1.src = 'assets/sprites/player_back_walk1.png';

        const playerSpriteBackWalk2 = new Image();
        playerSpriteBackWalk2.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteBackWalk2.src = 'assets/sprites/player_back_walk2.png';

        const playerSpriteWalk1 = new Image();
        playerSpriteWalk1.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteWalk1.src = 'assets/sprites/player_walk1.png';

        const playerSpriteWalk2 = new Image();
        playerSpriteWalk2.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteWalk2.src = 'assets/sprites/player_walk2.png';

        const playerSpriteCrouch1 = new Image();
        playerSpriteCrouch1.imageSmoothingEnabled = false; // Pixelated rendering
        playerSpriteCrouch1.src = 'assets/sprites/crouch-one.png';

        const playerSpriteCrouch2 = new Image();
        playerSpriteCrouch2.src = 'assets/sprites/crouch-two.png';
        playerSpriteCrouch2.imageSmoothingEnabled = false; // Pixelated rendering

        // Walking animation state
        let walkAnimationFrame = 0;
        const walkAnimationSpeed = 0.15; // How fast the animation cycles (lower = faster)

        // Crouch animation state (plays before starting minigame)
        const crouchAnimation = {
          active: false,
          timer: 0,
          duration: 1.0, // 1 second
          pendingMinigame: null, // Stores which minigame to start after animation
          particles: [], // Particle effects during animation
        };

        function createTileCanvas(drawFn) {
          // Create canvas with 1px overlap to eliminate seams between tiles
          // This technique ensures tiles can overlap slightly without stretching
          const overlap = 1;
          const buffer = document.createElement('canvas');
          buffer.width = tileSize + overlap;
          buffer.height = tileSize + overlap;
          const bctx = buffer.getContext('2d');
          // Disable image smoothing for pixel art
          bctx.imageSmoothingEnabled = false;
          // Draw the tile content (drawFn draws in the tileSize x tileSize area)
          drawFn(bctx);
          // Copy the rightmost column (column tileSize - 1) to the overlap column (column tileSize)
          // This creates seamless tiling: when adjacent tiles are drawn, they overlap by 1px
          // The rightmost pixel of each tile is the same as the leftmost visible pixel of the next tile
          const rightEdge = bctx.getImageData(tileSize - 1, 0, 1, tileSize);
          bctx.putImageData(rightEdge, tileSize, 0);
          // Copy the bottommost row (row tileSize - 1) to the overlap row (row tileSize)
          const bottomEdge = bctx.getImageData(0, tileSize - 1, tileSize, 1);
          bctx.putImageData(bottomEdge, 0, tileSize);
          // Copy the corner pixel for the bottom-right overlap
          const corner = bctx.getImageData(tileSize - 1, tileSize - 1, 1, 1);
          bctx.putImageData(corner, tileSize, tileSize);
          return buffer;
        }

        const colors = {
          grassBase: '#28a933',
          grassBright: '#36c843',
          grassDark: '#1e902a',
          outline: '#0c0c0c',
          rockLight: '#c2c2c2',
          rockMid: '#959595',
          rockDark: '#5f5f5f',
          rockShadow: '#3f3f3f',
          moundOuter: '#0c3f16',
          moundInner: '#0f5c1f',
          moundHighlight: '#157f2d',
          logLight: '#147429',
          logDark: '#0e5a20',
          logShadow: '#094217',
          redDark: '#780808',
          redBase: '#c40f0f',
          redBright: '#ff2a2a',
        };

        function fillCell(ctx, cx, cy, color) {
          ctx.fillStyle = color;
          ctx.fillRect(cx * tileCell, cy * tileCell, tileCell, tileCell);
        }

        function drawPlus(ctx, cx, cy, color) {
          fillCell(ctx, cx, cy, color);
          fillCell(ctx, cx - 1, cy, color);
          fillCell(ctx, cx + 1, cy, color);
          fillCell(ctx, cx, cy - 1, color);
          fillCell(ctx, cx, cy + 1, color);
        }

        function paintGrassBase(ctx, plusLayout) {
          ctx.fillStyle = colors.grassBase;
          ctx.fillRect(0, 0, tileSize, tileSize);
          const layout = plusLayout || [
            { x: 2, y: 2, color: colors.grassBright },
            { x: 5, y: 4, color: colors.grassBright },
            { x: 1, y: 5, color: colors.grassDark },
            { x: 6, y: 1, color: colors.grassDark },
          ];
          layout.forEach((plus) => drawPlus(ctx, plus.x, plus.y, plus.color));
        }

        const tileDefinitions = [
          {
            name: 'grass',
            weight: 110,
            draw(ctx, rotation = 0) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                // Apply random rotation (0, 90, 180, or 270 degrees)
                if (rotation !== 0) {
                  ctx.save();
                  ctx.translate(tileSize / 2, tileSize / 2);
                  ctx.rotate((rotation * Math.PI) / 180);
                  ctx.drawImage(
                    grassSprite,
                    -tileSize / 2,
                    -tileSize / 2,
                    tileSize,
                    tileSize
                  );
                  ctx.restore();
                } else {
                  ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
                }
              }
            },
          },
          {
            name: 'singleRock',
            weight: 10,
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw Rock_1 sprite on top of grass
              if (rock1Sprite.complete && rock1Sprite.naturalWidth > 0) {
                ctx.drawImage(rock1Sprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'rockCluster',
            weight: 8,
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw Rock_2 sprite on top of grass
              if (rock2Sprite.complete && rock2Sprite.naturalWidth > 0) {
                ctx.drawImage(rock2Sprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'moundedBush',
            weight: 7,
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw New_Bush sprite on top of grass
              if (newBushSprite.complete && newBushSprite.naturalWidth > 0) {
                ctx.drawImage(newBushSprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'logRows',
            weight: 5,
            draw(ctx) {
              // Always use grass sprite as base (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw tall grass sprite instead of logs
              // Position tall grass sprite in the center of the tile
              if (
                tallGrassSprite.complete &&
                tallGrassSprite.naturalWidth > 0
              ) {
                ctx.drawImage(tallGrassSprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'redX',
            weight: 2, // Reduced to 1/3 of original weight (5 -> 2)
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw New_New_X sprite on top of grass (no darkening needed)
              if (newXSprite.complete && newXSprite.naturalWidth > 0) {
                ctx.drawImage(newXSprite, 0, 0, tileSize, tileSize);
              }
            },
          },
          {
            name: 'secretX',
            weight: 2, // Twice as common (doubled from 1)
            draw(ctx) {
              // Always use grass sprite (only draw if loaded)
              // Secret X tiles - show grass with yellow/orange X pattern (visible for testing)
              ctx.imageSmoothingEnabled = false;
              if (grassSprite.complete && grassSprite.naturalWidth > 0) {
                ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              }
              // Draw yellow X sprite only if radar is active
              // This makes secret X tiles invisible unless player has radar
              // Check if radar exists and is active (radar is defined later in code)
              // Use try-catch to safely check radar since it's defined later
              try {
                if (
                  typeof radar !== 'undefined' &&
                  radar &&
                  radar.active &&
                  yellowXSprite.complete &&
                  yellowXSprite.naturalWidth > 0
                ) {
                  ctx.drawImage(yellowXSprite, 0, 0, tileSize, tileSize);
                }
              } catch (e) {
                // Radar not defined yet, don't draw yellow X (tiles will be invisible until radar is active)
              }
            },
          },
        ];

        const tileWeightTotal = tileDefinitions.reduce(
          (sum, t) => sum + t.weight,
          0
        );

        function pickTileDefinition() {
          let roll = Math.random() * tileWeightTotal;
          for (const def of tileDefinitions) {
            if ((roll -= def.weight) <= 0) {
              return def;
            }
          }
          return tileDefinitions[0];
        }

        // Helper function to check if a tile position overlaps with any tree
        function isTreeAtTile(row, col) {
          const tileCenterX = (col + 0.5) * tileSize;
          const tileCenterY = (row + 0.5) * tileSize;

          for (let i = 0; i < flora.trees.length; i++) {
            const tree = flora.trees[i];
            const dx = tree.x - tileCenterX;
            const dy = tree.y - tileCenterY;
            const distSq = dx * dx + dy * dy;
            const treeRadius = tree.colliderRadius || tree.size * 0.42;
            const minDistSq =
              (tileSize / 2 + treeRadius) * (tileSize / 2 + treeRadius);

            if (distSq < minDistSq) {
              return true;
            }
          }
          return false;
        }

        // Function to generate tiles (used at start and when resetting days)
        function generateTiles() {
          const newTileMap = [];
          for (let row = 0; row < tileRows; row++) {
            newTileMap[row] = [];
            for (let col = 0; col < tileCols; col++) {
              let def = pickTileDefinition();

              // If redX or secretX tile was picked and there's a tree at this position, replace with grass
              if (
                (def.name === 'redX' || def.name === 'secretX') &&
                isTreeAtTile(row, col)
              ) {
                def = tileDefinitions.find((d) => d.name === 'grass');
              }

              // No rotation for grass tiles to ensure seamless tiling
              // Random rotations cause adjacent tiles to have mismatched edges, creating visible seams
              // Keeping all grass tiles at 0Â° rotation ensures edges align perfectly
              let grassRotation = 0;

              newTileMap[row][col] = {
                name: def.name,
                canvas: createTileCanvas((ctx) => def.draw(ctx, grassRotation)),
                grassRotation: grassRotation, // Store rotation for reference
              };
            }
          }
          return newTileMap;
        }

        // Generate initial tiles
        let tileMap = generateTiles();

        // If sprites were already loaded before tiles were created, regenerate now
        if (
          (grassSprite.complete && grassSprite.naturalWidth > 0) ||
          (flowerSprite.complete && flowerSprite.naturalWidth > 0)
        ) {
          regenerateTiles();
        }

        const player = {
          x: world.width / 2,
          y: world.height - 40,
          width: 43,
          height: 43,
          color: '#7cffb3', // Original teal/green player color
          outline: '#0c2a19',
          vx: 0,
          vy: 0,
          maxSpeed: 2.0,
          accel: 0.25,
          friction: 0.86,
          sprintMultiplier: 1.6,
          radius: Math.max(39, 39) * 0.5, // Cache radius calculation
        };

        // Stamina system for sprinting
        const stamina = {
          current: 100,
          max: 100,
          drainPerSecond: 35, // how fast stamina drains while sprinting
          regenPerSecond: 22, // how fast stamina regenerates when not sprinting
          minToSprint: 8, // must have at least this much to initiate sprint
          exhausted: false, // when true, cannot sprint until fully recovered
        };

        // Cache gradients for stamina bar (created once, reused)
        let staminaBarGradients = null;
        function initStaminaGradients() {
          if (staminaBarGradients) return; // Already initialized
          const barW = 220;
          const barX = 16.5;
          const normalGradient = ctx.createLinearGradient(
            barX,
            0,
            barX + barW,
            0
          );
          normalGradient.addColorStop(0, '#51ff8a'); // Original teal/green
          normalGradient.addColorStop(1, '#7cffb3'); // Original teal/green
          const exhaustedGradient = ctx.createLinearGradient(
            barX,
            0,
            barX + barW,
            0
          );
          exhaustedGradient.addColorStop(0, '#ff4d4f');
          exhaustedGradient.addColorStop(1, '#ff7875');
          staminaBarGradients = {
            normal: normalGradient,
            exhausted: exhaustedGradient,
          };
        }

        // Game over state
        const gameOver = {
          active: false,
          message:
            'Your museum lost funding after displaying too many fakes. Try again!',
        };

        // System message (no character name, skippable)
        const systemMessage = {
          text: null, // Current system message text
        };

        // Tutorial dialogue system
        const tutorial = {
          active: false, // Tutorial disabled - oldGuy shows first dialogue instead
          dialogue: 'Hey! Over here!',
        };

        // Old Guy NPC (positioned to the right of spawn)
        const oldGuy = {
          x: world.width / 2 + 150, // To the right of spawn
          y: world.height - 40, // Same Y as spawn
          radius: 20,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // Track which dialogue to show (0-5 for initial sequence)
          hasCompletedIntro: false, // Track if player has completed initial dialogue sequence
        };

        // Joseph NPC (shopkeeper with radar, positioned centrally)
        const joseph = {
          x: world.width / 2, // Central location
          y: world.height / 2, // Central location
          radius: 20,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // Track dialogue progress (0-5)
          hasGivenRadar: false, // Track if player has received radar
        };

        // Museum Curator NPC (positioned in museum)
        const curator = {
          x: 0, // Will be set in initializeMuseum
          y: 0, // Will be set in initializeMuseum
          radius: 20,
          dialogue: null, // Current dialogue text
          dialogueStage: 0, // 0 = none, 1 = has artifacts, 2 = no artifacts
          dialogueTimer: 0, // Timer for auto-closing dialogue
        };

        // Inventory system
        const inventory = {
          open: false,
          slots: Array(15).fill(null), // 15 inventory slots
          equipment: null, // 1 equipment slot
          chocolateBarCount: 0, // Track chocolate bars (stored in equipment slot, not inventory)
          speedBrush: false, // Track if Speed Brush is owned (equipment slot only, not inventory)
        };

        // Candybar boost system
        const candybarBoost = {
          active: false, // Whether candybar boost is currently active
          duration: 0, // Time remaining in seconds
          maxDuration: 20, // 20 seconds duration
          cooldown: 0, // Time remaining on cooldown in seconds
          cooldownTime: 20, // 20 seconds cooldown
        };

        const keys = Object.create(null);
        const keyJustPressed = Object.create(null); // Track keys that were just pressed this frame
        const pressed = (code) => keys[code] === true;

        window.addEventListener(
          'keydown',
          (e) => {
            if (!keys[e.code]) {
              keyJustPressed[e.code] = true; // Mark as just pressed
            }
            keys[e.code] = true;
            // Prevent arrow keys from scrolling
            if (
              [
                'ArrowUp',
                'ArrowDown',
                'ArrowLeft',
                'ArrowRight',
                'Space',
              ].includes(e.code)
            ) {
              e.preventDefault();
            }
            // Toggle inventory with E
            if (e.code === 'KeyE') {
              e.preventDefault();
              // Don't allow opening inventory during minigame or game over
              if (
                balancingMinigame.active ||
                brushingMinigame.active ||
                declarationMinigame.active ||
                gameOver.active
              ) {
                return;
              }
              const wasOpen = inventory.open;
              inventory.open = !inventory.open;
              // Kill momentum when opening inventory
              if (!wasOpen && inventory.open) {
                player.vx = 0;
                player.vy = 0;
              }
            }

            // Interaction key Spacebar
            if (e.code === 'Space') {
              e.preventDefault();
              // Don't allow interaction during crouch animation or minigames (minigames use spacebar for their own mechanics)
              if (
                crouchAnimation.active ||
                balancingMinigame.active ||
                brushingMinigame.active ||
                declarationMinigame.active
              ) {
                return;
              }
              // Only process dialogue/interaction on key press, not while held
              // This prevents dialogue from skipping too fast when holding spacebar
              if (!keyJustPressed['Space']) {
                return; // Key already processed this frame
              }
              // If dialogue is showing, advance it (only once per key press)
              // Skip tutorial check in museum state (tutorial doesn't apply there)
              if (tutorial.active && gameState !== 'museum') {
                tutorial.active = false; // Close tutorial
                player.vx = 0;
                player.vy = 0;
              } else if (
                systemMessage.text ||
                oldGuy.dialogue ||
                joseph.dialogue ||
                curator.dialogue
              ) {
                // System messages can always be closed with spacebar
                if (systemMessage.text) {
                  systemMessage.text = null;
                } else if (oldGuy.dialogue) {
                  advanceOldGuyDialogue(); // Advance through dialogue stages
                  player.vx = 0;
                  player.vy = 0;
                } else if (joseph.dialogue) {
                  advanceJosephDialogue();
                  player.vx = 0;
                  player.vy = 0;
                } else if (curator.dialogue) {
                  advanceCuratorDialogue();
                  player.vx = 0;
                  player.vy = 0;
                }
              } else {
                // Try to interact (curator in museum, or other NPCs in playing state)
                // Check curator directly in museum state, otherwise use handleInteraction
                if (gameState === 'museum') {
                  // Direct curator interaction check - use fixed distance for reliability
                  const dx = player.x - curator.x;
                  const dy = player.y - curator.y;
                  const distSq = dx * dx + dy * dy;
                  // Use fixed interaction distance of 50 pixels
                  const interactionDistSq = 50 * 50;

                  if (distSq <= interactionDistSq) {
                    const hasArtifacts = inventory.slots.some(
                      (slot) => slot !== null
                    );

                    if (hasArtifacts) {
                      curator.dialogue =
                        'Hello there! I see you have some artifacts.';
                      curator.dialogueStage = 0; // Start at 0, advanceCuratorDialogue will increment to 1
                    } else {
                      curator.dialogue =
                        "Looks like you don't have anything to put in your museum.";
                      curator.dialogueStage = 0; // Start at 0, advanceCuratorDialogue will increment to 1
                    }
                    curator.dialogueTimer = 0;
                    player.vx = 0;
                    player.vy = 0;
                  }
                } else {
                  // Use normal handleInteraction for playing state
                  handleInteraction();
                }
              }
            }

            // Shop controls removed - now uses mouse clicks only

            // Declaration minigame: Removed keyboard controls, now uses buttons

            // Day end: Space to continue to next day
            if (gameState === 'dayEnd' && e.code === 'Space') {
              e.preventDefault();
              startNewDay();
              return;
            }

            // Week end: Space to return to title
            if (gameState === 'weekEnd' && e.code === 'Space') {
              e.preventDefault();
              gameState = 'title';
              // Reset everything for new game
              dayTime.currentDay = 0; // Start on Monday
              dayTime.currentHour = 8; // Start at 8:00 AM
              dayTime.hourTimer = 0;
              return;
            }

            // Game over: Space to restart
            if (gameOver.active && e.code === 'Space') {
              e.preventDefault();
              // Reset game state
              gameOver.active = false;
              // Reset player position
              player.x = world.width / 2;
              player.y = world.height - 40;
              player.vx = 0;
              player.vy = 0;
            }
          },
          { passive: false }
        );

        window.addEventListener('keyup', (e) => {
          keys[e.code] = false;
          keyJustPressed[e.code] = false;
        });

        // Track mouse position for hover effects
        let mouseX = 0;
        let mouseY = 0;

        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          // Account for canvas scaling - convert display coordinates to internal canvas coordinates
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          mouseX = (e.clientX - rect.left) * scaleX;
          mouseY = (e.clientY - rect.top) * scaleY;
        });

        // Mouse click handling for buttons
        canvas.addEventListener('click', (e) => {
          // Don't handle clicks if on title screen (title screen has its own handler)
          if (gameState === 'title') {
            return;
          }

          const rect = canvas.getBoundingClientRect();
          // Account for canvas scaling - convert display coordinates to internal canvas coordinates
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          // Museum door prompt click handling
          if (gameState === 'museum' && museum.doorPrompt) {
            const panelWidth = 400;
            const panelHeight = 200;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;
            const buttonWidth = 120;
            const buttonHeight = 50;
            const buttonSpacing = 40;
            const continueButtonX =
              panelX + panelWidth / 2 - buttonWidth - buttonSpacing / 2;
            const stayButtonX = panelX + panelWidth / 2 + buttonSpacing / 2;
            const buttonY = panelY + panelHeight - buttonHeight - 30;

            // Check if clicking continue button
            if (
              x >= continueButtonX &&
              x <= continueButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              museum.doorPrompt = false;
              startNewDay();
              return;
            }

            // Check if clicking stay button
            if (
              x >= stayButtonX &&
              x <= stayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              museum.doorPrompt = false;
              return;
            }
          }

          // Declaration minigame buttons
          if (declarationMinigame.active && !declarationMinigame.answered) {
            // Calculate button positions (same as in render function)
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            const buttonY = panelY + panelHeight - 80;
            const buttonWidth = 150;
            const buttonHeight = 40;
            const buttonSpacing = 20;
            const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
            const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

            // Display button (left)
            const displayButtonX = buttonStartX;
            if (
              x >= displayButtonX &&
              x <= displayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleDeclarationAnswer(true); // Display = Real
              return;
            }

            // Throw away button (right)
            const throwAwayButtonX = buttonStartX + buttonWidth + buttonSpacing;
            if (
              x >= throwAwayButtonX &&
              x <= throwAwayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleDeclarationAnswer(false); // Throw away = Fake
              return;
            }

            // Close button removed
          }

          // Inventory click handling (eating candybars from equipment slot, and inventory slots)
          if (inventory.open) {
            // Equipment items array (must match drawInventory)
            const equipmentItems = [
              {
                name: 'Radar',
                sprite: radarSprite,
                description: "Reveals hidden X's",
              },
              {
                name: 'Chocolate Bar',
                sprite: chocolateBarSprite,
                description: 'Speeds up your movement',
              },
              {
                name: 'Speed Brush',
                sprite: speedBrushSprite,
                description: 'Makes brushing minigame easier',
              },
            ];

            const slotSize = 48;
            const slotSpacing = 4;
            const slotsPerRow = 5;
            const numRows = 2; // Match drawInventory
            const panelPadding = 24;
            const equipmentSlotSize = 48; // Match drawInventory
            const equipmentRowSpacing = 4; // Match drawInventory
            const titleHeight = 40;
            const equipmentLabelHeight = 16;
            const equipmentSpacing = 30; // Match drawInventory
            const instructionsHeight = 30;

            // Calculate dimensions (match drawInventory)
            const equipmentRowWidth =
              equipmentItems.length * equipmentSlotSize +
              (equipmentItems.length - 1) * equipmentRowSpacing;
            const slotsAreaWidth =
              slotsPerRow * slotSize + (slotsPerRow - 1) * slotSpacing;
            const slotsAreaHeight =
              numRows * slotSize + (numRows - 1) * slotSpacing;
            const inventoryWidth =
              Math.max(equipmentRowWidth, slotsAreaWidth) + panelPadding * 2;
            const inventoryHeight =
              titleHeight +
              equipmentSlotSize +
              equipmentLabelHeight +
              equipmentSpacing +
              slotsAreaHeight +
              panelPadding * 2 +
              instructionsHeight;

            const panelX =
              Math.round(canvas.width / 2 - inventoryWidth / 2) + 0.5;
            const panelY =
              Math.round(canvas.height / 2 - inventoryHeight / 2) + 0.5;

            // Equipment row (match drawInventory)
            const equipmentRowStartX =
              panelX + inventoryWidth / 2 - equipmentRowWidth / 2;
            const equipmentY = panelY + titleHeight + 30; // Match drawInventory

            // Check if clicking on equipment slots (chocolate bar)
            for (let i = 0; i < equipmentItems.length; i++) {
              const item = equipmentItems[i];
              if (item.name === 'Chocolate Bar') {
                const equipmentX =
                  equipmentRowStartX +
                  i * (equipmentSlotSize + equipmentRowSpacing);

                if (
                  x >= equipmentX &&
                  x <= equipmentX + equipmentSlotSize &&
                  y >= equipmentY &&
                  y <= equipmentY + equipmentSlotSize
                ) {
                  // Eat chocolate bar if not on cooldown and boost not active
                  if (
                    inventory.chocolateBarCount > 0 &&
                    candybarBoost.cooldown <= 0 &&
                    !candybarBoost.active
                  ) {
                    candybarBoost.active = true;
                    candybarBoost.duration = candybarBoost.maxDuration;
                    inventory.chocolateBarCount -= 1; // Decrease count
                  }
                  return;
                }
              }
            }

            // Artifacts slots (for other items)
            const artifactsLabelY =
              equipmentY +
              equipmentSlotSize +
              equipmentLabelHeight +
              equipmentSpacing;
            const slotsStartX = panelX + panelPadding;
            const slotsStartY = artifactsLabelY;

            // Check if clicking on inventory slots
            for (let row = 0; row < numRows; row++) {
              for (let col = 0; col < slotsPerRow; col++) {
                const slotIndex = row * slotsPerRow + col;
                const slotX = slotsStartX + col * (slotSize + slotSpacing);
                const slotY = slotsStartY + row * (slotSize + slotSpacing);

                if (
                  x >= slotX &&
                  x <= slotX + slotSize &&
                  y >= slotY &&
                  y <= slotY + slotSize
                ) {
                  const item = inventory.slots[slotIndex];
                  if (
                    item &&
                    item.type === 'consumable' &&
                    item.name === 'Candybar'
                  ) {
                    // Eat candybar if not on cooldown and boost not active
                    if (candybarBoost.cooldown <= 0 && !candybarBoost.active) {
                      candybarBoost.active = true;
                      candybarBoost.duration = candybarBoost.maxDuration;
                      inventory.slots[slotIndex] = null; // Remove from inventory
                    }
                  }
                  return;
                }
              }
            }
          }
        });

        function clamp(value, min, max) {
          return Math.min(max, Math.max(min, value));
        }

        // Function to initialize museum
        function initializeMuseum() {
          // Set museum world size
          const museumTileSize = tileSize; // Use same tile size
          const museumWorldWidth = museum.width * museumTileSize;
          const museumWorldHeight = museum.height * museumTileSize;

          // Position player in center-top of museum
          player.x = museumWorldWidth / 2;
          player.y = museumTileSize * 2; // A bit down from top
          player.vx = 0;
          player.vy = 0;

          // Position curator in bottom left of museum
          curator.x = museumTileSize * 2; // Left side, 2 tiles from edge
          curator.y = museumWorldHeight - museumTileSize * 2; // Bottom, 2 tiles from edge

          // Position camera to place museum at bottom middle of screen
          camera.x = museumWorldWidth / 2; // Center horizontally (160 for 320px wide museum)
          // Position camera so museum appears at bottom of screen
          // Translation formula: screenY = worldY + (canvas.height/2 - camera.y)
          // Museum is drawn from world (0,0) to (320,320)
          // We want museum bottom (worldY = 320) at screen bottom (screenY = 500)
          // 500 = 320 + (250 - camera.y)
          // camera.y = 320 + 250 - 500 = 70
          // This positions museum from screenY 180 to 500 (at bottom)
          camera.y = museumWorldHeight - canvas.height / 2; // = 70
          camera.x = Math.round(camera.x);
          camera.y = Math.round(camera.y);

          // Debug: Force camera position (museum is 320px tall, canvas is 500px tall)
          // With camera.y = 70: screenY = worldY + 180
          // Museum top (worldY=0) â screenY=180, bottom (worldY=320) â screenY=500 â

          // Reset door prompt and tracking
          museum.doorPrompt = false;
          museum.wasNearDoor = false;
        }

        // Function to start a new day
        function startNewDay() {
          // Move to next day
          dayTime.currentDay++;

          // Check if week is over (Sunday = day 6, so after Sunday we're done)
          if (dayTime.currentDay > 6) {
            // Week is over
            gameState = 'weekEnd';
            return;
          }

          // Reset time for new day
          dayTime.currentHour = 8;
          dayTime.hourTimer = 0;

          // Don't show tutorial after first day
          if (dayTime.currentDay > 0) {
            tutorial.active = false;
          }

          // Set oldGuy's first dialogue on first day (replaces tutorial)
          if (dayTime.currentDay === 0) {
            oldGuy.dialogue = 'Hey! Over here!';
            oldGuy.dialogueStage = 0;
          }

          // Reset player to starting position
          player.x = world.width / 2;
          player.y = world.height - 40;
          player.vx = 0;
          player.vy = 0;

          // Reset camera to player
          camera.x = player.x;
          camera.y = player.y;

          // Regenerate tiles (randomize X's)
          tileMap = generateTiles();

          // Reset game state
          gameState = 'playing';
        }

        function update(dtMs) {
          const dt = (dtMs || 16.67) / 1000; // seconds

          // Update candybar boost timer
          if (gameState === 'playing') {
            if (candybarBoost.active) {
              candybarBoost.duration -= dt;
              if (candybarBoost.duration <= 0) {
                candybarBoost.active = false;
                candybarBoost.cooldown = candybarBoost.cooldownTime; // Start cooldown
              }
            } else if (candybarBoost.cooldown > 0) {
              candybarBoost.cooldown -= dt;
              if (candybarBoost.cooldown < 0) {
                candybarBoost.cooldown = 0;
              }
            }
          }

          // Update day/time system (only when playing)
          if (gameState === 'playing') {
            // Increment timer for current hour
            dayTime.hourTimer += dt;

            // When timer reaches 45 seconds, advance to next hour
            if (dayTime.hourTimer >= dayTime.secondsPerHour) {
              dayTime.currentHour++;
              dayTime.hourTimer = 0; // Reset timer for new hour
            }

            // Check if day should end (6 PM = 18:00)
            if (dayTime.currentHour >= dayTime.dayEndHour) {
              // Go to museum (except Sunday/after Sunday)
              if (dayTime.currentDay < 6) {
                // Not Sunday yet, go to museum
                gameState = 'museum';
                initializeMuseum();
              } else {
                // Sunday or later, go to dayEnd (week end)
                gameState = 'dayEnd';
              }
              // Stop player movement
              player.vx = 0;
              player.vy = 0;
            }
          }

          // Update museum (separate from playing state)
          if (gameState === 'museum' && !museum.doorPrompt) {
            const museumTileSize = tileSize;
            const museumWorldWidth = museum.width * museumTileSize;
            const museumWorldHeight = museum.height * museumTileSize;

            // Player movement in museum - disable movement if dialogue is showing
            // Declare variables outside if/else so they're available for animation/stamina updates
            const wantsSprint = pressed('ShiftLeft') || pressed('ShiftRight');
            const hasInput =
              pressed('ArrowLeft') ||
              pressed('KeyA') ||
              pressed('ArrowRight') ||
              pressed('KeyD') ||
              pressed('ArrowUp') ||
              pressed('KeyW') ||
              pressed('ArrowDown') ||
              pressed('KeyS');
            const allowBoost =
              wantsSprint &&
              !stamina.exhausted &&
              stamina.current >= stamina.minToSprint;
            const shouldDrain =
              wantsSprint &&
              !stamina.exhausted &&
              hasInput &&
              stamina.current > 0;

            if (curator.dialogue) {
              // Stop player movement during dialogue
              player.vx = 0;
              player.vy = 0;
            } else {
              const candybarMultiplier = candybarBoost.active ? 1.5 : 1.0;
              const accel = allowBoost
                ? player.accel * player.sprintMultiplier * candybarMultiplier
                : player.accel * candybarMultiplier;
              const maxSpeed = allowBoost
                ? player.maxSpeed * player.sprintMultiplier * candybarMultiplier
                : player.maxSpeed * candybarMultiplier;

              let ax = 0;
              let ay = 0;
              if (pressed('ArrowLeft') || pressed('KeyA')) ax -= accel;
              if (pressed('ArrowRight') || pressed('KeyD')) ax += accel;
              if (pressed('ArrowUp') || pressed('KeyW')) ay -= accel;
              if (pressed('ArrowDown') || pressed('KeyS')) ay += accel;

              player.vx += ax;
              player.vy += ay;

              if (ax === 0) player.vx *= player.friction;
              if (ay === 0) player.vy *= player.friction;

              const speed = Math.hypot(player.vx, player.vy);
              if (speed > maxSpeed) {
                const s = maxSpeed / speed;
                player.vx *= s;
                player.vy *= s;
              }

              player.x += player.vx;
              player.y += player.vy;
            }

            // Museum wall collision (keep player inside museum bounds)
            const playerRadius = player.width / 2;
            const wallThickness = museumTileSize;
            player.x = clamp(
              player.x,
              wallThickness + playerRadius,
              museumWorldWidth - wallThickness - playerRadius
            );
            player.y = clamp(
              player.y,
              wallThickness + playerRadius,
              museumWorldHeight - wallThickness - playerRadius
            );

            // Update camera - follow player horizontally, but keep museum at bottom
            camera.x += (player.x - camera.x) * camera.followLerp;
            // Only clamp if museum is larger than canvas (otherwise keep centered horizontally)
            if (museumWorldWidth > canvas.width) {
              camera.x = clamp(
                camera.x,
                canvas.width / 2,
                museumWorldWidth - canvas.width / 2
              );
            } else {
              // Museum is smaller than canvas - keep camera centered horizontally
              camera.x = museumWorldWidth / 2;
            }
            // Always keep museum at bottom of screen (don't follow player vertically)
            if (museumWorldHeight > canvas.height) {
              // Museum is larger than canvas - allow vertical scrolling but clamp
              camera.y += (player.y - camera.y) * camera.followLerp;
              camera.y = clamp(
                camera.y,
                canvas.height / 2,
                museumWorldHeight - canvas.height / 2
              );
            } else {
              // Museum is smaller than canvas - position at bottom middle
              // Keep camera at position that places museum at bottom
              camera.y = museumWorldHeight - canvas.height / 2;
            }
            camera.x = Math.round(camera.x);
            camera.y = Math.round(camera.y);

            // Check if player is near door (show prompt only when entering radius)
            const doorX = museum.doorCol * museumTileSize + museumTileSize / 2;
            const doorY = (museum.height - 1) * museumTileSize;
            const dx = player.x - doorX;
            const dy = player.y - doorY;
            const distToDoor = Math.sqrt(dx * dx + dy * dy);

            // Smaller activation radius (0.8 tiles)
            const doorActivationRadius = museumTileSize * 0.8;
            const wasNearDoor = museum.wasNearDoor || false;

            if (distToDoor < doorActivationRadius) {
              // Player is near door - show prompt only if we weren't near before
              if (!wasNearDoor) {
                museum.doorPrompt = true;
              }
              museum.wasNearDoor = true;
            } else {
              // Player moved away from door - reset tracking
              museum.wasNearDoor = false;
              // Don't hide prompt immediately - let it stay until player clicks or moves
            }

            // Resolve curator collision (separate function, like other NPCs)
            resolveCuratorCollision();

            // Update walking animation
            const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
            if (isMoving) {
              const animationMultiplier = allowBoost ? 1.25 : 0.75;
              walkAnimationFrame +=
                dt * 60 * walkAnimationSpeed * animationMultiplier;
            } else {
              walkAnimationFrame = 0;
            }

            // Stamina update
            if (shouldDrain) {
              stamina.current -= stamina.drainPerSecond * dt;
            } else {
              stamina.current += stamina.regenPerSecond * dt;
            }
            stamina.current = clamp(stamina.current, 0, stamina.max);

            if (stamina.current <= 0.0001) {
              stamina.exhausted = true;
            } else if (stamina.current >= stamina.max - 0.0001) {
              stamina.exhausted = false;
            }
          }

          // Only update player movement if inventory is closed, shop is closed, vending machine is closed, dialogue is not showing, tutorial is not active, crouch animation is not active, and minigame is not active
          // Also don't update if day/week has ended
          if (
            gameState === 'playing' &&
            !inventory.open &&
            !systemMessage.text &&
            !oldGuy.dialogue &&
            !tutorial.active &&
            !crouchAnimation.active &&
            !balancingMinigame.active &&
            !brushingMinigame.active &&
            !declarationMinigame.active &&
            !gameOver.active
          ) {
            const wantsSprint = pressed('ShiftLeft') || pressed('ShiftRight');

            // Decouple boost from draining so the bar can reach 0
            const hasInput =
              pressed('ArrowLeft') ||
              pressed('KeyA') ||
              pressed('ArrowRight') ||
              pressed('KeyD') ||
              pressed('ArrowUp') ||
              pressed('KeyW') ||
              pressed('ArrowDown') ||
              pressed('KeyS');
            const allowBoost =
              wantsSprint &&
              !stamina.exhausted &&
              stamina.current >= stamina.minToSprint;
            const shouldDrain =
              wantsSprint &&
              !stamina.exhausted &&
              hasInput &&
              stamina.current > 0;

            // Apply candybar boost (50% speed increase) if active
            const candybarMultiplier = candybarBoost.active ? 1.5 : 1.0;
            const accel = allowBoost
              ? player.accel * player.sprintMultiplier * candybarMultiplier
              : player.accel * candybarMultiplier;
            const maxSpeed = allowBoost
              ? player.maxSpeed * player.sprintMultiplier * candybarMultiplier
              : player.maxSpeed * candybarMultiplier;

            // Input axes
            let ax = 0;
            let ay = 0;
            if (pressed('ArrowLeft') || pressed('KeyA')) ax -= accel;
            if (pressed('ArrowRight') || pressed('KeyD')) ax += accel;
            if (pressed('ArrowUp') || pressed('KeyW')) ay -= accel;
            if (pressed('ArrowDown') || pressed('KeyS')) ay += accel;

            player.vx += ax;
            player.vy += ay;

            // Apply friction only when no input along that axis to keep controls snappy
            if (ax === 0) player.vx *= player.friction;
            if (ay === 0) player.vy *= player.friction;

            // Cap speed
            const speed = Math.hypot(player.vx, player.vy);
            if (speed > maxSpeed) {
              const s = maxSpeed / speed;
              player.vx *= s;
              player.vy *= s;
            }

            player.x += player.vx;
            player.y += player.vy;

            resolveTreeCollisions();
            resolveOldGuyCollision();
            resolveJosephCollision();
            resolveRadarCollision(); // Radar has collision too

            // Update walking animation with speed based on sprinting
            const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
            if (isMoving) {
              // 75% slower when walking, 125% faster when sprinting
              const animationMultiplier = allowBoost ? 1.25 : 0.75;
              walkAnimationFrame +=
                dt * 60 * walkAnimationSpeed * animationMultiplier; // Normalize to 60fps
            } else {
              walkAnimationFrame = 0; // Reset to idle when not moving
            }

            // Stamina update
            if (shouldDrain) {
              stamina.current -= stamina.drainPerSecond * dt;
            } else {
              stamina.current += stamina.regenPerSecond * dt;
            }
            stamina.current = clamp(stamina.current, 0, stamina.max);

            // Exhaustion rules: lock sprint when empty until fully refilled
            if (stamina.current <= 0.0001) {
              stamina.exhausted = true;
            } else if (stamina.current >= stamina.max - 0.0001) {
              stamina.exhausted = false;
            }

            // World bounds (keep player fully inside)
            const halfW = player.width / 2;
            const halfH = player.height / 2;
            player.x = clamp(player.x, halfW, world.width - halfW);
            player.y = clamp(player.y, halfH, world.height - halfH);
          }

          // Clear keyJustPressed at end of frame
          Object.keys(keyJustPressed).forEach(
            (key) => (keyJustPressed[key] = false)
          );

          // Camera follow (smoothly move camera toward player)
          const targetX = player.x;
          const targetY = player.y;
          camera.x += (targetX - camera.x) * camera.followLerp;
          camera.y += (targetY - camera.y) * camera.followLerp;

          // Clamp camera so it doesn't show outside world
          const halfViewW = canvas.width / 2;
          const halfViewH = canvas.height / 2;
          camera.x = clamp(camera.x, halfViewW, world.width - halfViewW);
          camera.y = clamp(camera.y, halfViewH, world.height - halfViewH);

          // Round camera to integer pixels to prevent sub-pixel jitter
          // This ensures the translate() call produces consistent pixel-aligned results
          camera.x = Math.round(camera.x);
          camera.y = Math.round(camera.y);

          // Update crouch animation
          if (crouchAnimation.active) {
            const dt = dtMs / 1000; // Convert to seconds
            // Apply candybar boost: 50% faster digging = 50% less duration
            const effectiveDuration = candybarBoost.active
              ? crouchAnimation.duration * 0.5
              : crouchAnimation.duration;
            crouchAnimation.timer += dt;

            // Create particles during animation (small dirt particles)
            if (crouchAnimation.timer < effectiveDuration) {
              // Emit particles continuously during animation
              const particleEmitRate = 25; // particles per second (reduced from 30)
              const maxParticles = 50; // Limit total particles for performance
              const particlesToEmit = Math.min(
                particleEmitRate * dt,
                maxParticles - crouchAnimation.particles.length
              );
              for (let i = 0; i < particlesToEmit; i++) {
                // Convert player world position to screen position for particles
                const screenX = player.x - camera.x + canvas.width / 2;
                const screenY = player.y - camera.y + canvas.height / 2;

                crouchAnimation.particles.push({
                  x: screenX + (Math.random() - 0.5) * 20,
                  y: screenY + (Math.random() - 0.5) * 20,
                  vx: (Math.random() - 0.5) * 60,
                  vy: (Math.random() - 0.5) * 60 - 20, // Slight upward bias
                  life: 1.0,
                  size: Math.random() * 2 + 1,
                });
              }
            }

            // Update particles (optimized: filter instead of splice)
            const aliveParticles = [];
            for (let i = 0; i < crouchAnimation.particles.length; i++) {
              const p = crouchAnimation.particles[i];
              p.x += p.vx * dt;
              p.y += p.vy * dt;
              p.vy += 80 * dt; // Gravity
              p.life -= dt * 2; // Fade out over 0.5 seconds

              // Keep alive particles
              if (p.life > 0) {
                aliveParticles.push(p);
              }
            }
            crouchAnimation.particles = aliveParticles;

            // After animation duration, start the pending minigame (if any) or just end animation
            if (crouchAnimation.timer >= effectiveDuration) {
              if (crouchAnimation.pendingMinigame) {
                startPendingMinigame();
              } else {
                // Just end the animation if no minigame is pending
                crouchAnimation.active = false;
                crouchAnimation.timer = 0;
                crouchAnimation.pendingMinigame = null;
                crouchAnimation.particles = [];
              }
            }
          }

          updateBalancingMinigame(dtMs);
          updateBrushingMinigame(dtMs);
          updateDeclarationMinigame(dtMs);
          updateRadar(dtMs);
        }

        function drawGrid() {
          // Performance: Only draw grid if visible (optional - can be disabled entirely if still laggy)
          // For now, keeping it but optimizing viewport calculations
          const step = 50;
          ctx.save();
          ctx.lineWidth = 1;

          // Viewport culling: only draw grid lines visible on screen
          const halfCanvasW = canvas.width / 2;
          const halfCanvasH = canvas.height / 2;
          const viewLeft = camera.x - halfCanvasW;
          const viewTop = camera.y - halfCanvasH;
          const viewRight = camera.x + halfCanvasW;
          const viewBottom = camera.y + halfCanvasH;

          const startX = Math.max(0, Math.floor(viewLeft / step) * step);
          const endX = Math.min(
            world.width,
            Math.ceil(viewRight / step) * step
          );
          const startY = Math.max(0, Math.floor(viewTop / step) * step);
          const endY = Math.min(
            world.height,
            Math.ceil(viewBottom / step) * step
          );

          // Batch strokes by color to reduce state changes
          for (let x = startX; x <= endX; x += step) {
            ctx.strokeStyle =
              x % 200 === 0 ? 'rgba(139,111,71,0.18)' : 'rgba(139,111,71,0.08)'; // Brown grid
            ctx.beginPath();
            ctx.moveTo(x + 0.5, viewTop);
            ctx.lineTo(x + 0.5, viewBottom);
            ctx.stroke();
          }
          for (let y = startY; y <= endY; y += step) {
            ctx.strokeStyle =
              y % 200 === 0 ? 'rgba(139,111,71,0.18)' : 'rgba(139,111,71,0.08)'; // Brown grid
            ctx.beginPath();
            ctx.moveTo(viewLeft, y + 0.5);
            ctx.lineTo(viewRight, y + 0.5);
            ctx.stroke();
          }
          ctx.restore();
        }

        function drawTiles() {
          // No ctx.save()/restore() here - transform is already applied in render()
          // Viewport culling: only draw tiles visible on screen
          const viewLeft = camera.x - canvas.width / 2;
          const viewTop = camera.y - canvas.height / 2;
          const viewRight = camera.x + canvas.width / 2;
          const viewBottom = camera.y + canvas.height / 2;

          const startRow = Math.max(0, Math.floor(viewTop / tileSize) - 1);
          const endRow = Math.min(
            tileRows - 1,
            Math.ceil(viewBottom / tileSize) + 1
          );
          const startCol = Math.max(0, Math.floor(viewLeft / tileSize) - 1);
          const endCol = Math.min(
            tileCols - 1,
            Math.ceil(viewRight / tileSize) + 1
          );

          for (let row = startRow; row <= endRow; row++) {
            for (let col = startCol; col <= endCol; col++) {
              const tile = tileMap[row][col];
              if (tile && tile.canvas) {
                // Draw tiles at exact integer world positions
                // Tile canvas is 33x33 (tileSize + 1) with 1px overlap on right and bottom
                // Tiles drawn at col * tileSize will naturally overlap:
                // - Tile at col=0: drawn at x=0, covers x=0 to x=32 (33px)
                // - Tile at col=1: drawn at x=32, covers x=32 to x=64 (33px)
                // - Overlap at x=32 ensures seamless edges
                // World positions are always multiples of tileSize (32), so they're integers
                // The camera transform (already applied) converts these to screen coordinates
                // Camera position is rounded, so screen positions should align to pixel boundaries
                const tileX = col * tileSize;
                const tileY = row * tileSize;
                ctx.drawImage(tile.canvas, tileX, tileY);
              }
            }
          }
        }

        function resolveTreeCollisions() {
          const playerRadius = player.radius; // Use cached radius
          const maxCheckDistance = 150;
          const maxCheckDistanceSq = maxCheckDistance * maxCheckDistance;

          // Early exit optimization: use squared distances to avoid sqrt
          for (let i = 0; i < flora.trees.length; i++) {
            const tree = flora.trees[i];
            const dx = player.x - tree.x;
            const dy = player.y - tree.y;
            const distSq = dx * dx + dy * dy;

            // Quick distance check first (no sqrt needed)
            if (distSq > maxCheckDistanceSq) continue;

            const treeRadius = tree.colliderRadius;
            const minDist = treeRadius + playerRadius;
            const minDistSq = minDist * minDist;

            if (distSq < minDistSq && distSq > 0) {
              // Avoid division by zero
              const dist = Math.sqrt(distSq);
              const overlap = minDist - dist;
              const invDist = 1 / dist; // Cache inverse distance
              player.x += dx * invDist * overlap;
              player.y += dy * invDist * overlap;
            }
          }
        }

        function resolveOldGuyCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - oldGuy.x;
          const dy = player.y - oldGuy.y;
          const distSq = dx * dx + dy * dy;
          const minDist = oldGuy.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        function resolveJosephCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - joseph.x;
          const dy = player.y - joseph.y;
          const distSq = dx * dx + dy * dy;
          const minDist = joseph.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        // Radar collision (radar is positioned next to Joseph)
        function resolveRadarCollision() {
          const playerRadius = player.radius;
          const radarSpriteSize = 43; // Same size as Joseph
          const radarOffsetX = 50; // Position to the right of Joseph
          const radarX = joseph.x + radarOffsetX;
          const radarY = joseph.y;
          const radarRadius = radarSpriteSize / 2;

          const dx = player.x - radarX;
          const dy = player.y - radarY;
          const distSq = dx * dx + dy * dy;
          const minDist = radarRadius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist;
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        function resolveCuratorCollision() {
          const playerRadius = player.radius; // Use cached radius
          const dx = player.x - curator.x;
          const dy = player.y - curator.y;
          const distSq = dx * dx + dy * dy;
          const minDist = curator.radius + playerRadius;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }

        function advanceJosephDialogue() {
          // Progress through Joseph's dialogue sequence
          // If already completed dialogue (stage 10), just close
          if (joseph.dialogueStage >= 10) {
            joseph.dialogue = null;
            joseph.dialogueStage = 0;
            return;
          }

          joseph.dialogueStage++;

          if (joseph.dialogueStage === 1) {
            joseph.dialogue =
              'Did you know that radars can detect hidden things underground?';
          } else if (joseph.dialogueStage === 2) {
            joseph.dialogue =
              'This one here is a GPR, or Ground penetrating radar.';
          } else if (joseph.dialogueStage === 3) {
            joseph.dialogue =
              'It works by emitting radiowaves that bounce off objects, approximating their location.';
          } else if (joseph.dialogueStage === 4) {
            joseph.dialogue =
              'Since I dont have much use for this radar, you can have it- for a price.';
          } else if (joseph.dialogueStage === 5) {
            joseph.dialogue =
              'Give me  a artifact using ths radar and you can keep it fo good!';
          } else if (joseph.dialogueStage >= 6) {
            // Give radar to player and activate quest
            if (!joseph.hasGivenRadar) {
              // Add radar to inventory (equipment slot)
              inventory.equipment = {
                name: 'Radar',
                sprite: radarSprite,
                tier: 0, // Not a shovel tier
              };
              radar.active = true;
              quests.findArtifactWithRadar.active = true;
              joseph.hasGivenRadar = true;
            }
            joseph.dialogue = null;
            joseph.dialogueStage = 0;
          }
        }

        function advanceOldGuyDialogue() {
          // Progress through the Old Guy's dialogue sequence
          if (!oldGuy.hasCompletedIntro) {
            // Initial dialogue sequence
            oldGuy.dialogueStage++;

            if (oldGuy.dialogueStage === 1) {
              oldGuy.dialogue =
                'Well, here we are. The newly discovered "Battle of the hills" historical site!';
            } else if (oldGuy.dialogueStage === 2) {
              oldGuy.dialogue =
                'It is time for you to uncover the history of this place!';
            } else if (oldGuy.dialogueStage === 3) {
              oldGuy.dialogue = 'Are you ready?';
            } else if (oldGuy.dialogueStage === 4) {
              oldGuy.dialogue = 'Dig up those holes with Spacebar!';
            } else if (oldGuy.dialogueStage >= 5) {
              // Completed the intro sequence
              oldGuy.dialogue = null;
              oldGuy.hasCompletedIntro = true;
              oldGuy.dialogueStage = 0;
            }
          } else {
            // After intro is complete, just close the "hurry up" message
            oldGuy.dialogue = null;
          }
        }

        function advanceCuratorDialogue() {
          // Curator dialogue advances through stages
          curator.dialogueStage++;
          const hasArtifacts = inventory.slots.some((slot) => slot !== null);

          if (hasArtifacts) {
            // Player has artifacts - three stages (0, 1, 2)
            if (curator.dialogueStage === 1) {
              curator.dialogue =
                'Press "E" to go into build mode, there you can create display cases for the things you\'ve dug up.';
            } else if (curator.dialogueStage >= 2) {
              curator.dialogue = null;
              curator.dialogueStage = 0;
            }
          } else {
            // Player has no artifacts - three stages (0, 1, 2)
            if (curator.dialogueStage === 1) {
              curator.dialogue =
                "Dig up the X's with your shovel to get artifacts!";
            } else if (curator.dialogueStage >= 2) {
              curator.dialogue = null;
              curator.dialogueStage = 0;
            }
          }
        }

        function handleInteraction() {
          // Don't interact if inventory is open
          if (inventory.open) {
            return;
          }

          // Don't start new dialogue if one is already showing
          if (oldGuy.dialogue || joseph.dialogue || curator.dialogue) {
            return;
          }

          const playerRadius = player.radius; // Use cached radius

          // Check if player is touching curator (collision-based, only in museum state)
          // Completely rewritten - check curator FIRST, exactly like shopkeeper pattern
          if (gameState === 'museum') {
            // Calculate distance to curator
            const dx = player.x - curator.x;
            const dy = player.y - curator.y;
            const distSq = dx * dx + dy * dy;
            const minDist = curator.radius + playerRadius;
            const minDistSq = minDist * minDist;

            // Allow interaction when very close (within collision distance + small buffer)
            if (distSq <= minDistSq * 1.2) {
              // Check if player has any artifacts
              const hasArtifacts = inventory.slots.some(
                (slot) => slot !== null
              );

              if (hasArtifacts) {
                curator.dialogue =
                  'Hello there! I see you have some artifacts.';
                curator.dialogueStage = 1;
              } else {
                curator.dialogue =
                  "Looks like you don't have anything to put in your museum.";
                curator.dialogueStage = 1;
              }
              curator.dialogueTimer = 0; // Don't auto-close, wait for Spacebar press
              // Kill momentum when opening dialogue
              player.vx = 0;
              player.vy = 0;
              return;
            }
            // If in museum state but not close to curator, return (no other NPCs in museum)
            return;
          }

          // Check if player is touching old guy (collision-based)
          let dx = player.x - oldGuy.x;
          let dy = player.y - oldGuy.y;
          let distSq = dx * dx + dy * dy;
          let minDist = oldGuy.radius + playerRadius;
          let minDistSq = minDist * minDist;

          // Allow interaction when very close (within collision distance + small buffer)
          if (distSq <= minDistSq * 1.2) {
            // Set dialogue based on whether intro is completed
            if (!oldGuy.hasCompletedIntro) {
              // Start the intro dialogue sequence
              oldGuy.dialogueStage = 0;
              oldGuy.dialogue = 'Hello there!';
            } else {
              // Show the "hurry up" message after intro is done
              oldGuy.dialogue =
                'What are you waiting for? Get going! Dig those holes with Spacebar!';
            }
            // Kill momentum when opening dialogue
            player.vx = 0;
            player.vy = 0;
            return;
          }

          // Check if player is touching Joseph (collision-based)
          // Increase interaction distance to make it easier to talk to Joseph
          dx = player.x - joseph.x;
          dy = player.y - joseph.y;
          distSq = dx * dx + dy * dy;
          minDist = joseph.radius + playerRadius;
          minDistSq = minDist * minDist;

          // Use larger interaction distance (2.0x instead of 1.2x) to make it easier to interact
          if (distSq <= minDistSq * 2.0) {
            // Start Joseph dialogue sequence if not completed
            if (!joseph.hasGivenRadar) {
              joseph.dialogueStage = 0;
              joseph.dialogue =
                'Did you know that radars can detect hidden things underground?';
            } else {
              // Already gave radar, just acknowledge
              joseph.dialogue = 'Good luck finding artifacts with that radar!';
              joseph.dialogueStage = 10; // High number so it closes quickly
            }
            // Kill momentum when opening dialogue
            player.vx = 0;
            player.vy = 0;
            return;
          }

          // Check if player is on a tile (any tile triggers crouch animation)
          // Only allow digging in 'playing' state (not in museum or other states)
          if (gameState !== 'playing') {
            // Still allow Space for dialogue/interactions in other states
            return;
          }

          const col = Math.floor(player.x / tileSize);
          const row = Math.floor(player.y / tileSize);

          if (row >= 0 && row < tileRows && col >= 0 && col < tileCols) {
            const tile = tileMap[row][col];
            if (tile) {
              // Start crouch animation on any tile (prevents spamming)
              if (!crouchAnimation.active) {
                crouchAnimation.active = true;
                crouchAnimation.timer = 0;
                crouchAnimation.particles = []; // Initialize particles array
                // Only store minigame if on red X or secret X tile, otherwise just play animation
                if (tile.name === 'redX' || tile.name === 'secretX') {
                  // Store which minigame to start after animation
                  // Probabilities: 40% balancing (pots), 40% declaration (typo), 20% brushing
                  const minigameRoll = Math.random();
                  if (minigameRoll < 0.4) {
                    crouchAnimation.pendingMinigame = 'balancing';
                  } else if (minigameRoll < 0.8) {
                    crouchAnimation.pendingMinigame = 'declaration';
                  } else {
                    crouchAnimation.pendingMinigame = 'brushing';
                  }
                  // Store whether this is a secret X tile for later reward multiplier
                  crouchAnimation.isSecretX = tile.name === 'secretX';
                } else {
                  // No minigame for other tiles
                  crouchAnimation.pendingMinigame = null;
                  crouchAnimation.isSecretX = false;
                }
                // Stop player movement during crouch animation
                player.vx = 0;
                player.vy = 0;
              }
              return;
            }
          }
        }

        // Helper function to add items to inventory when minigames complete
        // This function finds the first empty slot and adds the item there
        function addItemToInventory(itemName, sprite) {
          // Find first empty inventory slot
          for (let i = 0; i < inventory.slots.length; i++) {
            if (inventory.slots[i] === null) {
              // Empty slot found, add the item
              inventory.slots[i] = {
                name: itemName,
                sprite: sprite,
              };
              // Check if this is an artifact and quest is active
              if (
                quests.findArtifactWithRadar.active &&
                !quests.findArtifactWithRadar.completed &&
                radar.active
              ) {
                // Player found an artifact using the radar - complete quest!
                quests.findArtifactWithRadar.completed = true;
                quests.findArtifactWithRadar.active = false; // Quest complete, no longer show
              }
              return true; // Successfully added
            }
          }
          // No empty slots available
          return false; // Inventory full
        }

        // Function to give minigame reward (randomly chooses artifact)
        function giveMinigameReward() {
          // Randomly choose artifact: Rusty Nails (50%), Bullets (25%), Grapeshot (25%)
          const roll = Math.random();

          if (roll < 0.5) {
            // 50% chance - Rusty Nails
            if (
              rustyNailsSprite.complete &&
              rustyNailsSprite.naturalWidth > 0
            ) {
              return addItemToInventory('Rusty Nails', rustyNailsSprite);
            }
          } else if (roll < 0.75) {
            // 25% chance - Bullets
            if (bulletsSprite.complete && bulletsSprite.naturalWidth > 0) {
              return addItemToInventory('Bullets', bulletsSprite);
            }
          } else {
            // 25% chance - Grapeshot
            if (grapeshotSprite.complete && grapeshotSprite.naturalWidth > 0) {
              return addItemToInventory('Grapeshot', grapeshotSprite);
            }
          }
          return false; // Failed to add reward (inventory full or sprite not loaded)
        }

        // Function to start the actual minigame after crouch animation completes
        function startPendingMinigame() {
          const col = Math.floor(player.x / tileSize);
          const row = Math.floor(player.y / tileSize);

          if (crouchAnimation.pendingMinigame === 'balancing') {
            // Start Balancing minigame
            balancingMinigame.active = true;
            balancingMinigame.tileRow = row;
            balancingMinigame.tileCol = col;
            balancingMinigame.isSecretX = crouchAnimation.isSecretX;
            balancingMinigame.potAngle = 0;
            balancingMinigame.potAngularVelocity = 0;
            balancingMinigame.timeRemaining = 15;
            balancingMinigame.breaking = false;
            balancingMinigame.breakTimer = 0;
            balancingMinigame.pieces = [];
            // Initialize stick position to center of screen (lowered down)
            // Ensure canvas dimensions are valid
            const centerX = canvas && canvas.width ? canvas.width / 2 : 400;
            const centerY = canvas && canvas.height ? canvas.height / 2 : 300;
            balancingMinigame.stickX = centerX;
            balancingMinigame.stickY = centerY; // Will be lowered by 40px in render
            // Randomly select pot type (equal chance for each)
            const potTypeRoll = Math.random();
            if (potTypeRoll < 0.333) {
              balancingMinigame.potType = 'regular';
            } else if (potTypeRoll < 0.666) {
              balancingMinigame.potType = 'tall';
            } else {
              balancingMinigame.potType = 'short';
            }
            // Ensure potAngle and other values are initialized
            if (balancingMinigame.potAngle === undefined) {
              balancingMinigame.potAngle = 0;
            }
            if (balancingMinigame.potAngularVelocity === undefined) {
              balancingMinigame.potAngularVelocity = 0;
            }
          } else if (crouchAnimation.pendingMinigame === 'brushing') {
            // Start Brushing minigame
            brushingMinigame.active = true;
            brushingMinigame.tileRow = row;
            brushingMinigame.tileCol = col;
            brushingMinigame.isSecretX = crouchAnimation.isSecretX;
            brushingMinigame.dirtLevel = 1.0;
            brushingMinigame.redness = 0;
            brushingMinigame.timeHoldingSpace = 0;
            // Check if player has speed brush (equipment slot only)
            const hasSpeedBrush = inventory.speedBrush;
            // Speed brush: red trigger time is 2-4 seconds (instead of 3-8)
            if (hasSpeedBrush) {
              brushingMinigame.redTriggerTime = 2 + Math.random() * 2; // 2-4 seconds
              brushingMinigame.perfectReleaseWindow = 0.75; // 0.75 seconds (instead of 0.5)
            } else {
              brushingMinigame.redTriggerTime = 3 + Math.random() * 5; // 3-8 seconds
              brushingMinigame.perfectReleaseWindow = 0.5; // 0.5 seconds
            }
            brushingMinigame.timeSinceRed = 0;
            brushingMinigame.particles = [];
            brushingMinigame.completed = false;
            brushingMinigame.broken = false;
            // Initialize brush position to center of screen (slightly above dirt)
            brushingMinigame.brushX = canvas.width / 2;
            brushingMinigame.brushY = canvas.height / 2 - 40; // Slightly above center
            brushingMinigame.brushOffset = 0;
            brushingMinigame.brushDirection = 1;
          } else if (crouchAnimation.pendingMinigame === 'declaration') {
            // Start Declaration of Independence minigame
            declarationMinigame.active = true;
            declarationMinigame.tileRow = row;
            declarationMinigame.tileCol = col;
            declarationMinigame.isSecretX = crouchAnimation.isSecretX;
            declarationMinigame.answered = false;

            // 50% chance the test excerpt is fake (has typos)
            declarationMinigame.isFake = Math.random() < 0.5;

            if (declarationMinigame.isFake) {
              // Create fake version with random typo
              // Available typos: "sertain", "Celf-Evident", "Craeted", "Unaliable", "Persuit"
              const typoOptions = [
                { from: 'certain', to: 'sertain' },
                { from: 'self-evident', to: 'Celf-Evident' },
                { from: 'created', to: 'Craeted' },
                { from: 'unalienable', to: 'Unaliable' },
                { from: 'pursuit', to: 'Persuit' },
              ];
              // Randomly pick one typo
              const selectedTypo =
                typoOptions[Math.floor(Math.random() * typoOptions.length)];
              declarationMinigame.testExcerpt =
                declarationMinigame.realExcerpt.replace(
                  selectedTypo.from,
                  selectedTypo.to
                );
            } else {
              // Real version (no typos)
              declarationMinigame.testExcerpt = declarationMinigame.realExcerpt;
            }
          }

          // Reset crouch animation
          crouchAnimation.active = false;
          crouchAnimation.timer = 0;
          crouchAnimation.pendingMinigame = null;
        }

        function updateBalancingMinigame(dtMs) {
          if (!balancingMinigame.active) return;

          const dt = dtMs / 1000; // Convert to seconds

          // Player input affects angular velocity
          const leftInput = pressed('ArrowLeft') || pressed('KeyA');
          const rightInput = pressed('ArrowRight') || pressed('KeyD');

          // Get pot type modifiers
          // Tall pot: more susceptible to gravity and balancing (harder)
          // Short pot: less susceptible to gravity and balancing (easier)
          // Regular pot: normal difficulty
          let gravityMultiplier = 1.0;
          let inputMultiplier = 1.0;
          let teeteringMultiplier = 1.0;

          if (balancingMinigame.potType === 'tall') {
            gravityMultiplier = 1.2; // 20% more gravity (reduced from 1.5)
            inputMultiplier = 0.85; // 15% less effective input (reduced from 0.7)
            teeteringMultiplier = 1.2; // 20% more teetering (reduced from 1.4)
          } else if (balancingMinigame.potType === 'short') {
            gravityMultiplier = 0.6; // 40% less gravity
            inputMultiplier = 1.3; // 30% more effective input
            teeteringMultiplier = 0.7; // 30% less teetering
          }

          if (leftInput && !rightInput) {
            balancingMinigame.potAngularVelocity -= 0.2 * dt * inputMultiplier; // Lean left
          } else if (rightInput && !leftInput) {
            balancingMinigame.potAngularVelocity += 0.2 * dt * inputMultiplier; // Lean right
          }

          // Natural physics: pot wants to fall (very strong teetering force)
          const baseGravity = 0.6; // How fast it wants to fall (very strong - requires constant input)
          const gravity = baseGravity * gravityMultiplier;
          const damping = 0.985; // Less friction to allow stronger movement

          // Apply gravity based on current angle (very strong)
          balancingMinigame.potAngularVelocity +=
            Math.sin(balancingMinigame.potAngle) * gravity * dt;

          // Add constant teetering force to make it much harder
          balancingMinigame.potAngularVelocity +=
            Math.sin(balancingMinigame.potAngle * 2) *
            0.18 *
            dt *
            teeteringMultiplier;

          // Add additional random-like teetering force
          balancingMinigame.potAngularVelocity +=
            Math.sin(balancingMinigame.potAngle * 3 + Date.now() * 0.001) *
            0.12 *
            dt *
            teeteringMultiplier;

          // Apply damping
          balancingMinigame.potAngularVelocity *= Math.pow(damping, dt * 60); // Normalize to 60fps

          // Update angle
          balancingMinigame.potAngle +=
            balancingMinigame.potAngularVelocity * dt;

          // Check if pot fell off (angle too extreme - make it easier to lose)
          const maxAngle = Math.PI / 4.5; // About 40 degrees (easier to lose)
          if (
            Math.abs(balancingMinigame.potAngle) > maxAngle &&
            !balancingMinigame.breaking
          ) {
            // Start breaking animation
            balancingMinigame.breaking = true;
            balancingMinigame.breakTimer = 0.5; // 0.5 seconds of breaking animation

            // Create pot pieces flying off
            const potSize = 100;
            const stickX = balancingMinigame.stickX;
            const stickTipY = balancingMinigame.stickY - 25;
            const potContactY = stickTipY + 5; // Match the pot position from drawing code (slightly lower)
            const potCenterX = stickX;
            const potCenterY = potContactY - potSize / 2;

            // Create 8-12 pieces
            const numPieces = 10;
            balancingMinigame.pieces = [];
            for (let i = 0; i < numPieces; i++) {
              const angle =
                (Math.PI * 2 * i) / numPieces + balancingMinigame.potAngle;
              const speed = 2 + Math.random() * 3;
              balancingMinigame.pieces.push({
                x: potCenterX,
                y: potCenterY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 1, // Slight upward bias
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.3,
                size: 8 + Math.random() * 12,
                opacity: 1.0,
              });
            }
          }

          // Update breaking animation
          if (balancingMinigame.breaking) {
            balancingMinigame.breakTimer -= dt;

            // Update pieces
            for (let i = 0; i < balancingMinigame.pieces.length; i++) {
              const piece = balancingMinigame.pieces[i];
              piece.x += piece.vx * dt * 60;
              piece.y += piece.vy * dt * 60;
              piece.vy += 0.5 * dt * 60; // Gravity
              piece.rotation += piece.rotationSpeed * dt * 60;
              piece.opacity -= dt * 2; // Fade out
            }

            // End minigame after breaking animation
            if (balancingMinigame.breakTimer <= 0) {
              // Failed - give base reward with shovel multiplier and secret X multiplier
              let multiplier = 1.0;
              if (inventory.equipment) {
                if (inventory.equipment.tier === 1)
                  multiplier = 1.5; // Simple shovel
                else if (inventory.equipment.tier === 2)
                  multiplier = 2.0; // Iron shovel
                else if (inventory.equipment.tier === 3) multiplier = 2.5; // Steel shovel
              }
              // Apply 1.5x multiplier for secret X tiles
              if (balancingMinigame.isSecretX) {
                multiplier *= 1.5;
              }
              const grassDef = tileDefinitions.find(
                (def) => def.name === 'grass'
              );
              if (
                grassDef &&
                balancingMinigame.tileRow !== null &&
                balancingMinigame.tileCol !== null
              ) {
                tileMap[balancingMinigame.tileRow][balancingMinigame.tileCol] =
                  {
                    name: grassDef.name,
                    canvas: createTileCanvas(grassDef.draw),
                  };
                // Remove from discovered secret X list if it was a secret X tile
                radar.discoveredSecretX = radar.discoveredSecretX.filter(
                  (pos) =>
                    !(
                      pos.row === balancingMinigame.tileRow &&
                      pos.col === balancingMinigame.tileCol
                    )
                );
              }
              balancingMinigame.active = false;
              balancingMinigame.breaking = false;
              balancingMinigame.pieces = [];
              return;
            }
          }

          // Update timer
          balancingMinigame.timeRemaining -= dt;

          // Check if succeeded (15 seconds passed)
          if (balancingMinigame.timeRemaining <= 0) {
            // Success - give 3x reward with shovel multiplier and secret X multiplier
            let multiplier = 3.0; // Base success multiplier (3x)
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier = 4.5; // Simple shovel: 1.5x * 3 = 4.5x
              else if (inventory.equipment.tier === 2)
                multiplier = 6.0; // Iron shovel: 2x * 3 = 6x
              else if (inventory.equipment.tier === 3) multiplier = 7.5; // Steel shovel: 2.5x * 3 = 7.5x
            }
            // Apply 1.5x multiplier for secret X tiles
            if (balancingMinigame.isSecretX) {
              multiplier *= 1.5;
            }

            // Give minigame reward (bullets or grapeshot)
            giveMinigameReward();

            const grassDef = tileDefinitions.find(
              (def) => def.name === 'grass'
            );
            if (
              grassDef &&
              balancingMinigame.tileRow !== null &&
              balancingMinigame.tileCol !== null
            ) {
              tileMap[balancingMinigame.tileRow][balancingMinigame.tileCol] = {
                name: grassDef.name,
                canvas: createTileCanvas(grassDef.draw),
              };
              // Remove from discovered secret X list if it was a secret X tile
              radar.discoveredSecretX = radar.discoveredSecretX.filter(
                (pos) =>
                  !(
                    pos.row === balancingMinigame.tileRow &&
                    pos.col === balancingMinigame.tileCol
                  )
              );
            }
            balancingMinigame.active = false;
          }
        }

        function updateBrushingMinigame(dtMs) {
          if (!brushingMinigame.active) return;

          const dt = dtMs / 1000; // Convert to seconds
          const spacePressed = pressed('Space');

          // Animate brush back and forth when spacebar is held
          if (spacePressed) {
            // Track time holding space
            brushingMinigame.timeHoldingSpace += dt;

            // Animate brush moving back and forth across the dirt
            const brushSpeed = 200; // pixels per second (doubled from 100)
            brushingMinigame.brushOffset +=
              brushSpeed * dt * brushingMinigame.brushDirection;

            // Reverse direction when reaching edges (60 pixels from center)
            const maxOffset = 60;
            if (brushingMinigame.brushOffset >= maxOffset) {
              brushingMinigame.brushOffset = maxOffset;
              brushingMinigame.brushDirection = -1; // Move left
            } else if (brushingMinigame.brushOffset <= -maxOffset) {
              brushingMinigame.brushOffset = -maxOffset;
              brushingMinigame.brushDirection = 1; // Move right
            }

            // Spawn dirt particles while brushing (only if there's still dirt)
            if (brushingMinigame.dirtLevel > 0 && Math.random() < 0.3) {
              const centerX = canvas.width / 2;
              const centerY = canvas.height / 2;
              brushingMinigame.particles.push({
                x:
                  centerX +
                  brushingMinigame.brushOffset +
                  (Math.random() - 0.5) * 30,
                y: centerY + (Math.random() - 0.5) * 30,
                vx:
                  (Math.random() - 0.5) * 100 +
                  brushingMinigame.brushDirection * 30,
                vy: (Math.random() - 0.5) * 100 - 30, // Fly upward
                life: 1.0, // 0 = dead, 1.0 = fresh
                size: Math.random() * 3 + 2,
              });
            }

            // Brushing reduces dirt level (makes it cleaner)
            brushingMinigame.dirtLevel -= 0.2 * dt;
            brushingMinigame.dirtLevel = Math.max(
              0,
              brushingMinigame.dirtLevel
            );

            // After at least 5 seconds, dirt is cleaned
            if (brushingMinigame.timeHoldingSpace >= 5.0) {
              // Dirt is now clean
              brushingMinigame.dirtLevel = 0;

              // After the random trigger time (3-8 seconds), start red gradient transition
              if (
                brushingMinigame.timeHoldingSpace >=
                  brushingMinigame.redTriggerTime &&
                brushingMinigame.redness < 1.0
              ) {
                // Gradually increase redness over 1 second
                brushingMinigame.redness +=
                  dt / brushingMinigame.redTransitionTime;
                brushingMinigame.redness = Math.min(
                  1.0,
                  brushingMinigame.redness
                );
              }

              // Track time since turning red (only after fully red)
              if (brushingMinigame.redness >= 1.0) {
                brushingMinigame.timeSinceRed += dt;

                // If holding space too long after fully red, you break it (lose)
                if (
                  brushingMinigame.timeSinceRed >
                    brushingMinigame.perfectReleaseWindow &&
                  !brushingMinigame.broken
                ) {
                  brushingMinigame.broken = true;
                }
              }
            }
          } else {
            // When not brushing, reset time counter
            brushingMinigame.timeHoldingSpace = 0;

            // Reset brush position to center when not holding space
            brushingMinigame.brushOffset = 0;
            brushingMinigame.brushDirection = 1;

            // If dirt is clean and red, releasing in the perfect window = success!
            if (
              brushingMinigame.dirtLevel <= 0 &&
              brushingMinigame.redness > 0 &&
              !brushingMinigame.completed &&
              !brushingMinigame.broken
            ) {
              // Check if released within the perfect timing window
              if (
                brushingMinigame.timeSinceRed <=
                brushingMinigame.perfectReleaseWindow
              ) {
                brushingMinigame.completed = true; // PERFECT! Maximum reward
              } else {
                brushingMinigame.broken = true; // Missed the window, failed
              }
            }

            // Reset redness when not brushing (dirt returns to normal)
            brushingMinigame.redness = 0;
            brushingMinigame.timeSinceRed = 0;

            // Dirt slowly returns if not fully cleaned
            if (
              brushingMinigame.dirtLevel < 1.0 &&
              !brushingMinigame.completed &&
              !brushingMinigame.broken
            ) {
              brushingMinigame.dirtLevel += 0.15 * dt;
              brushingMinigame.dirtLevel = Math.min(
                1.0,
                brushingMinigame.dirtLevel
              );
            }
          }

          // Update particles
          for (let i = brushingMinigame.particles.length - 1; i >= 0; i--) {
            const p = brushingMinigame.particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 100 * dt; // Gravity
            p.life -= dt * 2; // Fade out over 0.5 seconds

            // Remove dead particles
            if (p.life <= 0) {
              brushingMinigame.particles.splice(i, 1);
            }
          }

          // End minigame if completed or broken
          if (brushingMinigame.completed || brushingMinigame.broken) {
            // Give reward based on performance
            let multiplier = brushingMinigame.completed ? 3.0 : 1.0; // 3x for perfect timing, 1x for failure
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier *= 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2)
                multiplier *= 2.0; // Iron shovel
              else if (inventory.equipment.tier === 3) multiplier *= 2.5; // Steel shovel
            }
            // Apply 1.5x multiplier for secret X tiles
            if (brushingMinigame.isSecretX) {
              multiplier *= 1.5;
            }

            // Give minigame reward (bullets or grapeshot) when completed successfully
            if (brushingMinigame.completed) {
              giveMinigameReward();
            }

            // Convert tile to grass
            const grassDef = tileDefinitions.find(
              (def) => def.name === 'grass'
            );
            if (
              grassDef &&
              brushingMinigame.tileRow !== null &&
              brushingMinigame.tileCol !== null
            ) {
              tileMap[brushingMinigame.tileRow][brushingMinigame.tileCol] = {
                name: grassDef.name,
                canvas: createTileCanvas(grassDef.draw),
              };
              // Remove from discovered secret X list if it was a secret X tile
              radar.discoveredSecretX = radar.discoveredSecretX.filter(
                (pos) =>
                  !(
                    pos.row === brushingMinigame.tileRow &&
                    pos.col === brushingMinigame.tileCol
                  )
              );
            }

            brushingMinigame.active = false;
          }
        }

        // Handle player's answer in Declaration minigame
        function handleDeclarationAnswer(playerSaidReal) {
          if (declarationMinigame.answered) return; // Already answered

          declarationMinigame.answered = true;

          // Check if player was correct
          // Player said Real (true) and it's actually Real (not fake) = correct
          // Player said Fake (false) and it's actually Fake (isFake = true) = correct
          // Special case: If player calls a real document fake, no penalty (neutral)
          const isCorrect =
            (playerSaidReal && !declarationMinigame.isFake) ||
            (!playerSaidReal && declarationMinigame.isFake);

          // Check if player called a real document fake (neutral outcome)
          const calledRealFake = !playerSaidReal && !declarationMinigame.isFake;

          declarationMinigame.wasCorrect = isCorrect;

          let actualReward = 0;
          if (isCorrect) {
            let multiplier = 1.0;
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier = 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2)
                multiplier = 2.0; // Iron shovel
              else if (inventory.equipment.tier === 3)
                multiplier = 2.5; // Steel shovel
              else if (inventory.equipment.tier === 4)
                multiplier = 3.0; // Diamond shovel
              else if (inventory.equipment.tier === 5) multiplier = 4.0; // Legendary shovel
            }
            // Apply 1.5x multiplier for secret X tiles
            if (declarationMinigame.isSecretX) {
              multiplier *= 1.5;
            }
            actualReward = Math.round(
              declarationMinigame.baseReward * multiplier
            );
          } else if (calledRealFake) {
            actualReward = 0;
          } else {
            actualReward = 0;
          }

          declarationMinigame.actualReward = actualReward;

          // Give minigame reward (bullets or grapeshot) when answered correctly
          if (isCorrect) {
            giveMinigameReward();
          }

          // Convert tile to grass
          const grassDef = tileDefinitions.find((def) => def.name === 'grass');
          if (
            grassDef &&
            declarationMinigame.tileRow !== null &&
            declarationMinigame.tileCol !== null
          ) {
            tileMap[declarationMinigame.tileRow][declarationMinigame.tileCol] =
              {
                name: grassDef.name,
                canvas: createTileCanvas(grassDef.draw),
              };
            // Remove from discovered secret X list if it was a secret X tile
            radar.discoveredSecretX = radar.discoveredSecretX.filter(
              (pos) =>
                !(
                  pos.row === declarationMinigame.tileRow &&
                  pos.col === declarationMinigame.tileCol
                )
            );
          }

          // Close minigame after a short delay to show result
          setTimeout(() => {
            declarationMinigame.active = false;
          }, 1000); // 1 second delay to show result
        }

        function updateDeclarationMinigame(dtMs) {
          if (!declarationMinigame.active) return;
          // Minigame logic is handled by key presses, no continuous updates needed
        }

        function updateRadar(dtMs) {
          if (!radar.active) return;
          // Don't fire radar while in any menu
          if (inventory.open || false) {
            return;
          }

          const dt = dtMs / 1000; // Convert to seconds

          // Calculate player's movement direction
          const playerSpeed = Math.hypot(player.vx, player.vy);
          if (playerSpeed > 0.1) {
            // Player is moving - use velocity direction
            radar.lastDirection.x = player.vx / playerSpeed;
            radar.lastDirection.y = player.vy / playerSpeed;
          }

          // Radar appears behind player (further away)
          const followDistance = 40; // Further away, behind player
          radar.x = player.x - radar.lastDirection.x * followDistance;
          radar.y = player.y - radar.lastDirection.y * followDistance;

          // Update ring timer
          radar.ringTimer += dt;

          // Spawn new ring every 2.5-4 seconds (twice as common)
          const minInterval = 2.5;
          const maxInterval = 4.0;
          if (radar.ringTimer >= minInterval) {
            // Random interval between 2.5-4 seconds
            const randomInterval =
              minInterval + Math.random() * (maxInterval - minInterval);
            if (radar.ringTimer >= randomInterval) {
              // Spawn a new ring in a random direction from radar position
              const angle = Math.random() * Math.PI * 2;
              const speed = 150; // pixels per second
              radar.rings.push({
                x: radar.x,
                y: radar.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0, // Fade out over time
                maxLife: 3.0, // Ring lasts 3 seconds
                foundSecretX: false, // Whether this ring found a secret X
                secretXPos: null, // Position of found secret X
              });
              radar.ringTimer = 0; // Reset timer
            }
          }

          // Update existing rings
          for (let i = radar.rings.length - 1; i >= 0; i--) {
            const ring = radar.rings[i];

            if (ring.foundSecretX) {
              // Ring is returning to player
              const dx = radar.x - ring.x;
              const dy = radar.y - ring.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const speed = 200; // Return speed

              if (dist < 10) {
                // Reached player - remove ring
                radar.rings.splice(i, 1);
                continue;
              }

              // Move towards player
              const invDist = 1 / dist;
              ring.vx = dx * invDist * speed;
              ring.vy = dy * invDist * speed;
            } else {
              // Check collision with secret X tiles
              const ringCol = Math.floor(ring.x / tileSize);
              const ringRow = Math.floor(ring.y / tileSize);

              if (
                ringRow >= 0 &&
                ringRow < tileRows &&
                ringCol >= 0 &&
                ringCol < tileCols
              ) {
                const tile = tileMap[ringRow][ringCol];
                if (tile && tile.name === 'secretX') {
                  // Found a secret X! Make ring return to player
                  ring.foundSecretX = true;
                  ring.secretXPos = { x: ring.x, y: ring.y };

                  // Mark this secret X as discovered (avoid duplicates)
                  const alreadyDiscovered = radar.discoveredSecretX.some(
                    (pos) => pos.row === ringRow && pos.col === ringCol
                  );
                  if (!alreadyDiscovered) {
                    radar.discoveredSecretX.push({
                      row: ringRow,
                      col: ringCol,
                    });
                  }
                }
              }
            }

            // Update ring position
            ring.x += ring.vx * dt;
            ring.y += ring.vy * dt;

            // Update ring life
            ring.life -= dt / ring.maxLife;

            // Remove dead rings
            if (ring.life <= 0) {
              radar.rings.splice(i, 1);
            }
          }
        }

        // Load New_Tree sprite
        const treeSprite = new Image();
        treeSprite.imageSmoothingEnabled = false;
        treeSprite.src = 'assets/sprites/New_Tree.png';

        // Load shovel sprites from PNG images
        const shovelSprites = {};
        function loadShovelSprite(tier, filename) {
          const sprite = new Image();
          sprite.src = filename;
          sprite.imageSmoothingEnabled = false; // Pixelated rendering
          shovelSprites[tier] = sprite;
          return sprite;
        }

        // Load shovel sprites for each tier (Multipliers)
        loadShovelSprite(1, 'assets/sprites/Trowel.png'); // Simple trowel
        loadShovelSprite(2, 'assets/sprites/Electric_Brush.png'); // Electric brush
        loadShovelSprite(3, 'assets/sprites/steel-shovel.png'); // Iron Sieve
        // Artifact equipment sprites (use steel-shovel for all artifact tools)
        const artifactShovelSprite = new Image();
        artifactShovelSprite.imageSmoothingEnabled = false;
        artifactShovelSprite.src = 'assets/sprites/steel-shovel.png';
        const artifactSpadeSprite = artifactShovelSprite;
        const artifactScoopSprite = artifactShovelSprite;

        // Load radar sprites (optimized: set imageSmoothingEnabled before src)
        const radarSprite = new Image(); // Default (up)
        radarSprite.imageSmoothingEnabled = false;
        radarSprite.src = 'assets/sprites/Radar.png';

        const radarSpriteRight = new Image(); // Right
        radarSpriteRight.imageSmoothingEnabled = false;
        radarSpriteRight.src = 'assets/sprites/Radar-2.png';

        const radarSpriteLeft = new Image(); // Left
        radarSpriteLeft.imageSmoothingEnabled = false;
        radarSpriteLeft.src = 'assets/sprites/Radar-3.png';

        const radarSpriteDown = new Image(); // Down
        radarSpriteDown.imageSmoothingEnabled = false;
        radarSpriteDown.src = 'assets/sprites/Radar-4.png';

        const radarRingSprite = new Image();
        radarRingSprite.imageSmoothingEnabled = false;
        radarRingSprite.src = 'assets/sprites/Radar_Ring.png';

        // Initialize allSprites array after ALL sprites are defined
        allSprites = [
          potSprite,
          potTallTanSprite,
          potShortGreySprite,
          potPoleSprite,
          brushSprite,
          speedBrushSprite,
          // candyKidSprite, // Removed - NPC not in use
          dirtSprite,
          grassSprite,
          flowerSprite,
          rock1Sprite,
          rock2Sprite,
          newXSprite,
          newBushSprite,
          tallGrassSprite,
          oldGuySprite,
          shopkeeperSprite,
          curatorSprite,
          // vendingMachineSprite, // Removed - NPC not in use
          chocolateBarSprite,
          bulletsSprite,
          grapeshotSprite,
          floorTileSprite,
          wallTileSprite,
          wallDoorSprite,
          playerSpriteIdle,
          playerSpriteBack,
          playerSpriteBackWalk1,
          playerSpriteBackWalk2,
          playerSpriteWalk1,
          playerSpriteWalk2,
          playerSpriteCrouch1,
          playerSpriteCrouch2,
          radarSprite,
          radarSpriteRight,
          radarSpriteLeft,
          radarSpriteDown,
          radarRingSprite,
          treeSprite,
        ];

        // Radar system
        const radar = {
          active: false, // Whether player owns radar (equipped in inventory)
          x: 0, // Position (follows behind player)
          y: 0,
          ringTimer: 0, // Timer for next ring
          rings: [], // Active radar rings
          discoveredSecretX: [], // Array of discovered secret X positions {row, col}
          lastDirection: { x: 0, y: -1 }, // Last movement direction (default: up)
          lastSpriteDirection: 'up', // Last sprite direction: 'up', 'down', 'left', 'right'
        };

        // Quest system
        const quests = {
          findArtifactWithRadar: {
            active: false, // Whether quest is active
            completed: false, // Whether quest is completed
          },
        };

        function drawFlora() {
          // Viewport culling: only draw trees visible on screen
          const halfCanvasW = canvas.width / 2;
          const halfCanvasH = canvas.height / 2;
          const viewLeft = camera.x - halfCanvasW;
          const viewTop = camera.y - halfCanvasH;
          const viewRight = camera.x + halfCanvasW;
          const viewBottom = camera.y + halfCanvasH;
          const padding = 120; // Extra padding to account for tree size
          // Use tree sprite dimensions (fallback to tileCell8 if not loaded yet)
          const spriteWidth =
            treeSprite.complete && treeSprite.naturalWidth > 0
              ? treeSprite.width
              : tileCell * 8;
          const spriteHeight =
            treeSprite.complete && treeSprite.naturalHeight > 0
              ? treeSprite.height
              : tileCell * 8;
          const spriteHalfW = spriteWidth / 2;
          const spriteHalfH = spriteHeight / 2;
          const tileCell8 = tileCell * 8;

          ctx.save();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Set once outside loop

          for (let i = 0; i < flora.trees.length; i++) {
            const tree = flora.trees[i];
            const halfSize = tree.size / 2;

            // Skip trees outside viewport (optimized bounds check)
            if (
              tree.x + halfSize < viewLeft - padding ||
              tree.x - halfSize > viewRight + padding ||
              tree.y + halfSize < viewTop - padding ||
              tree.y - halfSize > viewBottom + padding
            ) {
              continue;
            }

            ctx.save();
            ctx.translate(Math.round(tree.x) + 0.5, Math.round(tree.y) + 0.5);
            ctx.rotate(tree.rotation);

            // Draw shadow
            const shadowRadius = tree.size * 0.45;
            ctx.beginPath();
            ctx.ellipse(
              0,
              tree.size * 0.4,
              shadowRadius,
              tree.size * 0.2,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Draw tree
            if (treeSprite.complete && treeSprite.naturalWidth > 0) {
              const scale = tree.size / treeSprite.height; // Use actual sprite height for scaling
              ctx.scale(scale, scale);
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                treeSprite,
                -treeSprite.width / 2,
                -treeSprite.height / 2
              );
            }
            ctx.restore();
          }

          ctx.restore();
        }

        function drawJoseph() {
          ctx.save();

          // Draw Joseph sprite
          if (shopkeeperSprite.complete && shopkeeperSprite.naturalWidth > 0) {
            // Use actual sprite dimensions for proper scaling
            const spriteWidth = shopkeeperSprite.naturalWidth;
            const spriteHeight = shopkeeperSprite.naturalHeight;
            const maxDimension = Math.max(spriteWidth, spriteHeight, 1); // Ensure at least 1 to avoid division by zero
            const scale = 43 / maxDimension; // Scale to match player size (43px)
            const scaledWidth = spriteWidth * scale;
            const scaledHeight = spriteHeight * scale;

            // Joseph shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              joseph.x,
              joseph.y + scaledHeight * 0.35,
              scaledWidth * 0.5,
              scaledHeight * 0.22,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            const px = Math.round(joseph.x - scaledWidth / 2);
            const py = Math.round(joseph.y - scaledHeight / 2);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(shopkeeperSprite, px, py, scaledWidth, scaledHeight);

            // Draw Radar sprite next to Joseph (to the right)
            // Make radar bigger and add collision
            if (radarSprite.complete && radarSprite.naturalWidth > 0) {
              const radarSpriteSize = 43; // Same size as player/Joseph (was 32)
              const radarOffsetX = 50; // Position to the right of Joseph (increased from 35)
              const radarX = Math.round(joseph.x + radarOffsetX);
              const radarY = Math.round(joseph.y - radarSpriteSize / 2);

              // Radar shadow
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                radarX,
                radarY + radarSpriteSize * 0.35,
                radarSpriteSize * 0.5,
                radarSpriteSize * 0.22,
                0,
                0,
                Math.PI * 2
              );
              ctx.fill();

              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                radarSprite,
                radarX - radarSpriteSize / 2,
                radarY,
                radarSpriteSize,
                radarSpriteSize
              );
            }
          } else {
            // Fallback while loading
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              joseph.x,
              joseph.y + joseph.radius * 0.4,
              joseph.radius * 0.6,
              joseph.radius * 0.2,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            ctx.fillStyle = '#8b6f47';
            ctx.beginPath();
            ctx.arc(joseph.x, joseph.y, joseph.radius, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        function drawOldGuy() {
          ctx.save();

          // Draw old guy sprite
          if (oldGuySprite.complete && oldGuySprite.naturalWidth > 0) {
            // Scale to match player size (43x43, 10% bigger than original 39x39)
            const spriteWidth = 43;
            const spriteHeight = 43;

            // Old guy shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              oldGuy.x,
              oldGuy.y + spriteHeight * 0.35,
              spriteWidth * 0.5,
              spriteHeight * 0.22,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            const px = Math.round(oldGuy.x - spriteWidth / 2);
            const py = Math.round(oldGuy.y - spriteHeight / 2);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(oldGuySprite, px, py, spriteWidth, spriteHeight);
          }

          ctx.restore();
        }

        function drawRadar() {
          if (!radar.active) return;

          ctx.save();
          ctx.imageSmoothingEnabled = false;

          // Select radar sprite based on player's movement direction
          // Update sprite direction when moving, keep last direction when stopped
          const playerSpeed = Math.hypot(player.vx, player.vy);

          if (playerSpeed > 0.1) {
            // Player is moving - determine dominant direction and update
            const absVx = Math.abs(player.vx);
            const absVy = Math.abs(player.vy);

            if (absVx > absVy) {
              // Horizontal movement is dominant
              if (player.vx > 0) {
                radar.lastSpriteDirection = 'right';
              } else {
                radar.lastSpriteDirection = 'left';
              }
            } else if (absVy > absVx) {
              // Vertical movement is dominant
              if (player.vy > 0) {
                radar.lastSpriteDirection = 'down';
              } else {
                radar.lastSpriteDirection = 'up';
              }
            }
            // If absVx === absVy, keep current direction
          }

          // Use the stored sprite direction (persists when stopped)
          let currentRadarSprite = radarSprite; // Default: up
          if (radar.lastSpriteDirection === 'right') {
            currentRadarSprite = radarSpriteRight;
          } else if (radar.lastSpriteDirection === 'left') {
            currentRadarSprite = radarSpriteLeft;
          } else if (radar.lastSpriteDirection === 'down') {
            currentRadarSprite = radarSpriteDown;
          } else {
            currentRadarSprite = radarSprite; // up
          }

          // Draw radar sprite (appears in front of player, same size as player)
          const radarSize = player.width; // Same size as player (43x43)
          const px = Math.round(radar.x - radarSize / 2);
          const py = Math.round(radar.y - radarSize / 2);
          if (
            currentRadarSprite.complete &&
            currentRadarSprite.naturalWidth > 0
          ) {
            ctx.drawImage(currentRadarSprite, px, py, radarSize, radarSize);
          } else {
            // Fallback: draw grey square if sprite didn't load (for missing Radar-2, Radar-3, Radar-4 sprites)
            ctx.fillStyle = '#808080'; // Grey color
            ctx.fillRect(px, py, radarSize, radarSize);
            ctx.strokeStyle = '#606060'; // Darker grey border
            ctx.lineWidth = 2;
            ctx.strokeRect(px, py, radarSize, radarSize);
          }

          // Draw radar rings (bigger)
          if (radarRingSprite.complete && radarRingSprite.naturalWidth > 0) {
            for (let i = 0; i < radar.rings.length; i++) {
              const ring = radar.rings[i];
              const ringSize = 60; // Bigger ring size (doubled from 30)
              const alpha = ring.life; // Fade out as life decreases

              ctx.globalAlpha = alpha;
              const px = Math.round(ring.x - ringSize / 2);
              const py = Math.round(ring.y - ringSize / 2);
              ctx.drawImage(radarRingSprite, px, py, ringSize, ringSize);
            }
            ctx.globalAlpha = 1.0; // Reset alpha
          }

          // Draw markers for discovered secret X tiles (viewport culling for performance)
          ctx.imageSmoothingEnabled = false;
          const viewLeft = camera.x - canvas.width / 2;
          const viewTop = camera.y - canvas.height / 2;
          const viewRight = camera.x + canvas.width / 2;
          const viewBottom = camera.y + canvas.height / 2;

          for (let i = 0; i < radar.discoveredSecretX.length; i++) {
            const pos = radar.discoveredSecretX[i];
            const worldX = (pos.col + 0.5) * tileSize;
            const worldY = (pos.row + 0.5) * tileSize;

            // Viewport culling: only draw if visible
            if (
              worldX < viewLeft - tileSize ||
              worldX > viewRight + tileSize ||
              worldY < viewTop - tileSize ||
              worldY > viewBottom + tileSize
            ) {
              continue;
            }

            // Draw yellow X sprite directly (no tinting needed - sprite is already yellow)
            if (yellowXSprite.complete && yellowXSprite.naturalWidth > 0) {
              ctx.drawImage(
                yellowXSprite,
                worldX - tileSize / 2,
                worldY - tileSize / 2,
                tileSize,
                tileSize
              );
            }
          }

          ctx.restore();
        }

        function drawMuseum() {
          ctx.save();
          ctx.imageSmoothingEnabled = false;

          const museumTileSize = tileSize;
          const museumWorldWidth = museum.width * museumTileSize;
          const museumWorldHeight = museum.height * museumTileSize;

          // Calculate offset to center museum horizontally and place it at bottom
          // Museum is 320x320, canvas is 800x500
          // To center horizontally: offsetX = (canvas.width - museumWorldWidth) / 2
          // To place at bottom: offsetY = canvas.height - museumWorldHeight
          const offsetX = (canvas.width - museumWorldWidth) / 2;
          const offsetY = canvas.height - museumWorldHeight;
          ctx.translate(offsetX, offsetY);

          // Draw floor tiles (10x10 grid)
          for (let row = 0; row < museum.height; row++) {
            for (let col = 0; col < museum.width; col++) {
              const tileX = col * museumTileSize;
              const tileY = row * museumTileSize;

              // Draw floor tile
              if (
                floorTileSprite.complete &&
                floorTileSprite.naturalWidth > 0
              ) {
                ctx.drawImage(
                  floorTileSprite,
                  tileX,
                  tileY,
                  museumTileSize,
                  museumTileSize
                );
              } else {
                // Fallback grey floor
                ctx.fillStyle = '#808080';
                ctx.fillRect(tileX, tileY, museumTileSize, museumTileSize);
              }
            }
          }

          // Draw walls (top, left, right, bottom)
          // Top wall
          for (let col = 0; col < museum.width; col++) {
            const tileX = col * museumTileSize;
            const tileY = 0;
            if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
              ctx.drawImage(
                wallTileSprite,
                tileX,
                tileY,
                museumTileSize,
                museumTileSize
              );
            }
          }
          // Left wall
          for (let row = 0; row < museum.height; row++) {
            const tileX = 0;
            const tileY = row * museumTileSize;
            if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
              ctx.drawImage(
                wallTileSprite,
                tileX,
                tileY,
                museumTileSize,
                museumTileSize
              );
            }
          }
          // Right wall
          for (let row = 0; row < museum.height; row++) {
            const tileX = (museum.width - 1) * museumTileSize;
            const tileY = row * museumTileSize;
            if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
              ctx.drawImage(
                wallTileSprite,
                tileX,
                tileY,
                museumTileSize,
                museumTileSize
              );
            }
          }
          // Bottom wall (with door in middle)
          for (let col = 0; col < museum.width; col++) {
            const tileX = col * museumTileSize;
            const tileY = (museum.height - 1) * museumTileSize;

            if (col === museum.doorCol) {
              // Draw door sprite
              if (wallDoorSprite.complete && wallDoorSprite.naturalWidth > 0) {
                ctx.drawImage(
                  wallDoorSprite,
                  tileX,
                  tileY,
                  museumTileSize,
                  museumTileSize
                );
              } else {
                // Fallback door (different color)
                ctx.fillStyle = '#654321';
                ctx.fillRect(tileX, tileY, museumTileSize, museumTileSize);
              }
            } else {
              // Draw wall tile
              if (wallTileSprite.complete && wallTileSprite.naturalWidth > 0) {
                ctx.drawImage(
                  wallTileSprite,
                  tileX,
                  tileY,
                  museumTileSize,
                  museumTileSize
                );
              }
            }
          }

          ctx.restore();
        }

        function drawMuseumDoorPrompt() {
          ctx.save();

          // Background overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Prompt panel
          const panelWidth = 400;
          const panelHeight = 200;
          const panelX = (canvas.width - panelWidth) / 2;
          const panelY = (canvas.height - panelHeight) / 2;

          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

          // Prompt text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(
            'Continue to next day?',
            panelX + panelWidth / 2,
            panelY + 30
          );

          // Continue button (green)
          const buttonWidth = 120;
          const buttonHeight = 50;
          const buttonSpacing = 40;
          const continueButtonX =
            panelX + panelWidth / 2 - buttonWidth - buttonSpacing / 2;
          const stayButtonX = panelX + panelWidth / 2 + buttonSpacing / 2;
          const buttonY = panelY + panelHeight - buttonHeight - 30;

          // Check if mouse is hovering over buttons
          const hoverContinue =
            mouseX >= continueButtonX &&
            mouseX <= continueButtonX + buttonWidth &&
            mouseY >= buttonY &&
            mouseY <= buttonY + buttonHeight;
          const hoverStay =
            mouseX >= stayButtonX &&
            mouseX <= stayButtonX + buttonWidth &&
            mouseY >= buttonY &&
            mouseY <= buttonY + buttonHeight;

          // Continue button (highlight when hovering)
          ctx.fillStyle = hoverContinue ? '#69db7c' : '#51cf66'; // Lighter green when hovering
          ctx.fillRect(continueButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = hoverContinue ? 3 : 2; // Thicker border when hovering
          ctx.strokeRect(continueButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(
            'Continue',
            continueButtonX + buttonWidth / 2,
            buttonY + buttonHeight / 2
          );

          // Stay button (highlight when hovering)
          ctx.fillStyle = hoverStay ? '#ff8787' : '#ff6b6b'; // Lighter red when hovering
          ctx.fillRect(stayButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = hoverStay ? 3 : 2; // Thicker border when hovering
          ctx.strokeRect(stayButtonX, buttonY, buttonWidth, buttonHeight);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText(
            'Stay',
            stayButtonX + buttonWidth / 2,
            buttonY + buttonHeight / 2
          );

          ctx.restore();
        }

        function render() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Fill canvas with world background color to prevent CSS background showing through
          ctx.fillStyle = world.bg;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Check if in museum state
          if (gameState === 'museum') {
            // Fill background with black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw museum directly (no camera translation - positioned at bottom)
            drawMuseum();
            ctx.restore(); // Close the translate from drawMuseum

            // Draw player (need to apply same offset as museum)
            ctx.save();
            const museumTileSize = tileSize;
            const museumWorldWidth = museum.width * museumTileSize;
            const museumWorldHeight = museum.height * museumTileSize;
            const offsetX = (canvas.width - museumWorldWidth) / 2;
            const offsetY = canvas.height - museumWorldHeight;
            ctx.translate(offsetX, offsetY);

            // Player shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(
              player.x,
              player.y + player.height * 0.35,
              player.width * 0.5,
              player.height * 0.22,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Player sprite
            const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
            const isMovingUp = player.vy < -0.1;
            let currentSprite;
            if (isMovingUp) {
              if (isMoving) {
                const walkFrame = Math.floor(walkAnimationFrame) % 2;
                currentSprite =
                  walkFrame === 0
                    ? playerSpriteBackWalk1
                    : playerSpriteBackWalk2;
              } else {
                currentSprite = playerSpriteBack;
              }
            } else if (isMoving) {
              const walkFrame = Math.floor(walkAnimationFrame) % 2;
              currentSprite =
                walkFrame === 0 ? playerSpriteWalk1 : playerSpriteWalk2;
            } else {
              currentSprite = playerSpriteIdle;
            }

            if (currentSprite.complete && currentSprite.naturalWidth > 0) {
              const px = Math.round(player.x - player.width / 2);
              const py = Math.round(player.y - player.height / 2);
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(currentSprite, px, py, player.width, player.height);
            }

            ctx.restore();

            // Draw curator (use same offset as player in museum)
            ctx.save();
            // Use same offset calculation as player drawing
            const curatorMuseumTileSize = tileSize;
            const curatorMuseumWorldWidth =
              museum.width * curatorMuseumTileSize;
            const curatorMuseumWorldHeight =
              museum.height * curatorMuseumTileSize;
            const curatorMuseumOffsetX =
              (canvas.width - curatorMuseumWorldWidth) / 2;
            const curatorMuseumOffsetY =
              canvas.height - curatorMuseumWorldHeight;
            ctx.translate(curatorMuseumOffsetX, curatorMuseumOffsetY);

            // Draw curator sprite (same pattern as shopkeeper/oldGuy/candyKid)
            if (curatorSprite.complete && curatorSprite.naturalWidth > 0) {
              const spriteWidth = 43; // Match player size
              const spriteHeight = 43;

              // Curator shadow
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                curator.x,
                curator.y + spriteHeight * 0.35,
                spriteWidth * 0.5,
                spriteHeight * 0.22,
                0,
                0,
                Math.PI * 2
              );
              ctx.fill();

              const px = Math.round(curator.x - spriteWidth / 2);
              const py = Math.round(curator.y - spriteHeight / 2);
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(curatorSprite, px, py, spriteWidth, spriteHeight);
            } else {
              // Fallback while loading (same pattern as shopkeeper)
              ctx.fillStyle = 'rgba(0,0,0,0.25)';
              ctx.beginPath();
              ctx.ellipse(
                curator.x,
                curator.y + curator.radius * 0.4,
                curator.radius * 0.6,
                curator.radius * 0.2,
                0,
                0,
                Math.PI * 2
              );
              ctx.fill();

              ctx.fillStyle = '#8b4caf'; // Purple color for curator placeholder
              ctx.strokeStyle = '#6a3d8c';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(curator.x, curator.y, curator.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            }

            ctx.restore();

            // Draw door prompt if active
            if (museum.doorPrompt) {
              drawMuseumDoorPrompt();
            }

            // Draw dialogue box if curator (or any NPC) has dialogue
            if (curator.dialogue) {
              drawDialogueBox();
            }

            return; // Don't render normal game elements in museum
          }

          // World space: translate so that camera is centered
          ctx.save();
          ctx.translate(
            Math.round(canvas.width / 2 - camera.x),
            Math.round(canvas.height / 2 - camera.y)
          );

          drawTiles();
          drawGrid();
          drawFlora();

          // Old Guy NPC
          drawOldGuy();

          // Joseph NPC (shopkeeper with radar)
          drawJoseph();

          // Radar and radar rings
          drawRadar();

          // Player shadow
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
          ctx.ellipse(
            player.x,
            player.y + player.height * 0.35,
            player.width * 0.5,
            player.height * 0.22,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // Player sprite - use back sprite when moving upward, walking sprites when moving
          const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
          const isMovingUp = player.vy < -0.1; // Small threshold to prevent flickering
          let currentSprite;

          // Show crouch animation when active (semi-rapidly switches between crouch sprites)
          if (crouchAnimation.active) {
            // Switch between crouch sprites every 0.15 seconds (semi-rapid animation)
            const crouchFrame = Math.floor(crouchAnimation.timer / 0.15) % 2;
            currentSprite =
              crouchFrame === 0 ? playerSpriteCrouch1 : playerSpriteCrouch2;
          } else if (isMovingUp) {
            // Alternate between back walk sprites when moving up
            if (isMoving) {
              const walkFrame = Math.floor(walkAnimationFrame) % 2;
              currentSprite =
                walkFrame === 0 ? playerSpriteBackWalk1 : playerSpriteBackWalk2;
            } else {
              // Use idle back sprite when not moving but facing up
              currentSprite = playerSpriteBack;
            }
          } else if (isMoving) {
            // Alternate between walk sprites when moving
            const walkFrame = Math.floor(walkAnimationFrame) % 2;
            currentSprite =
              walkFrame === 0 ? playerSpriteWalk1 : playerSpriteWalk2;
          } else {
            // Use idle sprite when not moving
            currentSprite = playerSpriteIdle;
          }

          if (currentSprite.complete && currentSprite.naturalWidth > 0) {
            const px = Math.round(player.x - player.width / 2);
            const py = Math.round(player.y - player.height / 2);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(currentSprite, px, py, player.width, player.height);
          } else {
            // Fallback while loading
            ctx.fillStyle = player.color;
            ctx.strokeStyle = player.outline;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(
              Math.round(player.x - player.width / 2) + 0.5,
              Math.round(player.y - player.height / 2) + 0.5,
              player.width,
              player.height
            );
            ctx.fill();
            ctx.stroke();
          }

          // Direction indicator - small black arrow triangle
          const dirX = player.vx;
          const dirY = player.vy;
          const speedSq = dirX * dirX + dirY * dirY;
          if (speedSq > 0.04) {
            // 0.2^2 = 0.04
            const speed = Math.sqrt(speedSq);
            const nx = dirX / speed;
            const ny = dirY / speed;

            // Position arrow outside player bounds (player radius + offset)
            const playerRadius = Math.max(player.width, player.height) / 2;
            const arrowDistance = playerRadius + 12; // Distance from player center
            const arrowX = player.x + nx * arrowDistance;
            const arrowY = player.y + ny * arrowDistance;

            // Draw small black triangle arrow
            const arrowSize = 6; // Size of the arrow
            const angle = Math.atan2(ny, nx);

            ctx.save();
            ctx.fillStyle = '#000000'; // Black arrow
            ctx.translate(arrowX, arrowY);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(arrowSize, 0); // Tip of arrow
            ctx.lineTo(-arrowSize * 0.6, -arrowSize * 0.6); // Bottom left
            ctx.lineTo(-arrowSize * 0.6, arrowSize * 0.6); // Bottom right
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          // Optional: draw world bounds
          ctx.strokeStyle = 'rgba(139,111,71,0.25)'; // Brown world bounds
          ctx.lineWidth = 2;
          ctx.strokeRect(0.5, 0.5, world.width - 1, world.height - 1);

          // End world space
          ctx.restore();

          // Draw crouch animation particles (screen space)
          if (crouchAnimation.active && crouchAnimation.particles.length > 0) {
            ctx.save();
            for (const p of crouchAnimation.particles) {
              ctx.globalAlpha = p.life; // Fade out as life decreases
              ctx.fillStyle = '#8b4513'; // Brown dirt color
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }

          // UI: Quest system (top-left, above stamina bar)
          let questUIHeight = 0;
          if (
            quests &&
            quests.findArtifactWithRadar &&
            quests.findArtifactWithRadar.active &&
            !quests.findArtifactWithRadar.completed
          ) {
            ctx.save();
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffffff';

            const questX = 16.5;
            const questY = 14.5;

            // Draw "Quests" label
            ctx.fillText('Quests', questX, questY);

            // Draw quest description below
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillStyle = '#e8eaf6';
            ctx.fillText(
              'Find an artifact using the Radar',
              questX,
              questY + 18
            );

            questUIHeight = 36; // Height of quest UI (18 + 18 spacing)
            ctx.restore();
          }

          // UI: Stamina bar (top-left, below quest if visible, otherwise at top)
          const staminaBarY = 14.5 + questUIHeight;
          const bar = {
            x: 16.5,
            y: staminaBarY,
            w: 220,
            h: 16,
          };
          // Background
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)'; // White UI borders
          ctx.fillStyle = 'rgba(10,20,14,0.8)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.rect(bar.x, bar.y, bar.w, bar.h);
          ctx.fill();
          ctx.stroke();

          // Fill (use cached gradients)
          if (!staminaBarGradients) initStaminaGradients();
          const ratio = stamina.current / stamina.max;
          const fillWidth = Math.round(bar.w * ratio);
          // Make stamina bar red when candybar boost is active
          ctx.fillStyle =
            candybarBoost.active || stamina.exhausted
              ? staminaBarGradients.exhausted
              : staminaBarGradients.normal;
          ctx.beginPath();
          ctx.rect(bar.x + 1, bar.y + 1, Math.max(0, fillWidth - 2), bar.h - 2);
          ctx.fill();

          // UI: Time and Day display (top-center, screen space)
          if (gameState === 'playing' || gameState === 'dayEnd') {
            ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Convert to 12-hour format with AM/PM (no minutes)
            let displayHour = dayTime.currentHour;
            let ampm = 'AM';
            if (displayHour >= 12) {
              ampm = 'PM';
              if (displayHour > 12) {
                displayHour -= 12;
              }
            }
            if (displayHour === 0) {
              displayHour = 12;
            }

            const timeText = `${
              dayTime.days[dayTime.currentDay]
            } - ${displayHour} ${ampm}`;
            ctx.fillStyle = '#e8eaf6';
            ctx.fillText(timeText, canvas.width / 2, 14.5);
          }

          // Draw balancing minigame
          if (balancingMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel (bigger to fit text)
            const panelWidth = 450;
            const panelHeight = 350;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff'; // White menu borders
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Draw pot pole sprite (replaces drawn stick)
            // Ensure stick position is valid (fallback to center if undefined)
            // Lower the stick position down in the panel so pole is visible below pot
            const stickX = balancingMinigame.stickX || canvas.width / 2;
            const stickY = (balancingMinigame.stickY || canvas.height / 2) + 80; // Lower by 80px (was 40px) so pole extends below pot
            const stickBaseY = stickY + 25; // Bottom of stick
            const stickTipY = stickY - 25; // Top of stick (tip)
            const stickHeight = stickBaseY - stickTipY; // Height of stick area

            // Draw pole sprite centered at stick position
            if (potPoleSprite.complete && potPoleSprite.naturalWidth > 0) {
              ctx.imageSmoothingEnabled = false;
              // Maintain aspect ratio but make it bigger
              // Use the sprite's natural aspect ratio to avoid warping
              const aspectRatio =
                potPoleSprite.naturalWidth / potPoleSprite.naturalHeight;
              const baseHeight = stickHeight * 1.5; // 1.5x bigger (was 2x)
              const poleHeight = baseHeight;
              const poleWidth = poleHeight * aspectRatio; // Maintain aspect ratio
              // Center the pole on the stick position
              const poleX = stickX - poleWidth / 2; // Center horizontally
              const poleY = stickY - poleHeight / 2; // Center vertically on stickY
              ctx.drawImage(potPoleSprite, poleX, poleY, poleWidth, poleHeight);
            } else {
              // Fallback: draw simple stick while sprite loads
              ctx.strokeStyle = '#8b4513'; // Brown
              ctx.lineWidth = 6;
              ctx.lineCap = 'round';
              ctx.beginPath();
              ctx.moveTo(stickX, stickBaseY);
              ctx.lineTo(stickX, stickTipY);
              ctx.stroke();
              ctx.fillStyle = '#654321'; // Darker brown for tip
              ctx.beginPath();
              ctx.arc(stickX, stickTipY, 3, 0, Math.PI * 2);
              ctx.fill();
            }

            // Draw pot balancing on tip of stick - only if not breaking
            // Pot size varies by type: tall is taller, short is shorter
            let potSize = 100; // Base size for regular pot
            if (balancingMinigame.potType === 'tall') {
              potSize = 120; // Taller pot
            } else if (balancingMinigame.potType === 'short') {
              potSize = 80; // Shorter pot
            }

            // Position pot slightly lower so it rests on the pole
            const potContactY = stickTipY + 5; // Pot contacts stick slightly below tip

            // Ensure potType is set (fallback to 'regular' if undefined)
            if (!balancingMinigame.potType) {
              balancingMinigame.potType = 'regular';
            }

            if (!balancingMinigame.breaking) {
              ctx.save();
              // Translate to the contact point (where pot touches stick tip)
              ctx.translate(stickX, potContactY);
              // Rotate around the contact point (ensure angle is a number)
              const potAngle = balancingMinigame.potAngle || 0;
              ctx.rotate(potAngle);

              // Select the correct pot sprite based on type
              let currentPotSprite = potSprite;
              if (balancingMinigame.potType === 'tall') {
                currentPotSprite = potTallTanSprite;
              } else if (balancingMinigame.potType === 'short') {
                currentPotSprite = potShortGreySprite;
              }

              // Draw pot sprite from PNG, offset upward so bottom is at rotation point
              if (
                currentPotSprite.complete &&
                currentPotSprite.naturalWidth > 0
              ) {
                ctx.imageSmoothingEnabled = false;
                // Draw with bottom at origin (0, 0), so pot extends upward
                ctx.drawImage(
                  currentPotSprite,
                  -potSize / 2,
                  -potSize,
                  potSize,
                  potSize
                );
              } else {
                // Placeholder while loading (color varies by type)
                if (balancingMinigame.potType === 'tall') {
                  ctx.fillStyle = '#d2b48c'; // Tan color
                } else if (balancingMinigame.potType === 'short') {
                  ctx.fillStyle = '#808080'; // Grey color
                } else {
                  ctx.fillStyle = '#8b4513'; // Brown for regular
                }
                ctx.beginPath();
                ctx.ellipse(
                  0,
                  -potSize / 2,
                  potSize / 2,
                  potSize / 2.5,
                  0,
                  0,
                  Math.PI * 2
                );
                ctx.fill();
              }

              ctx.restore();
            }

            // Draw breaking pot pieces
            if (
              balancingMinigame.breaking &&
              balancingMinigame.pieces.length > 0
            ) {
              for (let i = 0; i < balancingMinigame.pieces.length; i++) {
                const piece = balancingMinigame.pieces[i];
                if (piece.opacity > 0) {
                  ctx.save();
                  ctx.globalAlpha = piece.opacity;
                  ctx.translate(piece.x, piece.y);
                  ctx.rotate(piece.rotation);

                  // Draw pot piece (brown fragment)
                  ctx.fillStyle = '#8b4513';
                  ctx.strokeStyle = '#654321';
                  ctx.lineWidth = 1;
                  ctx.beginPath();
                  ctx.rect(
                    -piece.size / 2,
                    -piece.size / 2,
                    piece.size,
                    piece.size
                  );
                  ctx.fill();
                  ctx.stroke();

                  ctx.restore();
                }
              }
            }

            // Timer text removed

            // Instructions
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.textBaseline = 'bottom';
            ctx.fillText(
              'Use arrow keys to keep the pot from tipping!',
              canvas.width / 2,
              panelY + panelHeight - 20
            );

            ctx.restore();
          }

          // Draw brushing minigame
          if (brushingMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel
            const panelWidth = 450;
            const panelHeight = 350;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff'; // White menu borders
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Draw dirt sprite (in center, with red tint based on redness)
            const dirtSize = 150;
            const dirtX = canvas.width / 2;
            const dirtY = canvas.height / 2;

            if (dirtSprite.complete && dirtSprite.naturalWidth > 0) {
              ctx.save();
              ctx.imageSmoothingEnabled = false;

              // Draw dirt sprite normally first
              ctx.globalAlpha = 1.0;
              ctx.drawImage(
                dirtSprite,
                dirtX - dirtSize / 2,
                dirtY - dirtSize / 2,
                dirtSize,
                dirtSize
              );

              // Apply red color tint using multiply blend mode (gradual transition)
              const redness = brushingMinigame.redness;
              if (redness > 0) {
                // Set blend mode to multiply for color tinting effect
                ctx.globalCompositeOperation = 'multiply';
                ctx.globalAlpha = redness; // Fade in the red over 1 second
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(
                  dirtX - dirtSize / 2,
                  dirtY - dirtSize / 2,
                  dirtSize,
                  dirtSize
                );

                // Reset blend mode
                ctx.globalCompositeOperation = 'source-over';

                // Add a subtle glow when fully red
                if (redness >= 1.0) {
                  const pulse = Math.sin(Date.now() / 150) * 0.2 + 0.8;
                  ctx.globalAlpha = pulse * 0.15;
                  ctx.fillStyle = '#ff3333';
                  ctx.fillRect(
                    dirtX - dirtSize / 2 - 5,
                    dirtY - dirtSize / 2 - 5,
                    dirtSize + 10,
                    dirtSize + 10
                  );
                }
              }

              ctx.restore();
            } else {
              // Fallback while loading
              const redness = brushingMinigame.redness;
              // Blend from brown to red based on redness value
              const r = Math.round(139 + (255 - 139) * redness);
              const g = Math.round(69 * (1 - redness));
              const b = Math.round(19 * (1 - redness));
              ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
              ctx.beginPath();
              ctx.rect(
                dirtX - dirtSize / 2,
                dirtY - dirtSize / 2,
                dirtSize,
                dirtSize
              );
              ctx.fill();
            }

            // Draw brush sprite - now animated with brushOffset
            // Check if player has speed brush
            let hasSpeedBrush = false;
            if (
              inventory.equipment &&
              inventory.equipment.name === 'Speed Brush'
            ) {
              hasSpeedBrush = true;
            }
            for (let i = 0; i < inventory.slots.length; i++) {
              if (
                inventory.slots[i] &&
                inventory.slots[i].name === 'Speed Brush'
              ) {
                hasSpeedBrush = true;
                break;
              }
            }
            const brushSize = 80;
            const brushX = canvas.width / 2 + brushingMinigame.brushOffset; // Add offset for animation
            const brushY = brushingMinigame.brushY;

            // Use speed brush sprite if player has it, otherwise use regular brush
            const currentBrushSprite = hasSpeedBrush
              ? speedBrushSprite
              : brushSprite;
            if (
              currentBrushSprite.complete &&
              currentBrushSprite.naturalWidth > 0
            ) {
              ctx.save();
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                currentBrushSprite,
                brushX - brushSize / 2,
                brushY - brushSize / 2,
                brushSize,
                brushSize
              );
              ctx.restore();
            } else {
              // Fallback while loading
              ctx.fillStyle = '#8b7355';
              ctx.beginPath();
              ctx.rect(
                brushX - brushSize / 2,
                brushY - brushSize / 2,
                brushSize,
                brushSize
              );
              ctx.fill();
            }

            // Draw particles
            for (const p of brushingMinigame.particles) {
              ctx.save();
              ctx.globalAlpha = p.life; // Fade out as life decreases
              ctx.fillStyle = '#8b4513'; // Brown dirt color
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }

            // Instructions
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(
              'Hold SPACE to brush the dirt clean!',
              canvas.width / 2,
              panelY + 20
            );

            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.textBaseline = 'bottom';
            ctx.fillText(
              'When it turns RED, release SPACE quickly for max cash!',
              canvas.width / 2,
              panelY + panelHeight - 20
            );

            ctx.restore();
          }

          // Draw Declaration of Independence minigame
          if (declarationMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff'; // White menu borders
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(
              'Declaration of Independence - Authenticity Check',
              Math.round(canvas.width / 2),
              Math.round(panelY + 20)
            );

            // Close button removed

            // Divide panel into two columns
            const columnWidth = (panelWidth - 60) / 2; // Leave space for divider and padding
            const leftX = panelX + 20;
            const rightX = panelX + panelWidth / 2 + 10;
            const textY = panelY + 70;
            const textWidth = columnWidth - 20;

            // Left column label (Reference)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Reference',
              Math.round(leftX + columnWidth / 2),
              Math.round(textY - 25)
            );

            // Left column text (real excerpt)
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            // Enable better text rendering

            // Word wrap for left text
            const leftWords = declarationMinigame.realExcerpt.split(' ');
            let leftLine = '';
            let leftY = textY;
            for (let i = 0; i < leftWords.length; i++) {
              const testLine = leftLine + leftWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > textWidth && i > 0) {
                ctx.fillText(leftLine, Math.round(leftX), Math.round(leftY));
                leftLine = leftWords[i] + ' ';
                leftY += 24;
              } else {
                leftLine = testLine;
              }
            }
            ctx.fillText(leftLine, Math.round(leftX), Math.round(leftY));

            // Divider line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelX + panelWidth / 2, panelY + 60);
            ctx.lineTo(panelX + panelWidth / 2, panelY + panelHeight - 100);
            ctx.stroke();

            // Right column label (Questionable)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Possible fake',
              Math.round(rightX + columnWidth / 2),
              Math.round(textY - 25)
            );

            // Right column text (test excerpt)
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            // Enable better text rendering

            // Word wrap for right text
            const rightWords = declarationMinigame.testExcerpt.split(' ');
            let rightLine = '';
            let rightY = textY;
            for (let i = 0; i < rightWords.length; i++) {
              const testLine = rightLine + rightWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > textWidth && i > 0) {
                ctx.fillText(rightLine, Math.round(rightX), Math.round(rightY));
                rightLine = rightWords[i] + ' ';
                rightY += 24;
              } else {
                rightLine = testLine;
              }
            }
            ctx.fillText(rightLine, Math.round(rightX), Math.round(rightY));

            // Buttons
            if (!declarationMinigame.answered) {
              const buttonY = panelY + panelHeight - 80;
              const buttonWidth = 150;
              const buttonHeight = 40;
              const buttonSpacing = 20;
              const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
              const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

              // Display button (left) - brighter green
              const displayButtonX = buttonStartX;
              // Check if mouse is hovering over Display button
              const isHoveringDisplay =
                mouseX >= displayButtonX &&
                mouseX <= displayButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringDisplay
                ? 'rgba(0, 255, 0, 1.0)' // Even brighter green on hover
                : 'rgba(0, 200, 0, 0.9)'; // Brighter green
              ctx.fillRect(
                Math.round(displayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.strokeStyle = '#ffffff'; // White border (no yellow on hover)
              ctx.lineWidth = 2;
              ctx.strokeRect(
                Math.round(displayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'Display',
                Math.round(displayButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2)
              );

              // Throw away button (right) - brighter red
              const throwAwayButtonX =
                buttonStartX + buttonWidth + buttonSpacing;
              // Check if mouse is hovering over Throw away button
              const isHoveringThrowAway =
                mouseX >= throwAwayButtonX &&
                mouseX <= throwAwayButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringThrowAway
                ? 'rgba(255, 0, 0, 1.0)' // Even brighter red on hover
                : 'rgba(200, 0, 0, 0.9)'; // Brighter red
              ctx.fillRect(
                Math.round(throwAwayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.strokeStyle = '#ffffff'; // White border (no yellow on hover)
              ctx.lineWidth = 2;
              ctx.strokeRect(
                Math.round(throwAwayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'Throw away',
                Math.round(throwAwayButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2)
              );
            } else {
              let resultText = '';
              let resultColor = '#ffffff';

              if (declarationMinigame.wasCorrect) {
                resultText = 'Correct!';
                resultColor = '#00ff00';
              } else if (declarationMinigame.actualReward === 0) {
                resultText = 'Incorrect! (No penalty)';
                resultColor = '#ffff00';
              } else {
                resultText = 'Incorrect!';
                resultColor = '#ff0000';
              }

              ctx.fillStyle = resultColor;
              ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(
                resultText,
                Math.round(canvas.width / 2),
                Math.round(panelY + panelHeight - 60)
              );
            }

            ctx.restore();
          }

          // Draw game over screen
          if (gameOver.active) {
            ctx.save();

            // Full screen overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Game over panel
            const panelWidth = 600;
            const panelHeight = 200;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(139, 0, 0, 0.95)'; // Dark red background
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Game over text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('GAME OVER', canvas.width / 2, panelY + 30);

            // Message
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.textBaseline = 'middle';

            // Word wrap the message
            const messageWords = gameOver.message.split(' ');
            let messageLine = '';
            let messageY = panelY + 90;
            const messageMaxWidth = panelWidth - 40;

            for (let i = 0; i < messageWords.length; i++) {
              const testLine = messageLine + messageWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > messageMaxWidth && i > 0) {
                ctx.fillText(messageLine, canvas.width / 2, messageY);
                messageLine = messageWords[i] + ' ';
                messageY += 25;
              } else {
                messageLine = testLine;
              }
            }
            ctx.fillText(messageLine, canvas.width / 2, messageY);

            // Restart instruction
            ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textBaseline = 'bottom';
            ctx.fillText(
              'Press Spacebar to restart',
              canvas.width / 2,
              panelY + panelHeight - 20
            );

            ctx.restore();
          }

          // Draw inventory menu
          if (inventory.open) {
            drawInventory();
          }

          // Draw dialogue textbox (RPG style at top of screen)
          // Only show tutorial on first day (Monday = day 0)
          // System messages are also shown
          if (
            systemMessage.text ||
            (tutorial.active && dayTime.currentDay === 0) ||
            oldGuy.dialogue ||
            curator.dialogue
          ) {
            drawDialogueBox();
          }

          // Draw day end warning (at 5 PM, bottom of screen)
          if (
            gameState === 'playing' &&
            dayTime.currentHour === dayTime.warningHour
          ) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'The day is ending',
              canvas.width / 2,
              canvas.height - 25
            );
            ctx.restore();
          }

          // Draw day end screen
          if (gameState === 'dayEnd') {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e8eaf6';
            ctx.font = 'bold 36px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'The day has ended.',
              canvas.width / 2,
              canvas.height / 2 - 40
            );

            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillText(
              'Press SPACE to continue',
              canvas.width / 2,
              canvas.height / 2 + 20
            );
            ctx.restore();
          }

          // Draw week end screen
          if (gameState === 'weekEnd') {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e8eaf6';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              'Your week is over!',
              canvas.width / 2,
              canvas.height / 2 - 100
            );

            // Determine ending
            let endingText = '';
            let endingColor = '#e8eaf6';
            if (totalMoney === 0) {
              endingText = 'Lazy';
              endingColor = '#ff6b6b';
            } else if (totalMoney < 2500) {
              endingText = 'Average';
              endingColor = '#ffd93d';
            } else {
              endingText = 'Rich';
              endingColor = '#51cf66';
            }

            ctx.font = 'bold 48px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillStyle = endingColor;
            ctx.fillText(endingText, canvas.width / 2, canvas.height / 2 + 20);

            ctx.fillStyle = '#e8eaf6';
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.fillText(
              'Press SPACE to return to title',
              canvas.width / 2,
              canvas.height / 2 + 100
            );
            ctx.restore();
          }
        }

        function drawShopMenu() {
          // Shop system removed - function stub
          return;
          ctx.save();

          const shopWidth = 400;
          const itemHeight = 50;
          const itemPadding = 10;
          const titleHeight = 40;
          const tabHeight = 30;
          const instructionsHeight = 25;
          const topPadding = 15;
          const bottomPadding = 15;
          const shopHeight =
            titleHeight +
            tabHeight +
            topPadding +
            shop.items.length * itemHeight +
            (shop.items.length - 1) * itemPadding +
            bottomPadding +
            instructionsHeight;
          const shopX = Math.round(canvas.width / 2 - shopWidth / 2) + 0.5;
          const shopY = Math.round(canvas.height / 2 - shopHeight / 2) + 0.5;

          // Background overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Shop panel background
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.beginPath();
          ctx.rect(shopX, shopY, shopWidth, shopHeight);
          ctx.fill();

          // Shop panel border
          ctx.strokeStyle = '#ffffff'; // White borders
          ctx.lineWidth = 3;
          ctx.strokeRect(shopX, shopY, shopWidth, shopHeight);

          // Title
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText('Shop', shopX + shopWidth / 2, shopY + 12);

          // Tabs
          const tabWidth = shopWidth / shop.tabs.length;
          for (let i = 0; i < shop.tabs.length; i++) {
            const tabX = shopX + i * tabWidth;
            const tabY = shopY + titleHeight;
            const isActive = shop.currentTab === i;

            // Tab background
            ctx.fillStyle = isActive
              ? 'rgba(20, 40, 30, 0.9)'
              : 'rgba(15, 30, 20, 0.6)';
            ctx.fillRect(tabX, tabY, tabWidth, tabHeight);

            // Tab border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(tabX, tabY, tabWidth, tabHeight);

            // Tab text
            ctx.fillStyle = '#ffffff';
            ctx.font = isActive
              ? 'bold 14px ui-monospace, Menlo, Consolas, monospace'
              : '14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
              shop.tabs[i].name,
              tabX + tabWidth / 2,
              tabY + tabHeight / 2
            );
          }

          // Draw shop items
          const startY = shopY + titleHeight + tabHeight + topPadding;
          for (let i = 0; i < shop.items.length; i++) {
            const item = shop.items[i];
            const itemY = startY + i * (itemHeight + itemPadding);
            const itemRectX = shopX + 20;
            const itemRectY = itemY;
            const itemRectW = shopWidth - 40;
            const itemRectH = itemHeight;

            // Check if item is purchased
            let isPurchased = item.purchased === true;
            // Also check for equipment items
            if (item.type === 'equipment' && item.name === 'Radar') {
              isPurchased = radar.active;
            } else if (
              item.type === 'equipment' &&
              item.name === 'Speed Brush'
            ) {
              isPurchased = isPurchased || inventory.speedBrush;
            } else if (
              item.type === 'shovel' &&
              item.tier === 6 &&
              (item.name === 'Artifact spade' ||
                item.name === 'Artifact shovel' ||
                item.name === 'Artifact scoop')
            ) {
              // Artifact equipment is purchased if player has any artifact equipment
              isPurchased = inventory.artifactEquipment !== null;
            }

            // Item background - red if purchased
            ctx.fillStyle = isPurchased
              ? 'rgba(80, 20, 20, 0.8)'
              : 'rgba(20, 40, 30, 0.8)';
            ctx.strokeStyle = isPurchased
              ? 'rgba(200, 50, 50, 0.8)'
              : 'rgba(255, 255, 255, 0.6)'; // Red borders if purchased
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(itemRectX, itemRectY, itemRectW, itemRectH);
            ctx.fill();
            ctx.stroke();

            // Draw item sprite (if available)
            let itemSprite = null;
            if (item.type === 'shovel') {
              if (item.tier === 6) {
                // Artifact equipment - use artifact shovel sprite
                itemSprite = artifactShovelSprite;
              } else {
                itemSprite = shovelSprites[item.tier];
              }
            } else if (item.type === 'equipment' && item.name === 'Radar') {
              itemSprite = radarSprite;
            } else if (
              item.type === 'equipment' &&
              item.name === 'Speed Brush'
            ) {
              itemSprite = speedBrushSprite;
            }

            // Draw sprite if available (left side of item box)
            const spriteSize = 32;
            const spriteX = itemRectX + 10;
            const spriteY = itemRectY + (itemRectH - spriteSize) / 2;
            const hasSprite =
              itemSprite && itemSprite.complete && itemSprite.naturalWidth > 0;
            if (hasSprite) {
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                itemSprite,
                spriteX,
                spriteY,
                spriteSize,
                spriteSize
              );
            }

            // Item name - gray out if purchased (offset to make room for sprite)
            const nameX = itemRectX + (hasSprite ? 50 : 10);
            ctx.fillStyle = isPurchased ? '#888888' : '#ffffff';
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(item.name, nameX, itemRectY + 6);

            // Item tier (only for shovels, skip tier 6 artifact items)
            if (item.type === 'shovel' && item.tier !== 6) {
              ctx.fillStyle = isPurchased ? '#888888' : '#ffffff';
              ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(`Tier ${item.tier}`, nameX, itemRectY + 22);
            } else if (
              item.type === 'shovel' &&
              item.tier === 6 &&
              item.description
            ) {
              // Show description for artifact items
              ctx.fillStyle = isPurchased ? '#888888' : '#aaaaaa';
              ctx.font = '10px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(item.description, nameX, itemRectY + 22);
            }

            if (isPurchased) {
              // Show "Sold" or "You already have one" for purchased items in red
              ctx.fillStyle = '#ff6666';
              ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'right';
              ctx.textBaseline = 'middle';
              // For artifact equipment, show "You already have one" instead of "Sold"
              const soldText =
                item.type === 'shovel' &&
                item.tier === 6 &&
                (item.name === 'Artifact spade' ||
                  item.name === 'Artifact shovel' ||
                  item.name === 'Artifact scoop')
                  ? 'You already have one'
                  : 'Sold';
              ctx.fillText(
                soldText,
                itemRectX + itemRectW - 10,
                itemRectY + itemRectH / 2
              );
            } else {
              // Check if previous tier is purchased (for Multipliers tab)
              let canBuy = true;
              if (item.type === 'shovel' && item.tier > 1) {
                // Find previous tier item
                const prevTierItem = shop.items.find(
                  (i) => i.type === 'shovel' && i.tier === item.tier - 1
                );
                if (prevTierItem && !prevTierItem.purchased) {
                  canBuy = false;
                }
              }

              // Price
              const priceText = `$${item.price}`;
              const canAfford = money.amount >= item.price;
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'right';
              ctx.fillText(
                priceText,
                itemRectX + itemRectW - 10,
                itemRectY + 14
              );

              // Buy button indicator (click to buy)
              if (!canBuy) {
                ctx.fillStyle = '#ff6666';
                ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
                ctx.textAlign = 'right';
                ctx.fillText(
                  'Buy previous tier first',
                  itemRectX + itemRectW - 10,
                  itemRectY + 32
                );
              } else if (canAfford) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
                ctx.textAlign = 'right';
                ctx.fillText(
                  'Click to buy',
                  itemRectX + itemRectW - 10,
                  itemRectY + 32
                );
              } else {
                ctx.fillStyle = '#ff6666'; // Red for cannot afford
                ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
                ctx.textAlign = 'right';
                ctx.fillText(
                  'Cannot afford',
                  itemRectX + itemRectW - 10,
                  itemRectY + 32
                );
              }
            }
          }

          // Instructions
          ctx.fillStyle = '#ffffff';
          ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Press Spacebar to close | Click tabs and items to interact',
            shopX + shopWidth / 2,
            shopY + shopHeight - 10
          );

          ctx.restore();
        }

        function purchaseItem(itemIndex) {
          // Shop system removed - function stub
          return;
          if (itemIndex < 0 || itemIndex >= shop.items.length) return;

          const item = shop.items[itemIndex];

          // Check for artifact equipment FIRST (before general shovel handling)
          // Artifact items have type: 'shovel' and tier: 6, so they would match the general shovel condition
          if (
            item.type === 'shovel' &&
            item.tier === 6 &&
            (item.name === 'Artifact spade' ||
              item.name === 'Artifact shovel' ||
              item.name === 'Artifact scoop')
          ) {
            // Artifact equipment - can only have one total (not one of each)
            // Check if player already has any artifact equipment
            if (inventory.artifactEquipment) {
              return; // Already have artifact equipment, can't buy another
            }
            if (money.amount >= item.price) {
              money.amount -= item.price;
              // Mark as purchased
              item.purchased = true;
              // Equip this artifact tool with appropriate sprite
              let artifactSprite = artifactShovelSprite;
              if (item.name === 'Artifact spade') {
                artifactSprite = artifactSpadeSprite;
              } else if (item.name === 'Artifact shovel') {
                artifactSprite = artifactShovelSprite;
              } else if (item.name === 'Artifact scoop') {
                artifactSprite = artifactScoopSprite;
              }
              inventory.artifactEquipment = {
                name: item.name,
                sprite: artifactSprite,
              };
              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }
            }
          } else if (item.type === 'shovel') {
            // Check if already purchased
            if (item.purchased) {
              return; // Already purchased
            }

            // Check if previous tier is purchased (for tier > 1)
            if (item.tier > 1) {
              const prevTierItem = shop.items.find(
                (i) => i.type === 'shovel' && i.tier === item.tier - 1
              );
              if (prevTierItem && !prevTierItem.purchased) {
                return; // Must buy previous tier first
              }
            }

            if (money.amount >= item.price) {
              money.amount -= item.price;
              // Mark as purchased
              item.purchased = true;

              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }

              // Get the appropriate sprite for this shovel tier
              // For tier 6 (Artifact shovel/spade/scoop), use the regular shovel sprite as placeholder
              let sprite = shovelSprites[item.tier];
              // If sprite not loaded yet, try to load it, or use a default
              if (!sprite) {
                if (item.tier === 6) {
                  // Use tier 5 sprite as placeholder for tier 6
                  sprite = shovelSprites[5] || shovelSprites[1];
                } else {
                  const spriteName =
                    'assets/sprites/' +
                    item.name.toLowerCase().replace(/\s+/g, '-') +
                    '.png';
                  sprite = loadShovelSprite(item.tier, spriteName);
                }
              }
              // Add shovel to equipment slot (use highest tier purchased)
              inventory.equipment = {
                name: item.name,
                tier: item.tier,
                sprite: sprite || shovelSprites[1], // Fallback to tier 1 sprite
                type: 'shovel',
              };
            }
          } else if (item.type === 'equipment' && item.name === 'Radar') {
            // Check if player already owns radar
            if (radar.active) {
              return; // Already own radar
            }

            if (money.amount >= item.price) {
              money.amount -= item.price;

              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }

              // Activate radar
              radar.active = true;
              radar.ringTimer = 0;
              radar.rings = [];

              // Mark as purchased
              item.purchased = true;
            }
          } else if (item.type === 'equipment' && item.name === 'Speed Brush') {
            // Check if already purchased
            if (item.purchased || inventory.speedBrush) {
              return; // Already purchased/owned
            }

            if (money.amount >= item.price) {
              money.amount -= item.price;

              // Mark as purchased and owned
              item.purchased = true;
              inventory.speedBrush = true;

              // Check if this is the first item purchased
              if (!shopkeeper.hasBoughtFirstItem) {
                shopkeeper.hasBoughtFirstItem = true;
                // Set dialogue to show inventory message
                shopkeeper.dialogue =
                  "Press E to open your inventory to see the items you've bought!";
                shopkeeper.dialogueStage = 1;
                shopkeeper.dialogueTimer = 0;
              }
            }
          }
        }

        function drawDialogueBox() {
          ctx.save();

          const boxHeight = 100;
          const boxY = 0; // Top of screen instead of bottom
          const boxPadding = 20;
          const boxMargin = 20;
          const boxX = boxMargin;
          const boxWidth = canvas.width - boxMargin * 2;

          // Background with slight transparency
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.beginPath();
          ctx.rect(boxX, boxY, boxWidth, boxHeight);
          ctx.fill();

          // Border
          ctx.strokeStyle = '#ffffff'; // White borders
          ctx.lineWidth = 3;
          ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

          // Inner border for depth
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Lighter white for inner border
          ctx.lineWidth = 1;
          ctx.strokeRect(boxX + 2, boxY + 2, boxWidth - 4, boxHeight - 4);

          // Dialogue text
          ctx.fillStyle = '#ffffff';
          ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';

          // Determine which character is speaking and get their name
          // System messages have no character name
          let characterName = '';
          if (systemMessage.text) {
            characterName = ''; // System messages have no character name
          } else if (tutorial.active) {
            characterName = 'Candy Kid';
          } else if (oldGuy.dialogue) {
            characterName = 'Uncle Bernie';
          } else if (curator.dialogue) {
            characterName = 'Museum Curator';
          }

          // Draw character name above dialogue text
          let nameY = boxY + boxPadding;
          if (characterName) {
            ctx.fillStyle = '#ffffff'; // White for character names
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(characterName, boxX + boxPadding, nameY);

            // Draw line between name and text
            const lineY = nameY + 18;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(boxX + boxPadding, lineY);
            ctx.lineTo(boxX + boxWidth - boxPadding, lineY);
            ctx.stroke();
          }

          // Word wrap the dialogue text
          const maxWidth = boxWidth - boxPadding * 2;
          const dialogueText = systemMessage.text
            ? systemMessage.text
            : tutorial.active
            ? tutorial.dialogue
            : oldGuy.dialogue || curator.dialogue || '';
          const words = dialogueText.split(' ');
          let line = '';
          // Start text below character name and line (add extra space if name exists)
          let y = boxY + boxPadding + (characterName ? 38 : 0);

          for (let i = 0; i < words.length; i++) {
            const testLine = line + words[i] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;

            if (testWidth > maxWidth && i > 0) {
              ctx.fillText(line, boxX + boxPadding, y);
              line = words[i] + ' ';
              y += 22; // Line height
            } else {
              line = testLine;
            }
          }
          ctx.fillText(line, boxX + boxPadding, y);

          // Draw help text in bottom right of textbox (only for tutorial)
          if (tutorial.active) {
            const helpText =
              'Press Spacebar to progress textboxes and talk to people';
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            // Move further down and to the right (reduce padding more)
            ctx.fillText(helpText, boxX + boxWidth - 10, boxY + boxHeight - 10);
          }

          ctx.restore();
        }

        function drawInventory() {
          ctx.save();

          // Equipment items that can be owned
          const equipmentItems = [
            {
              name: 'Radar',
              sprite: radarSprite,
              description: "Reveals hidden X's",
            },
            {
              name: 'Chocolate Bar',
              sprite: chocolateBarSprite,
              description: 'Speeds up your movement',
            },
            {
              name: 'Speed Brush',
              sprite: speedBrushSprite,
              description: 'Makes brushing minigame easier',
            },
            {
              name: 'Artifact Tool',
              sprite: inventory.artifactEquipment
                ? inventory.artifactEquipment.sprite
                : null,
              description: inventory.artifactEquipment
                ? inventory.artifactEquipment.name
                : 'No artifact tool equipped',
            },
          ];

          // Artifacts panel dimensions
          const slotSize = 48;
          const slotSpacing = 4;
          const slotsPerRow = 5;
          const numRows = 2; // Reduced from 3 to make room for equipment row
          const panelPadding = 24;
          const equipmentSlotSize = 48;
          const equipmentRowSpacing = 4;
          const titleHeight = 40;
          const equipmentLabelHeight = 16;
          const equipmentSpacing = 30; // Increased spacing between equipment and artifacts
          const instructionsHeight = 30;

          // Calculate proper dimensions to fit all slots
          const equipmentRowWidth =
            equipmentItems.length * equipmentSlotSize +
            (equipmentItems.length - 1) * equipmentRowSpacing;
          const slotsAreaWidth =
            slotsPerRow * slotSize + (slotsPerRow - 1) * slotSpacing;
          const slotsAreaHeight =
            numRows * slotSize + (numRows - 1) * slotSpacing;
          const inventoryWidth =
            Math.max(equipmentRowWidth, slotsAreaWidth) + panelPadding * 2;
          const inventoryHeight =
            titleHeight +
            equipmentSlotSize +
            equipmentLabelHeight +
            equipmentSpacing +
            slotsAreaHeight +
            panelPadding * 2 +
            instructionsHeight;

          const panelX =
            Math.round(canvas.width / 2 - inventoryWidth / 2) + 0.5;
          const panelY =
            Math.round(canvas.height / 2 - inventoryHeight / 2) + 0.5;

          // Background with semi-transparent overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Main panel background
          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.beginPath();
          ctx.rect(panelX, panelY, inventoryWidth, inventoryHeight);
          ctx.fill();

          // Panel border
          ctx.strokeStyle = '#ffffff'; // White borders
          ctx.lineWidth = 2;
          ctx.strokeRect(panelX, panelY, inventoryWidth, inventoryHeight);

          // Title
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText('Inventory', panelX + inventoryWidth / 2, panelY + 12);

          // Equipment row (at the top, centered)
          const equipmentRowStartX =
            panelX + inventoryWidth / 2 - equipmentRowWidth / 2;
          const equipmentY = panelY + titleHeight + 30; // Lower the equipment row by 30 pixels

          // Equipment label (above the equipment row)
          ctx.fillStyle = '#ffffff';
          ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Equipment',
            panelX + inventoryWidth / 2,
            equipmentY - 4
          );

          let hoveredItemDescription = null;

          // Draw equipment items row
          for (let i = 0; i < equipmentItems.length; i++) {
            const item = equipmentItems[i];
            const equipmentX =
              equipmentRowStartX +
              i * (equipmentSlotSize + equipmentRowSpacing);

            // Check if player owns this item
            let isOwned = false;
            let itemCount = 0; // For items with counts (like chocolate bars)
            if (item.name === 'Radar') {
              isOwned = radar.active;
            } else if (item.name === 'Chocolate Bar') {
              // Chocolate bars are stored in equipment slot with count
              isOwned = inventory.chocolateBarCount > 0;
              itemCount = inventory.chocolateBarCount;
            } else if (item.name === 'Speed Brush') {
              // Speed Brush is in equipment slot only
              isOwned = inventory.speedBrush;
            } else if (item.name === 'Artifact Tool') {
              // Artifact tool slot
              isOwned = inventory.artifactEquipment !== null;
            }

            // Check if hovering (only show description if owned)
            const isHovered =
              mouseX >= equipmentX &&
              mouseX <= equipmentX + equipmentSlotSize &&
              mouseY >= equipmentY &&
              mouseY <= equipmentY + equipmentSlotSize;

            if (isHovered && isOwned) {
              hoveredItemDescription = item.description;
            }

            // Slot background
            ctx.fillStyle = isOwned
              ? 'rgba(20, 40, 30, 0.8)'
              : 'rgba(0, 0, 0, 0.9)'; // Black if not owned
            ctx.strokeStyle = isOwned
              ? 'rgba(255, 255, 255, 0.9)'
              : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = isOwned ? 2 : 1.5;
            ctx.beginPath();
            ctx.rect(
              equipmentX,
              equipmentY,
              equipmentSlotSize,
              equipmentSlotSize
            );
            ctx.fill();
            ctx.stroke();

            // Draw item sprite (only if owned, otherwise slot is black)
            if (isOwned) {
              // Draw sprite if available
              if (
                item.sprite &&
                item.sprite.complete &&
                item.sprite.naturalWidth > 0
              ) {
                const spriteSize = equipmentSlotSize - 8;
                const spriteX =
                  equipmentX + (equipmentSlotSize - spriteSize) / 2;
                const spriteY =
                  equipmentY + (equipmentSlotSize - spriteSize) / 2;
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                  item.sprite,
                  spriteX,
                  spriteY,
                  spriteSize,
                  spriteSize
                );
                ctx.restore();

                // Draw count number in corner (for chocolate bars)
                if (item.name === 'Chocolate Bar' && itemCount > 0) {
                  ctx.fillStyle = '#ffffff';
                  ctx.font =
                    'bold 14px ui-monospace, Menlo, Consolas, monospace';
                  ctx.textAlign = 'right';
                  ctx.textBaseline = 'bottom';
                  // Draw with shadow for readability
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                  ctx.shadowBlur = 2;
                  ctx.fillText(
                    itemCount.toString(),
                    equipmentX + equipmentSlotSize - 4,
                    equipmentY + equipmentSlotSize - 4
                  );
                  ctx.shadowBlur = 0; // Reset shadow
                }
              }
            }
          }

          // Artifacts label
          const artifactsLabelY =
            equipmentY +
            equipmentSlotSize +
            equipmentLabelHeight +
            equipmentSpacing;
          ctx.fillStyle = '#ffffff';
          ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Artifacts',
            panelX + inventoryWidth / 2,
            artifactsLabelY - 4
          );

          // Artifact slots grid (below equipment row)
          const slotsStartX = panelX + panelPadding;
          const slotsStartY = artifactsLabelY;

          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < slotsPerRow; col++) {
              const slotIndex = row * slotsPerRow + col;
              const slotX = slotsStartX + col * (slotSize + slotSpacing);
              const slotY = slotsStartY + row * (slotSize + slotSpacing);

              // Slot background
              ctx.fillStyle = 'rgba(20, 40, 30, 0.8)';
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White borders
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.rect(slotX, slotY, slotSize, slotSize);
              ctx.fill();
              ctx.stroke();

              // Check if hovering over this slot
              const isHovered =
                mouseX >= slotX &&
                mouseX <= slotX + slotSize &&
                mouseY >= slotY &&
                mouseY <= slotY + slotSize;

              // Draw item if present
              const item = inventory.slots[slotIndex];
              if (item) {
                // Draw item sprite
                if (
                  item.sprite &&
                  item.sprite.complete &&
                  item.sprite.naturalWidth > 0
                ) {
                  const spriteSize = slotSize - 8; // Leave padding
                  const spriteX = slotX + (slotSize - spriteSize) / 2;
                  const spriteY = slotY + (slotSize - spriteSize) / 2;
                  ctx.save();
                  ctx.imageSmoothingEnabled = false;
                  ctx.drawImage(
                    item.sprite,
                    spriteX,
                    spriteY,
                    spriteSize,
                    spriteSize
                  );
                  ctx.restore();
                }

                // Show description on hover
                if (isHovered) {
                  let description = '';
                  if (item.name === 'Candybar') {
                    description = 'Speeds up your movement';
                  } else if (item.name === 'Speed Brush') {
                    description = 'Makes brushing minigame easier';
                  } else {
                    description = item.name;
                  }
                  if (!hoveredItemDescription) {
                    hoveredItemDescription = description;
                  }
                }
              }
            }
          }

          // Draw hover tooltip
          if (hoveredItemDescription) {
            const tooltipPadding = 8;
            const tooltipX = mouseX + 10;
            const tooltipY = mouseY + 10;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const metrics = ctx.measureText(hoveredItemDescription);
            const tooltipWidth = metrics.width + tooltipPadding * 2;
            const tooltipHeight = 20;

            // Make sure tooltip stays on screen
            const finalTooltipX =
              tooltipX + tooltipWidth > canvas.width
                ? mouseX - tooltipWidth - 10
                : tooltipX;
            const finalTooltipY =
              tooltipY + tooltipHeight > canvas.height
                ? mouseY - tooltipHeight - 10
                : tooltipY;

            ctx.fillRect(
              finalTooltipX,
              finalTooltipY,
              tooltipWidth,
              tooltipHeight
            );
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(
              finalTooltipX,
              finalTooltipY,
              tooltipWidth,
              tooltipHeight
            );

            ctx.fillStyle = '#ffffff';
            ctx.fillText(
              hoveredItemDescription,
              finalTooltipX + tooltipPadding,
              finalTooltipY + 4
            );
          }

          // Instructions
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Press E to close',
            panelX + inventoryWidth / 2,
            panelY + inventoryHeight - 12
          );

          ctx.restore();
        }

        // Title screen rendering
        function drawTitleScreen() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Save current camera position
          const savedCameraX = camera.x;
          const savedCameraY = camera.y;

          // Calculate smooth circular camera position
          const camX =
            titleScreenCamera.centerX +
            Math.cos(titleScreenCamera.angle) * titleScreenCamera.radiusX;
          const camY =
            titleScreenCamera.centerY +
            Math.sin(titleScreenCamera.angle) * titleScreenCamera.radiusY;

          // Set camera to title screen camera position for background rendering
          camera.x = camX;
          camera.y = camY;

          // Draw game world background (tiles, grid, flora) - no NPCs, player, or radar
          ctx.save();
          // World space: translate so that camera is centered
          ctx.translate(
            Math.round(canvas.width / 2 - camera.x),
            Math.round(canvas.height / 2 - camera.y)
          );

          // Draw background elements only
          drawTiles();
          drawGrid();
          drawFlora();

          ctx.restore();

          // Restore camera position
          camera.x = savedCameraX;
          camera.y = savedCameraY;

          // Draw semi-transparent overlay to darken background slightly and make text readable
          ctx.fillStyle = 'rgba(15, 26, 18, 0.6)'; // Dark green overlay with transparency
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Title text
          ctx.fillStyle = '#e8eaf6';
          ctx.font = 'bold 48px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(
            'Dig, Dig, Dig!',
            canvas.width / 2,
            canvas.height / 2 - 80
          );

          // Play button
          const buttonX = canvas.width / 2;
          const buttonY = canvas.height / 2 + 40;
          const buttonWidth = 200;
          const buttonHeight = 60;

          // Check if mouse is hovering over play button
          const isHoveringPlay =
            mouseX >= buttonX - buttonWidth / 2 &&
            mouseX <= buttonX + buttonWidth / 2 &&
            mouseY >= buttonY - buttonHeight / 2 &&
            mouseY <= buttonY + buttonHeight / 2;

          // Button background (rounded rectangle) - brighter when hovering
          ctx.fillStyle = isHoveringPlay ? '#1f2f4a' : '#15193a'; // Brighter on hover
          ctx.strokeStyle = isHoveringPlay ? '#3b4f6f' : '#2b2f55'; // Brighter border on hover
          ctx.lineWidth = 3;
          const radius = 8;
          const btnX = buttonX - buttonWidth / 2;
          const btnY = buttonY - buttonHeight / 2;
          ctx.beginPath();
          ctx.moveTo(btnX + radius, btnY);
          ctx.lineTo(btnX + buttonWidth - radius, btnY);
          ctx.quadraticCurveTo(
            btnX + buttonWidth,
            btnY,
            btnX + buttonWidth,
            btnY + radius
          );
          ctx.lineTo(btnX + buttonWidth, btnY + buttonHeight - radius);
          ctx.quadraticCurveTo(
            btnX + buttonWidth,
            btnY + buttonHeight,
            btnX + buttonWidth - radius,
            btnY + buttonHeight
          );
          ctx.lineTo(btnX + radius, btnY + buttonHeight);
          ctx.quadraticCurveTo(
            btnX,
            btnY + buttonHeight,
            btnX,
            btnY + buttonHeight - radius
          );
          ctx.lineTo(btnX, btnY + radius);
          ctx.quadraticCurveTo(btnX, btnY, btnX + radius, btnY);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Button text
          ctx.fillStyle = '#e8eaf6';
          ctx.font = '24px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText('PLAY', buttonX, buttonY);

          // Credits text
          ctx.fillStyle = '#a0a0a0'; // Lighter gray for credits
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Made by the FLL team "Potential Error", with the help of Bernie Durfee.',
            canvas.width / 2,
            canvas.height - 20
          );
        }

        // Handle mouse clicks for title screen
        canvas.addEventListener('click', (e) => {
          if (gameState === 'title') {
            const rect = canvas.getBoundingClientRect();
            // Account for canvas scaling - convert display coordinates to internal canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Check if click is on play button
            const buttonX = canvas.width / 2;
            const buttonY = canvas.height / 2 + 40;
            const buttonWidth = 200;
            const buttonHeight = 60;

            if (
              x >= buttonX - buttonWidth / 2 &&
              x <= buttonX + buttonWidth / 2 &&
              y >= buttonY - buttonHeight / 2 &&
              y <= buttonY + buttonHeight / 2
            ) {
              // Initialize day/time system for new game
              dayTime.currentDay = 0; // Start on Monday
              dayTime.currentHour = 8; // Start at 8:00 AM
              dayTime.hourTimer = 0;

              // Reset player position
              player.x = world.width / 2;
              player.y = world.height - 40;
              player.vx = 0;
              player.vy = 0;

              // Reset camera
              camera.x = player.x;
              camera.y = player.y;

              gameState = 'playing';
              e.stopPropagation(); // Prevent other handlers from processing
            }
          }
        });

        let lastTime = performance.now();
        function loop(now) {
          try {
            const dt = Math.min(33, now - lastTime);
            lastTime = now;
            const dtSeconds = dt / 1000;

            if (gameState === 'loading') {
              // Draw loading screen first to ensure it shows
              drawLoadingScreen();

              // Update loading progress
              updateLoadingProgress();

              // Wait for all sprites to load, then wait 1 second more
              if (loadingState.allLoaded) {
                loadingState.postLoadTimer += dtSeconds * 1000; // Convert to ms
                if (loadingState.postLoadTimer >= loadingState.postLoadDelay) {
                  gameState = 'title';
                }
              }
            } else if (gameState === 'title') {
              // Update title screen camera for smooth circular scrolling
              titleScreenCamera.angle += titleScreenCamera.speed * dtSeconds;
              // Keep angle in reasonable range to prevent overflow
              if (titleScreenCamera.angle > Math.PI * 2) {
                titleScreenCamera.angle -= Math.PI * 2;
              }
              drawTitleScreen();
            } else {
              update(dt);
              render();
            }
          } catch (error) {
            console.error('Game loop error:', error);
            // Draw error screen
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ff0000';
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Error: ' + error.message,
              canvas.width / 2,
              canvas.height / 2
            );
          }

          requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
