<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dig, Dig, Dig!</title>
    <style>
      html,
      body {
      height: 100%;
            margin: 0;
      background: #0f1a12;
      color: #e8eaf6;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, Noto Sans, Helvetica, Arial, 'Apple Color Emoji',
          'Segoe UI Emoji';
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100%;
    }
      header,
      footer {
      padding: 6px 14px;
      background: #15193a;
      border-bottom: 1px solid #2b2f55;
    }
    header {
      position: sticky;
            top: 0;
      z-index: 1;
    }
    footer {
      border-top: 1px solid #2b2f55;
      border-bottom: none;
    }
    main {
      display: grid;
      place-items: center;
      padding: 0;
      overflow: hidden;
    }
    canvas {
      background: #1c7f2d;
      border: 1px solid #2b2f55;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 0 0 1px rgba(255, 255, 255, 0.03);
      image-rendering: pixelated;
      max-width: 100%;
      height: 100%;
      width: auto;
    }
    .hint {
      opacity: 0.8;
      font-size: 11px;
    }
    kbd {
      background: #202659;
      border: 1px solid #303776;
      border-bottom-width: 2px;
      border-radius: 4px;
      padding: 1px 6px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          'Liberation Mono', monospace;
      font-size: 12px;
        }
    </style>
</head>
<body>
  <div class="wrap">
    <header>
      <strong>Simple Player Movement</strong>
    </header>
    <main>
        <canvas
          id="game"
          width="800"
          height="500"
          aria-label="Game canvas"
        ></canvas>
    </main>
    </div>

    <script>
      (function () {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const world = {
        width: 2400,
          height: 2064,
          bg: '#0f1226',
      };

      const camera = {
        x: world.width / 2,
        y: world.height / 2,
          followLerp: 0.12,
      };

      const tileSize = 32;
      const tileCols = Math.ceil(world.width / tileSize);
      const tileRows = Math.ceil(world.height / tileSize);
      const tileCell = 4;
      const cellsPerTile = tileSize / tileCell;

      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }

        function createScatter(
          count,
          minSize,
          maxSize,
          margin = 60,
          minDistance = 120
        ) {
        const sprites = [];
          const maxAttempts = 50;
          const cellSize = minDistance * 2;
        const gridCols = Math.ceil(world.width / cellSize);
        const gridRows = Math.ceil(world.height / cellSize);
          const grid = Array.from({ length: gridRows }, () =>
            Array(gridCols)
              .fill(null)
              .map(() => [])
          );

        function getGridCell(x, y) {
          const col = Math.floor(x / cellSize);
          const row = Math.floor(y / cellSize);
            return {
              row: Math.max(0, Math.min(gridRows - 1, row)),
              col: Math.max(0, Math.min(gridCols - 1, col)),
            };
        }

        for (let i = 0; i < count; i++) {
          const size = randomRange(minSize, maxSize);
          const colliderRadius = size * 0.42;
          const requiredDistance = minDistance + colliderRadius;
          const requiredDistanceSq = requiredDistance * requiredDistance;

            let x,
              y,
              valid = false;
          let placementAttempts = 0;

          while (!valid && placementAttempts < maxAttempts) {
            placementAttempts++;
            x = randomRange(margin, world.width - margin);
            y = randomRange(margin, world.height - margin);

            const cell = getGridCell(x, y);
            valid = true;
            for (let dr = -1; dr <= 1 && valid; dr++) {
              for (let dc = -1; dc <= 1 && valid; dc++) {
                const checkRow = cell.row + dr;
                const checkCol = cell.col + dc;
                  if (
                    checkRow >= 0 &&
                    checkRow < gridRows &&
                    checkCol >= 0 &&
                    checkCol < gridCols
                  ) {
                  for (const existing of grid[checkRow][checkCol]) {
                    const dx = x - existing.x;
                    const dy = y - existing.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < requiredDistanceSq) {
                      valid = false;
                      break;
                    }
                  }
                }
              }
            }
          }

          if (valid) {
            const tree = {
              x,
              y,
              size,
              rotation: randomRange(-Math.PI / 8, Math.PI / 8),
                colliderRadius,
            };
            sprites.push(tree);
            const cell = getGridCell(x, y);
            grid[cell.row][cell.col].push(tree);
          }
        }
        return sprites;
      }

      const flora = {
          trees: createScatter(65, 78, 102, 140, 180),
      };

      const balancingMinigame = {
        active: false,
          potAngle: 0,
          potAngularVelocity: 0,
          timeRemaining: 15,
          baseReward: 10,
          stickX: 0,
          stickY: 0,
        potSprite: null,
          potType: 'regular',
        tileRow: null,
        tileCol: null,
          breaking: false,
          breakTimer: 0,
          pieces: [],
          isSecretX: false, // Track if this minigame came from a secret X tile
        };

      const brushingMinigame = {
        active: false,
          dirtLevel: 1.0,
          redness: 0,
          timeHoldingSpace: 0,
          redTriggerTime: 0,
          timeSinceRed: 0,
          redTransitionTime: 1.0,
          perfectReleaseWindow: 0.5,
          baseReward: 10,
        tileRow: null,
        tileCol: null,
          brushX: 0,
          brushY: 0,
          brushOffset: 0,
          brushDirection: 1,
          particles: [],
          completed: false,
          broken: false,
          isSecretX: false, // Track if this minigame came from a secret X tile
        };

        const declarationMinigame = {
          active: false,
          baseReward: 50,
          penalty: 30,
          tileRow: null,
          tileCol: null,
          realExcerpt:
            'We hold these truths to be self-evident, that all men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the pursuit of Happiness.',
          testExcerpt: '',
          isFake: false,
          answered: false,
          wasCorrect: false,
          actualReward: 0,
          isSecretX: false, // Track if this minigame came from a secret X tile
        };

      const potSprite = new Image();
      potSprite.src = 'assets/sprites/pot.png';
        potSprite.imageSmoothingEnabled = false;

        const potTallTanSprite = new Image();
        potTallTanSprite.src = 'assets/sprites/tall-pot.png';
        potTallTanSprite.imageSmoothingEnabled = false;

        const potShortGreySprite = new Image();
        potShortGreySprite.src = 'assets/sprites/short-pot.png';
        potShortGreySprite.imageSmoothingEnabled = false;

        const potPoleSprite = new Image();
        potPoleSprite.src = 'assets/sprites/pot-pole.png';
        potPoleSprite.imageSmoothingEnabled = false;

      const brushSprite = new Image();
      brushSprite.src = 'assets/sprites/brush.png';
        brushSprite.imageSmoothingEnabled = false;

      const dirtSprite = new Image();
      dirtSprite.src = 'assets/sprites/dirt.png';
        dirtSprite.imageSmoothingEnabled = false;

      const moneyBorderSprite = new Image();
      moneyBorderSprite.src = 'assets/sprites/money_border.png';
        moneyBorderSprite.imageSmoothingEnabled = false;

        const grassSprite = new Image();
        grassSprite.src = 'assets/sprites/Grass.png';
        grassSprite.imageSmoothingEnabled = false;

      const oldGuySprite = new Image();
      oldGuySprite.src = 'assets/sprites/oldguy.png';
        oldGuySprite.imageSmoothingEnabled = false;
      const shopkeeperSprite = new Image();
      shopkeeperSprite.src = 'assets/sprites/shopkeeper.png';
      shopkeeperSprite.imageSmoothingEnabled = false; // Pixelated rendering

      // Load player sprites from PNG images
      const playerSpriteIdle = new Image();
      playerSpriteIdle.src = 'assets/sprites/player.png';
      playerSpriteIdle.imageSmoothingEnabled = false; // Pixelated rendering

      const playerSpriteBack = new Image();
      playerSpriteBack.src = 'assets/sprites/player_back.png';
      playerSpriteBack.imageSmoothingEnabled = false; // Pixelated rendering

      const playerSpriteBackWalk1 = new Image();
      playerSpriteBackWalk1.src = 'assets/sprites/player_back_walk1.png';
      playerSpriteBackWalk1.imageSmoothingEnabled = false; // Pixelated rendering

      const playerSpriteBackWalk2 = new Image();
      playerSpriteBackWalk2.src = 'assets/sprites/player_back_walk2.png';
      playerSpriteBackWalk2.imageSmoothingEnabled = false; // Pixelated rendering

      const playerSpriteWalk1 = new Image();
      playerSpriteWalk1.src = 'assets/sprites/player_walk1.png';
      playerSpriteWalk1.imageSmoothingEnabled = false; // Pixelated rendering

      const playerSpriteWalk2 = new Image();
      playerSpriteWalk2.src = 'assets/sprites/player_walk2.png';
      playerSpriteWalk2.imageSmoothingEnabled = false; // Pixelated rendering

        const playerSpriteCrouch1 = new Image();
        playerSpriteCrouch1.src = 'assets/sprites/crouch-one.png';
        playerSpriteCrouch1.imageSmoothingEnabled = false; // Pixelated rendering

        const playerSpriteCrouch2 = new Image();
        playerSpriteCrouch2.src = 'assets/sprites/crouch-two.png';
        playerSpriteCrouch2.imageSmoothingEnabled = false; // Pixelated rendering

      // Walking animation state
      let walkAnimationFrame = 0;
      const walkAnimationSpeed = 0.15; // How fast the animation cycles (lower = faster)

        // Crouch animation state (plays before starting minigame)
        const crouchAnimation = {
          active: false,
          timer: 0,
          duration: 1.0, // 1 second
          pendingMinigame: null, // Stores which minigame to start after animation
          particles: [], // Particle effects during animation
        };

      function createTileCanvas(drawFn) {
        const buffer = document.createElement('canvas');
        buffer.width = tileSize;
        buffer.height = tileSize;
        const bctx = buffer.getContext('2d');
          // Disable image smoothing for pixel art
          bctx.imageSmoothingEnabled = false;
        drawFn(bctx);
        return buffer;
      }

      const colors = {
        grassBase: '#28a933',
        grassBright: '#36c843',
        grassDark: '#1e902a',
        outline: '#0c0c0c',
        rockLight: '#c2c2c2',
        rockMid: '#959595',
        rockDark: '#5f5f5f',
        rockShadow: '#3f3f3f',
        moundOuter: '#0c3f16',
        moundInner: '#0f5c1f',
        moundHighlight: '#157f2d',
        logLight: '#147429',
        logDark: '#0e5a20',
        logShadow: '#094217',
        redDark: '#780808',
        redBase: '#c40f0f',
          redBright: '#ff2a2a',
      };

      function fillCell(ctx, cx, cy, color) {
        ctx.fillStyle = color;
        ctx.fillRect(cx * tileCell, cy * tileCell, tileCell, tileCell);
      }

      function drawPlus(ctx, cx, cy, color) {
        fillCell(ctx, cx, cy, color);
        fillCell(ctx, cx - 1, cy, color);
        fillCell(ctx, cx + 1, cy, color);
        fillCell(ctx, cx, cy - 1, color);
        fillCell(ctx, cx, cy + 1, color);
      }

      function paintGrassBase(ctx, plusLayout) {
        ctx.fillStyle = colors.grassBase;
        ctx.fillRect(0, 0, tileSize, tileSize);
        const layout = plusLayout || [
          { x: 2, y: 2, color: colors.grassBright },
          { x: 5, y: 4, color: colors.grassBright },
          { x: 1, y: 5, color: colors.grassDark },
            { x: 6, y: 1, color: colors.grassDark },
        ];
        layout.forEach((plus) => drawPlus(ctx, plus.x, plus.y, plus.color));
      }

      const tileDefinitions = [
        {
          name: 'grass',
          weight: 110,
          draw(ctx) {
              // Always use grass sprite
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
            },
        },
        {
          name: 'singleRock',
          weight: 10,
          draw(ctx) {
              // Always use grass sprite
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
            const x = tileCell * 1;
            const y = tileCell * 1;
            const width = tileCell * 6;
            const height = tileCell * 6;
            ctx.fillStyle = colors.outline;
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = colors.rockDark;
              ctx.fillRect(
                x + tileCell,
                y + tileCell,
                width - tileCell * 2,
                height - tileCell * 2
              );
            ctx.fillStyle = colors.rockMid;
              ctx.fillRect(
                x + tileCell * 2,
                y + tileCell * 2,
                width - tileCell * 4,
                height - tileCell * 3
              );
            ctx.fillStyle = colors.rockLight;
              ctx.fillRect(
                x + tileCell * 2,
                y + tileCell * 2,
                width - tileCell * 5,
                height - tileCell * 5
              );
            ctx.fillStyle = colors.rockShadow;
              ctx.fillRect(
                x + tileCell * 2,
                y + tileCell * 4,
                width - tileCell * 4,
                tileCell * 2
              );
            },
        },
        {
          name: 'rockCluster',
          weight: 8,
          draw(ctx) {
              // Always use grass sprite
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
            const cluster = [
              { x: 1, y: 2, w: 3, h: 3, light: colors.rockMid },
              { x: 4, y: 1, w: 3, h: 3, light: colors.rockLight },
              { x: 3, y: 4, w: 4, h: 3, light: colors.rockDark },
                { x: 0, y: 4, w: 3, h: 3, light: colors.rockMid },
            ];
            cluster.forEach((rock) => {
              ctx.fillStyle = colors.outline;
                ctx.fillRect(
                  rock.x * tileCell,
                  rock.y * tileCell,
                  rock.w * tileCell,
                  rock.h * tileCell
                );
              ctx.fillStyle = rock.light;
                ctx.fillRect(
                  (rock.x + 0.5) * tileCell,
                  (rock.y + 0.5) * tileCell,
                  (rock.w - 1) * tileCell,
                  (rock.h - 1) * tileCell
                );
              ctx.fillStyle = colors.rockShadow;
                ctx.fillRect(
                  (rock.x + 0.5) * tileCell,
                  (rock.y + rock.h - 1) * tileCell,
                  (rock.w - 1.2) * tileCell,
                  tileCell
                );
              });
            },
        },
        {
          name: 'moundedBush',
          weight: 7,
          draw(ctx) {
              // Always use grass sprite
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
            const x = tileCell;
            const y = tileCell * 2;
            const w = tileCell * 6;
            const h = tileCell * 4;
            ctx.fillStyle = colors.outline;
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = colors.moundOuter;
              ctx.fillRect(
                x + tileCell,
                y + tileCell,
                w - tileCell * 2,
                h - tileCell * 2
              );
            ctx.fillStyle = colors.moundInner;
              ctx.fillRect(
                x + tileCell * 1.5,
                y + tileCell * 1.5,
                w - tileCell * 3,
                h - tileCell * 3
              );
            ctx.fillStyle = colors.moundHighlight;
              ctx.fillRect(
                x + tileCell * 2,
                y + tileCell * 1.5,
                w - tileCell * 4,
                tileCell * 2
              );
            },
        },
        {
          name: 'logRows',
          weight: 5,
          draw(ctx) {
              // Always use grass sprite
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
            const startX = tileCell;
            const width = tileCell * 6;
            const logHeight = tileCell * 2;
            const spacing = tileCell * 2;
            for (let i = 0; i < 2; i++) {
              const y = tileCell + i * (logHeight + spacing);
              ctx.fillStyle = colors.outline;
              ctx.fillRect(startX, y, width, logHeight);
              ctx.fillStyle = colors.logDark;
                ctx.fillRect(
                  startX + tileCell,
                  y + tileCell / 2,
                  width - tileCell * 2,
                  logHeight - tileCell
                );
              ctx.fillStyle = colors.logLight;
                ctx.fillRect(
                  startX + tileCell,
                  y + tileCell / 2,
                  width - tileCell * 2,
                  logHeight - tileCell * 1.5
                );
                for (
                  let notch = startX + tileCell;
                  notch < startX + width - tileCell;
                  notch += tileCell * 1.5
                ) {
                ctx.fillStyle = colors.logShadow;
                  ctx.fillRect(
                    notch,
                    y + tileCell / 2,
                    tileCell / 2,
                    logHeight - tileCell
                  );
                }
              }
            },
        },
        {
          name: 'redX',
            weight: 2, // Reduced to 1/3 of original weight (5 -> 2)
          draw(ctx) {
              // Always use grass sprite
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
            const maxIndex = cellsPerTile - 1;
            for (let y = 0; y < cellsPerTile; y++) {
              for (let x = 0; x < cellsPerTile; x++) {
                const diag1 = Math.abs(x - y);
                const diag2 = Math.abs(x + y - maxIndex);
                const onX = diag1 <= 1 || diag2 <= 1;
                if (!onX) continue;
                let color = colors.redBase;
                if (diag1 === 0 && diag2 === 0) {
                  color = colors.redBright;
                  } else if (
                    diag1 === 1 ||
                    diag2 === 1 ||
                    x === 0 ||
                    y === 0 ||
                    x === maxIndex ||
                    y === maxIndex
                  ) {
                  color = colors.redDark;
                }
                fillCell(ctx, x, y, color);
              }
            }
            },
          },
          {
            name: 'secretX',
            weight: 1, // Rarer than redX tiles (redX is 2)
            draw(ctx) {
              // Always use grass sprite
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(grassSprite, 0, 0, tileSize, tileSize);
              const maxIndex = cellsPerTile - 1;
              for (let y = 0; y < cellsPerTile; y++) {
                for (let x = 0; x < cellsPerTile; x++) {
                  const diag1 = Math.abs(x - y);
                  const diag2 = Math.abs(x + y - maxIndex);
                  const onX = diag1 <= 1 || diag2 <= 1;
                  if (!onX) continue;
                  let color = colors.secretGold;
                  if (diag1 === 0 && diag2 === 0) {
                    color = colors.secretGoldBright;
                  } else if (
                    diag1 === 1 ||
                    diag2 === 1 ||
                    x === 0 ||
                    y === 0 ||
                    x === maxIndex ||
                    y === maxIndex
                  ) {
                    color = colors.secretGoldDark;
                  }
                  fillCell(ctx, x, y, color);
                }
              }
            },
          },
        ];

        const tileWeightTotal = tileDefinitions.reduce(
          (sum, t) => sum + t.weight,
          0
        );

      function pickTileDefinition() {
        let roll = Math.random() * tileWeightTotal;
        for (const def of tileDefinitions) {
          if ((roll -= def.weight) <= 0) {
            return def;
          }
        }
        return tileDefinitions[0];
      }

      // Helper function to check if a tile position overlaps with any tree
      function isTreeAtTile(row, col) {
        const tileCenterX = (col + 0.5) * tileSize;
        const tileCenterY = (row + 0.5) * tileSize;

        for (let i = 0; i < flora.trees.length; i++) {
          const tree = flora.trees[i];
          const dx = tree.x - tileCenterX;
          const dy = tree.y - tileCenterY;
          const distSq = dx * dx + dy * dy;
          const treeRadius = tree.colliderRadius || tree.size * 0.42;
            const minDistSq =
              (tileSize / 2 + treeRadius) * (tileSize / 2 + treeRadius);

          if (distSq < minDistSq) {
            return true;
          }
        }
        return false;
      }

      // Generate tiles with check for trees
      const tileMap = [];
      for (let row = 0; row < tileRows; row++) {
        tileMap[row] = [];
        for (let col = 0; col < tileCols; col++) {
          let def = pickTileDefinition();

            // If redX or secretX tile was picked and there's a tree at this position, replace with grass
            if (
              (def.name === 'redX' || def.name === 'secretX') &&
              isTreeAtTile(row, col)
            ) {
              def = tileDefinitions.find((d) => d.name === 'grass');
          }

          tileMap[row][col] = {
            name: def.name,
              canvas: createTileCanvas(def.draw),
          };
        }
      }

      const player = {
        x: world.width / 2,
        y: world.height - 40,
        width: 43,
        height: 43,
        color: '#7cffb3', // Original teal/green player color
        outline: '#0c2a19',
        vx: 0,
        vy: 0,
        maxSpeed: 2.0,
        accel: 0.25,
        friction: 0.86,
        sprintMultiplier: 1.6,
          radius: Math.max(39, 39) * 0.5, // Cache radius calculation
      };

      // Stamina system for sprinting
      const stamina = {
        current: 100,
        max: 100,
          drainPerSecond: 35, // how fast stamina drains while sprinting
          regenPerSecond: 22, // how fast stamina regenerates when not sprinting
          minToSprint: 8, // must have at least this much to initiate sprint
          exhausted: false, // when true, cannot sprint until fully recovered
      };

      // Cache gradients for stamina bar (created once, reused)
      let staminaBarGradients = null;
      function initStaminaGradients() {
        if (staminaBarGradients) return; // Already initialized
        const barW = 220;
        const barX = 16.5;
          const normalGradient = ctx.createLinearGradient(
            barX,
            0,
            barX + barW,
            0
          );
        normalGradient.addColorStop(0, '#51ff8a'); // Original teal/green
        normalGradient.addColorStop(1, '#7cffb3'); // Original teal/green
          const exhaustedGradient = ctx.createLinearGradient(
            barX,
            0,
            barX + barW,
            0
          );
        exhaustedGradient.addColorStop(0, '#ff4d4f');
        exhaustedGradient.addColorStop(1, '#ff7875');
          staminaBarGradients = {
            normal: normalGradient,
            exhausted: exhaustedGradient,
          };
      }

      // Money system
      const money = {
          amount: 0,
        };

        // Game over state
        const gameOver = {
          active: false,
          message:
            'Your museum lost funding after displaying too many fakes. Try again!',
      };

      // Shop system
      const shop = {
        open: false,
        items: [
            { name: 'Simple shovel', tier: 1, price: 25 },
            { name: 'Iron Shovel', tier: 2, price: 200 },
            { name: 'Steel Shovel', tier: 3, price: 350 },
            { name: 'Diamond Shovel', tier: 4, price: 500 },
            { name: 'Legendary Shovel', tier: 5, price: 2000 },
          ],
      };

      // Shopkeeper NPC
      const shopkeeper = {
        x: world.width - 100,
        y: world.height - 100,
        radius: 20,
        dialogue: null, // Current dialogue text
        dialogueStage: 0, // 0 = none, 1 = "Hello", 2 = "What would you like?"
          dialogueTimer: 0,
      };

      // Tutorial dialogue system
      const tutorial = {
        active: true, // Show tutorial dialogue when game starts
          dialogue: 'Hey! Over here!',
      };

      // Old Guy NPC (positioned to the right of spawn)
      const oldGuy = {
        x: world.width / 2 + 150, // To the right of spawn
        y: world.height - 40, // Same Y as spawn
        radius: 20,
        dialogue: null, // Current dialogue text
        dialogueStage: 0, // Track which dialogue to show (0-5 for initial sequence)
          hasCompletedIntro: false, // Track if player has completed initial dialogue sequence
      };

      // Inventory system
      const inventory = {
        open: false,
        slots: Array(15).fill(null), // 15 inventory slots
          equipment: null, // 1 equipment slot
      };

      const keys = Object.create(null);
      const keyJustPressed = Object.create(null); // Track keys that were just pressed this frame
      const pressed = (code) => keys[code] === true;

        window.addEventListener(
          'keydown',
          (e) => {
        if (!keys[e.code]) {
          keyJustPressed[e.code] = true; // Mark as just pressed
        }
        keys[e.code] = true;
        // Prevent arrow keys from scrolling
            if (
              [
                'ArrowUp',
                'ArrowDown',
                'ArrowLeft',
                'ArrowRight',
                'Space',
              ].includes(e.code)
            ) {
          e.preventDefault();
        }
        // Toggle inventory with E
        if (e.code === 'KeyE') {
          e.preventDefault();
              // Don't allow opening inventory during minigame or game over
              if (
                balancingMinigame.active ||
                brushingMinigame.active ||
                declarationMinigame.active ||
                gameOver.active
              ) {
            return;
          }
          // Close shop if open
          if (shop.open) {
            shop.open = false;
            shopkeeper.dialogue = null;
            shopkeeper.dialogueStage = 0;
          }
          const wasOpen = inventory.open;
          inventory.open = !inventory.open;
          // Kill momentum when opening inventory
          if (!wasOpen && inventory.open) {
            player.vx = 0;
            player.vy = 0;
          }
        }

        // Interaction key Spacebar
        if (e.code === 'Space') {
          e.preventDefault();
              // Don't allow interaction during crouch animation or minigames (minigames use spacebar for their own mechanics)
              if (
                crouchAnimation.active ||
                balancingMinigame.active ||
                brushingMinigame.active ||
                declarationMinigame.active
              ) {
            return;
          }
          // If shop is open, close it
          if (shop.open) {
            shop.open = false;
            shopkeeper.dialogue = null;
            shopkeeper.dialogueStage = 0;
            player.vx = 0;
            player.vy = 0;
          }
          // If dialogue is showing, close it
          else if (tutorial.active) {
            tutorial.active = false; // Close tutorial
            player.vx = 0;
            player.vy = 0;
          } else if (shopkeeper.dialogue || oldGuy.dialogue) {
            if (shopkeeper.dialogue) {
              advanceShopkeeperDialogue();
            } else if (oldGuy.dialogue) {
              advanceOldGuyDialogue(); // Advance through dialogue stages
              player.vx = 0;
              player.vy = 0;
            }
          } else {
            // Otherwise, try to interact
            handleInteraction();
          }
        }

        // Number keys for shop purchases
        if (shop.open) {
          const keyNum = parseInt(e.key);
          if (keyNum >= 1 && keyNum <= 5) {
            e.preventDefault();
            purchaseItem(keyNum - 1);
          }
        }

            // Declaration minigame: Removed keyboard controls, now uses buttons

            // Game over: Space to restart
            if (gameOver.active && e.code === 'Space') {
              e.preventDefault();
              // Reset game state
              gameOver.active = false;
              money.amount = 0;
              // Reset player position
              player.x = world.width / 2;
              player.y = world.height - 40;
              player.vx = 0;
              player.vy = 0;
            }
          },
          { passive: false }
        );

      window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
        keyJustPressed[e.code] = false;
      });

        // Track mouse position for hover effects
        let mouseX = 0;
        let mouseY = 0;

        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          // Account for canvas scaling - convert display coordinates to internal canvas coordinates
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          mouseX = (e.clientX - rect.left) * scaleX;
          mouseY = (e.clientY - rect.top) * scaleY;
        });

        // Mouse click handling for buttons
        canvas.addEventListener('click', (e) => {
          const rect = canvas.getBoundingClientRect();
          // Account for canvas scaling - convert display coordinates to internal canvas coordinates
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          // Declaration minigame buttons
          if (declarationMinigame.active && !declarationMinigame.answered) {
            // Calculate button positions (same as in render function)
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            const buttonY = panelY + panelHeight - 80;
            const buttonWidth = 150;
            const buttonHeight = 40;
            const buttonSpacing = 20;
            const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
            const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

            // Display button (left)
            const displayButtonX = buttonStartX;
            if (
              x >= displayButtonX &&
              x <= displayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleDeclarationAnswer(true); // Display = Real
              return;
            }

            // Throw away button (right)
            const throwAwayButtonX = buttonStartX + buttonWidth + buttonSpacing;
            if (
              x >= throwAwayButtonX &&
              x <= throwAwayButtonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              handleDeclarationAnswer(false); // Throw away = Fake
              return;
            }
          }
        });

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function update(dtMs) {
        const dt = (dtMs || 16.67) / 1000; // seconds

          // Only update player movement if inventory is closed, shop is closed, dialogue is not showing, tutorial is not active, crouch animation is not active, and minigame is not active
          if (
            !inventory.open &&
            !shop.open &&
            !shopkeeper.dialogue &&
            !oldGuy.dialogue &&
            !tutorial.active &&
            !crouchAnimation.active &&
            !balancingMinigame.active &&
            !brushingMinigame.active &&
            !declarationMinigame.active &&
            !gameOver.active
          ) {
          const wantsSprint = pressed('ShiftLeft') || pressed('ShiftRight');

          // Decouple boost from draining so the bar can reach 0
            const hasInput =
              pressed('ArrowLeft') ||
              pressed('KeyA') ||
              pressed('ArrowRight') ||
              pressed('KeyD') ||
              pressed('ArrowUp') ||
              pressed('KeyW') ||
              pressed('ArrowDown') ||
              pressed('KeyS');
            const allowBoost =
              wantsSprint &&
              !stamina.exhausted &&
              stamina.current >= stamina.minToSprint;
            const shouldDrain =
              wantsSprint &&
              !stamina.exhausted &&
              hasInput &&
              stamina.current > 0;

            const accel = allowBoost
              ? player.accel * player.sprintMultiplier
              : player.accel;
            const maxSpeed = allowBoost
              ? player.maxSpeed * player.sprintMultiplier
              : player.maxSpeed;

          // Input axes
          let ax = 0;
          let ay = 0;
          if (pressed('ArrowLeft') || pressed('KeyA')) ax -= accel;
          if (pressed('ArrowRight') || pressed('KeyD')) ax += accel;
          if (pressed('ArrowUp') || pressed('KeyW')) ay -= accel;
          if (pressed('ArrowDown') || pressed('KeyS')) ay += accel;

          player.vx += ax;
          player.vy += ay;

          // Apply friction only when no input along that axis to keep controls snappy
          if (ax === 0) player.vx *= player.friction;
          if (ay === 0) player.vy *= player.friction;

          // Cap speed
          const speed = Math.hypot(player.vx, player.vy);
          if (speed > maxSpeed) {
            const s = maxSpeed / speed;
            player.vx *= s;
            player.vy *= s;
          }

        player.x += player.vx;
        player.y += player.vy;

        resolveTreeCollisions();
        resolveShopkeeperCollision();
        resolveOldGuyCollision();

        // Update walking animation with speed based on sprinting
        const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
        if (isMoving) {
          // 75% slower when walking, 125% faster when sprinting
          const animationMultiplier = allowBoost ? 1.25 : 0.75;
              walkAnimationFrame +=
                dt * 60 * walkAnimationSpeed * animationMultiplier; // Normalize to 60fps
        } else {
          walkAnimationFrame = 0; // Reset to idle when not moving
        }

          // Stamina update
          if (shouldDrain) {
            stamina.current -= stamina.drainPerSecond * dt;
          } else {
            stamina.current += stamina.regenPerSecond * dt;
          }
          stamina.current = clamp(stamina.current, 0, stamina.max);

          // Exhaustion rules: lock sprint when empty until fully refilled
          if (stamina.current <= 0.0001) {
            stamina.exhausted = true;
          } else if (stamina.current >= stamina.max - 0.0001) {
            stamina.exhausted = false;
          }

          // World bounds (keep player fully inside)
          const halfW = player.width / 2;
          const halfH = player.height / 2;
          player.x = clamp(player.x, halfW, world.width - halfW);
          player.y = clamp(player.y, halfH, world.height - halfH);
        }

        // Clear keyJustPressed at end of frame
          Object.keys(keyJustPressed).forEach(
            (key) => (keyJustPressed[key] = false)
          );

        // Camera follow (smoothly move camera toward player)
        const targetX = player.x;
        const targetY = player.y;
        camera.x += (targetX - camera.x) * camera.followLerp;
        camera.y += (targetY - camera.y) * camera.followLerp;

        // Clamp camera so it doesn't show outside world
        const halfViewW = canvas.width / 2;
        const halfViewH = canvas.height / 2;
        camera.x = clamp(camera.x, halfViewW, world.width - halfViewW);
        camera.y = clamp(camera.y, halfViewH, world.height - halfViewH);

        // Round camera to integer pixels to prevent sub-pixel jitter
        // This ensures the translate() call produces consistent pixel-aligned results
        camera.x = Math.round(camera.x);
        camera.y = Math.round(camera.y);

          // Update crouch animation
          if (crouchAnimation.active) {
            const dt = dtMs / 1000; // Convert to seconds
            crouchAnimation.timer += dt;

            // Create particles during animation (small dirt particles)
            if (crouchAnimation.timer < crouchAnimation.duration) {
              // Emit particles continuously during animation
              const particleEmitRate = 30; // particles per second
              const particlesToEmit = particleEmitRate * dt;
              for (let i = 0; i < particlesToEmit; i++) {
                // Convert player world position to screen position for particles
                const screenX = player.x - camera.x + canvas.width / 2;
                const screenY = player.y - camera.y + canvas.height / 2;

                crouchAnimation.particles.push({
                  x: screenX + (Math.random() - 0.5) * 20,
                  y: screenY + (Math.random() - 0.5) * 20,
                  vx: (Math.random() - 0.5) * 60,
                  vy: (Math.random() - 0.5) * 60 - 20, // Slight upward bias
                  life: 1.0,
                  size: Math.random() * 2 + 1,
                });
              }
            }

            // Update particles
            for (let i = crouchAnimation.particles.length - 1; i >= 0; i--) {
              const p = crouchAnimation.particles[i];
              p.x += p.vx * dt;
              p.y += p.vy * dt;
              p.vy += 80 * dt; // Gravity
              p.life -= dt * 2; // Fade out over 0.5 seconds

              // Remove dead particles
              if (p.life <= 0) {
                crouchAnimation.particles.splice(i, 1);
              }
            }

            // After 1 second, start the pending minigame (if any) or just end animation
            if (crouchAnimation.timer >= crouchAnimation.duration) {
              if (crouchAnimation.pendingMinigame) {
                startPendingMinigame();
              } else {
                // Just end the animation if no minigame is pending
                crouchAnimation.active = false;
                crouchAnimation.timer = 0;
                crouchAnimation.pendingMinigame = null;
                crouchAnimation.particles = [];
              }
            }
          }

        updateBalancingMinigame(dtMs);
        updateBrushingMinigame(dtMs);
          updateDeclarationMinigame(dtMs);
      }

      function drawGrid() {
        // Performance: Only draw grid if visible (optional - can be disabled entirely if still laggy)
        // For now, keeping it but optimizing viewport calculations
        const step = 50;
        ctx.save();
        ctx.lineWidth = 1;

        // Viewport culling: only draw grid lines visible on screen
        const halfCanvasW = canvas.width / 2;
        const halfCanvasH = canvas.height / 2;
        const viewLeft = camera.x - halfCanvasW;
        const viewTop = camera.y - halfCanvasH;
        const viewRight = camera.x + halfCanvasW;
        const viewBottom = camera.y + halfCanvasH;

        const startX = Math.max(0, Math.floor(viewLeft / step) * step);
          const endX = Math.min(
            world.width,
            Math.ceil(viewRight / step) * step
          );
        const startY = Math.max(0, Math.floor(viewTop / step) * step);
          const endY = Math.min(
            world.height,
            Math.ceil(viewBottom / step) * step
          );

        // Batch strokes by color to reduce state changes
        for (let x = startX; x <= endX; x += step) {
            ctx.strokeStyle =
              x % 200 === 0 ? 'rgba(139,111,71,0.18)' : 'rgba(139,111,71,0.08)'; // Brown grid
          ctx.beginPath();
          ctx.moveTo(x + 0.5, viewTop);
          ctx.lineTo(x + 0.5, viewBottom);
          ctx.stroke();
        }
        for (let y = startY; y <= endY; y += step) {
            ctx.strokeStyle =
              y % 200 === 0 ? 'rgba(139,111,71,0.18)' : 'rgba(139,111,71,0.08)'; // Brown grid
          ctx.beginPath();
          ctx.moveTo(viewLeft, y + 0.5);
          ctx.lineTo(viewRight, y + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawTiles() {
        ctx.save();
        // Viewport culling: only draw tiles visible on screen
        const viewLeft = camera.x - canvas.width / 2;
        const viewTop = camera.y - canvas.height / 2;
        const viewRight = camera.x + canvas.width / 2;
        const viewBottom = camera.y + canvas.height / 2;

        const startRow = Math.max(0, Math.floor(viewTop / tileSize) - 1);
          const endRow = Math.min(
            tileRows - 1,
            Math.ceil(viewBottom / tileSize) + 1
          );
        const startCol = Math.max(0, Math.floor(viewLeft / tileSize) - 1);
          const endCol = Math.min(
            tileCols - 1,
            Math.ceil(viewRight / tileSize) + 1
          );

        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            const tile = tileMap[row][col];
            if (tile && tile.canvas) {
              // Draw tiles at exact integer pixel positions to prevent seams
              // Add 1px overlap to eliminate gaps between tiles
              const tileX = Math.floor(col * tileSize);
              const tileY = Math.floor(row * tileSize);
                ctx.drawImage(
                  tile.canvas,
                  tileX,
                  tileY,
                  tileSize + 1,
                  tileSize + 1
                );
            }
          }
        }
        ctx.restore();
      }

      function resolveTreeCollisions() {
        const playerRadius = player.radius; // Use cached radius
        const maxCheckDistance = 150;
        const maxCheckDistanceSq = maxCheckDistance * maxCheckDistance;

        // Early exit optimization: use squared distances to avoid sqrt
        for (let i = 0; i < flora.trees.length; i++) {
          const tree = flora.trees[i];
          const dx = player.x - tree.x;
          const dy = player.y - tree.y;
          const distSq = dx * dx + dy * dy;

          // Quick distance check first (no sqrt needed)
          if (distSq > maxCheckDistanceSq) continue;

          const treeRadius = tree.colliderRadius;
          const minDist = treeRadius + playerRadius;
          const minDistSq = minDist * minDist;

            if (distSq < minDistSq && distSq > 0) {
              // Avoid division by zero
            const dist = Math.sqrt(distSq);
            const overlap = minDist - dist;
            const invDist = 1 / dist; // Cache inverse distance
            player.x += dx * invDist * overlap;
            player.y += dy * invDist * overlap;
          }
        }
      }

      function resolveShopkeeperCollision() {
        const playerRadius = player.radius; // Use cached radius
        const dx = player.x - shopkeeper.x;
        const dy = player.y - shopkeeper.y;
        const distSq = dx * dx + dy * dy;
        const minDist = shopkeeper.radius + playerRadius;
        const minDistSq = minDist * minDist;

        if (distSq < minDistSq && distSq > 0) {
          const dist = Math.sqrt(distSq);
          const overlap = minDist - dist;
          const invDist = 1 / dist; // Cache inverse distance
          player.x += dx * invDist * overlap;
          player.y += dy * invDist * overlap;
        }
      }

      function resolveOldGuyCollision() {
        const playerRadius = player.radius; // Use cached radius
        const dx = player.x - oldGuy.x;
        const dy = player.y - oldGuy.y;
        const distSq = dx * dx + dy * dy;
        const minDist = oldGuy.radius + playerRadius;
        const minDistSq = minDist * minDist;

        if (distSq < minDistSq && distSq > 0) {
          const dist = Math.sqrt(distSq);
          const overlap = minDist - dist;
          const invDist = 1 / dist; // Cache inverse distance
          player.x += dx * invDist * overlap;
          player.y += dy * invDist * overlap;
        }
      }

      function advanceShopkeeperDialogue() {
        if (shopkeeper.dialogueStage === 1) {
          // After "Hello", show "What would you like?"
            shopkeeper.dialogue = 'What would you like?';
          shopkeeper.dialogueStage = 2;
        } else if (shopkeeper.dialogueStage === 2) {
          // After "What would you like?", open shop menu
          // Close inventory if open
          if (inventory.open) {
            inventory.open = false;
          }
          shop.open = true;
          shopkeeper.dialogue = null;
          shopkeeper.dialogueStage = 0;
        }
      }

      function advanceOldGuyDialogue() {
        // Progress through the Old Guy's dialogue sequence
        if (!oldGuy.hasCompletedIntro) {
          // Initial dialogue sequence
          oldGuy.dialogueStage++;

          if (oldGuy.dialogueStage === 1) {
              oldGuy.dialogue =
                'Well, here we are. The newly discovered "Battle of the hills" historical site!';
          } else if (oldGuy.dialogueStage === 2) {
              oldGuy.dialogue =
                'It is time for you to uncover the history of this place!';
          } else if (oldGuy.dialogueStage === 3) {
              oldGuy.dialogue = 'Are you ready?';
          } else if (oldGuy.dialogueStage === 4) {
              oldGuy.dialogue = 'Dig up those holes with Spacebar!';
          } else if (oldGuy.dialogueStage >= 5) {
            // Completed the intro sequence
            oldGuy.dialogue = null;
            oldGuy.hasCompletedIntro = true;
            oldGuy.dialogueStage = 0;
          }
        } else {
          // After intro is complete, just close the "hurry up" message
          oldGuy.dialogue = null;
        }
      }

      function handleInteraction() {
        // Don't interact if inventory is open
        if (inventory.open) {
          return;
        }

        // Don't start new dialogue if one is already showing
        if (shopkeeper.dialogue || oldGuy.dialogue) {
          return;
        }

        // Check if player is touching old guy (collision-based)
        const playerRadius = player.radius; // Use cached radius
        let dx = player.x - oldGuy.x;
        let dy = player.y - oldGuy.y;
        let distSq = dx * dx + dy * dy;
        let minDist = oldGuy.radius + playerRadius;
        let minDistSq = minDist * minDist;

        // Allow interaction when very close (within collision distance + small buffer)
        if (distSq <= minDistSq * 1.2) {
          // Set dialogue based on whether intro is completed
          if (!oldGuy.hasCompletedIntro) {
            // Start the intro dialogue sequence
            oldGuy.dialogueStage = 0;
              oldGuy.dialogue = 'Hello there!';
          } else {
            // Show the "hurry up" message after intro is done
              oldGuy.dialogue =
                'What are you waiting for? Get going! Dig those holes with Spacebar!';
          }
          // Kill momentum when opening dialogue
          player.vx = 0;
          player.vy = 0;
          return;
        }

        // Check if player is touching shopkeeper (collision-based)
        dx = player.x - shopkeeper.x;
        dy = player.y - shopkeeper.y;
        distSq = dx * dx + dy * dy;
        minDist = shopkeeper.radius + playerRadius;
        minDistSq = minDist * minDist;

        // Allow interaction when very close (within collision distance + small buffer)
        if (distSq <= minDistSq * 1.2) {
            shopkeeper.dialogue = 'Hello';
          shopkeeper.dialogueStage = 1;
          shopkeeper.dialogueTimer = 0; // Don't auto-close, wait for Spacebar press
          // Kill momentum when opening dialogue
          player.vx = 0;
          player.vy = 0;
          return;
        }

          // Check if player is on a tile (any tile triggers crouch animation)
        const col = Math.floor(player.x / tileSize);
        const row = Math.floor(player.y / tileSize);

        if (row >= 0 && row < tileRows && col >= 0 && col < tileCols) {
          const tile = tileMap[row][col];
            if (tile) {
              // Start crouch animation on any tile (prevents spamming)
              if (!crouchAnimation.active) {
                crouchAnimation.active = true;
                crouchAnimation.timer = 0;
                crouchAnimation.particles = []; // Initialize particles array
                // Only store minigame if on red X or secret X tile, otherwise just play animation
                if (tile.name === 'redX' || tile.name === 'secretX') {
                  // Store which minigame to start after animation
                  const minigameRoll = Math.random();
                  if (minigameRoll < 0.333) {
                    crouchAnimation.pendingMinigame = 'balancing';
                  } else if (minigameRoll < 0.666) {
                    crouchAnimation.pendingMinigame = 'brushing';
                  } else {
                    crouchAnimation.pendingMinigame = 'declaration';
                  }
                  // Store whether this is a secret X tile for later reward multiplier
                  crouchAnimation.isSecretX = tile.name === 'secretX';
                } else {
                  // No minigame for other tiles
                  crouchAnimation.pendingMinigame = null;
                  crouchAnimation.isSecretX = false;
                }
                // Stop player movement during crouch animation
                player.vx = 0;
                player.vy = 0;
              }
              return;
            }
          }
        }

        // Function to start the actual minigame after crouch animation completes
        function startPendingMinigame() {
          const col = Math.floor(player.x / tileSize);
          const row = Math.floor(player.y / tileSize);

          if (crouchAnimation.pendingMinigame === 'balancing') {
            // Start Balancing minigame
              balancingMinigame.active = true;
            balancingMinigame.tileRow = row;
            balancingMinigame.tileCol = col;
            balancingMinigame.isSecretX = crouchAnimation.isSecretX;
              balancingMinigame.potAngle = 0;
            balancingMinigame.potAngularVelocity = 0;
              balancingMinigame.timeRemaining = 15;
            balancingMinigame.breaking = false;
            balancingMinigame.breakTimer = 0;
            balancingMinigame.pieces = [];
            // Initialize stick position to center of screen
              balancingMinigame.stickX = canvas.width / 2;
            balancingMinigame.stickY = canvas.height / 2;
            // Randomly select pot type (equal chance for each)
            const potTypeRoll = Math.random();
            if (potTypeRoll < 0.333) {
              balancingMinigame.potType = 'regular';
            } else if (potTypeRoll < 0.666) {
              balancingMinigame.potType = 'tall';
            } else {
              balancingMinigame.potType = 'short';
            }
          } else if (crouchAnimation.pendingMinigame === 'brushing') {
            // Start Brushing minigame
              brushingMinigame.active = true;
              brushingMinigame.tileRow = row;
              brushingMinigame.tileCol = col;
            brushingMinigame.isSecretX = crouchAnimation.isSecretX;
            brushingMinigame.dirtLevel = 1.0;
            brushingMinigame.redness = 0;
            brushingMinigame.timeHoldingSpace = 0;
            brushingMinigame.redTriggerTime = 3 + Math.random() * 5;
            brushingMinigame.timeSinceRed = 0;
            brushingMinigame.particles = [];
              brushingMinigame.completed = false;
              brushingMinigame.broken = false;
            // Initialize brush position to center of screen (slightly above dirt)
            brushingMinigame.brushX = canvas.width / 2;
            brushingMinigame.brushY = canvas.height / 2 - 40; // Slightly above center
            brushingMinigame.brushOffset = 0;
            brushingMinigame.brushDirection = 1;
          } else if (crouchAnimation.pendingMinigame === 'declaration') {
            // Start Declaration of Independence minigame
            declarationMinigame.active = true;
            declarationMinigame.tileRow = row;
            declarationMinigame.tileCol = col;
            declarationMinigame.isSecretX = crouchAnimation.isSecretX;
            declarationMinigame.answered = false;

            // 50% chance the test excerpt is fake (has typos)
            declarationMinigame.isFake = Math.random() < 0.5;

            if (declarationMinigame.isFake) {
              // Create fake version with random typo
              // Available typos: "sertain", "Celf-Evident", "Craeted", "Unaliable", "Persuit"
              const typoOptions = [
                { from: 'certain', to: 'sertain' },
                { from: 'self-evident', to: 'Celf-Evident' },
                { from: 'created', to: 'Craeted' },
                { from: 'unalienable', to: 'Unaliable' },
                { from: 'pursuit', to: 'Persuit' },
              ];
              // Randomly pick one typo
              const selectedTypo =
                typoOptions[Math.floor(Math.random() * typoOptions.length)];
              declarationMinigame.testExcerpt =
                declarationMinigame.realExcerpt.replace(
                  selectedTypo.from,
                  selectedTypo.to
                );
            } else {
              // Real version (no typos)
              declarationMinigame.testExcerpt = declarationMinigame.realExcerpt;
            }
          }

          // Reset crouch animation
          crouchAnimation.active = false;
          crouchAnimation.timer = 0;
          crouchAnimation.pendingMinigame = null;
      }

      function updateBalancingMinigame(dtMs) {
        if (!balancingMinigame.active) return;

        const dt = dtMs / 1000; // Convert to seconds

        // Player input affects angular velocity
        const leftInput = pressed('ArrowLeft') || pressed('KeyA');
        const rightInput = pressed('ArrowRight') || pressed('KeyD');

          // Get pot type modifiers
          // Tall pot: more susceptible to gravity and balancing (harder)
          // Short pot: less susceptible to gravity and balancing (easier)
          // Regular pot: normal difficulty
          let gravityMultiplier = 1.0;
          let inputMultiplier = 1.0;
          let teeteringMultiplier = 1.0;

          if (balancingMinigame.potType === 'tall') {
            gravityMultiplier = 1.2; // 20% more gravity (reduced from 1.5)
            inputMultiplier = 0.85; // 15% less effective input (reduced from 0.7)
            teeteringMultiplier = 1.2; // 20% more teetering (reduced from 1.4)
          } else if (balancingMinigame.potType === 'short') {
            gravityMultiplier = 0.6; // 40% less gravity
            inputMultiplier = 1.3; // 30% more effective input
            teeteringMultiplier = 0.7; // 30% less teetering
          }

        if (leftInput && !rightInput) {
            balancingMinigame.potAngularVelocity -= 0.2 * dt * inputMultiplier; // Lean left
        } else if (rightInput && !leftInput) {
            balancingMinigame.potAngularVelocity += 0.2 * dt * inputMultiplier; // Lean right
        }

        // Natural physics: pot wants to fall (very strong teetering force)
          const baseGravity = 0.6; // How fast it wants to fall (very strong - requires constant input)
          const gravity = baseGravity * gravityMultiplier;
        const damping = 0.985; // Less friction to allow stronger movement

        // Apply gravity based on current angle (very strong)
          balancingMinigame.potAngularVelocity +=
            Math.sin(balancingMinigame.potAngle) * gravity * dt;

        // Add constant teetering force to make it much harder
          balancingMinigame.potAngularVelocity +=
            Math.sin(balancingMinigame.potAngle * 2) *
            0.18 *
            dt *
            teeteringMultiplier;

        // Add additional random-like teetering force
          balancingMinigame.potAngularVelocity +=
            Math.sin(balancingMinigame.potAngle * 3 + Date.now() * 0.001) *
            0.12 *
            dt *
            teeteringMultiplier;

        // Apply damping
        balancingMinigame.potAngularVelocity *= Math.pow(damping, dt * 60); // Normalize to 60fps

        // Update angle
          balancingMinigame.potAngle +=
            balancingMinigame.potAngularVelocity * dt;

        // Check if pot fell off (angle too extreme - make it easier to lose)
        const maxAngle = Math.PI / 4.5; // About 40 degrees (easier to lose)
          if (
            Math.abs(balancingMinigame.potAngle) > maxAngle &&
            !balancingMinigame.breaking
          ) {
          // Start breaking animation
          balancingMinigame.breaking = true;
          balancingMinigame.breakTimer = 0.5; // 0.5 seconds of breaking animation

          // Create pot pieces flying off
          const potSize = 100;
          const stickX = balancingMinigame.stickX;
          const stickTipY = balancingMinigame.stickY - 25;
            const potContactY = stickTipY + 30; // Match the pot position from drawing code
          const potCenterX = stickX;
          const potCenterY = potContactY - potSize / 2;

          // Create 8-12 pieces
          const numPieces = 10;
          balancingMinigame.pieces = [];
          for (let i = 0; i < numPieces; i++) {
              const angle =
                (Math.PI * 2 * i) / numPieces + balancingMinigame.potAngle;
            const speed = 2 + Math.random() * 3;
            balancingMinigame.pieces.push({
              x: potCenterX,
              y: potCenterY,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed - 1, // Slight upward bias
              rotation: Math.random() * Math.PI * 2,
              rotationSpeed: (Math.random() - 0.5) * 0.3,
              size: 8 + Math.random() * 12,
                opacity: 1.0,
            });
          }
        }

        // Update breaking animation
        if (balancingMinigame.breaking) {
          balancingMinigame.breakTimer -= dt;

          // Update pieces
          for (let i = 0; i < balancingMinigame.pieces.length; i++) {
            const piece = balancingMinigame.pieces[i];
            piece.x += piece.vx * dt * 60;
            piece.y += piece.vy * dt * 60;
            piece.vy += 0.5 * dt * 60; // Gravity
            piece.rotation += piece.rotationSpeed * dt * 60;
            piece.opacity -= dt * 2; // Fade out
          }

          // End minigame after breaking animation
          if (balancingMinigame.breakTimer <= 0) {
              // Failed - give base reward with shovel multiplier and secret X multiplier
            let multiplier = 1.0;
            if (inventory.equipment) {
                if (inventory.equipment.tier === 1)
                  multiplier = 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2) multiplier = 2.0; // Iron shovel
            }
              // Apply 1.5x multiplier for secret X tiles
              if (balancingMinigame.isSecretX) {
                multiplier *= 1.5;
              }
              money.amount += Math.round(
                balancingMinigame.baseReward * multiplier
              );
              const grassDef = tileDefinitions.find(
                (def) => def.name === 'grass'
              );
              if (
                grassDef &&
                balancingMinigame.tileRow !== null &&
                balancingMinigame.tileCol !== null
              ) {
                tileMap[balancingMinigame.tileRow][balancingMinigame.tileCol] =
                  {
                name: grassDef.name,
                    canvas: createTileCanvas(grassDef.draw),
              };
            }
            balancingMinigame.active = false;
            balancingMinigame.breaking = false;
            balancingMinigame.pieces = [];
            return;
          }
        }

        // Update timer
        balancingMinigame.timeRemaining -= dt;

        // Check if succeeded (15 seconds passed)
        if (balancingMinigame.timeRemaining <= 0) {
            // Success - give 3x reward with shovel multiplier and secret X multiplier
          let multiplier = 3.0; // Base success multiplier (3x)
          if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier = 4.5; // Simple shovel: 1.5x * 3 = 4.5x
            else if (inventory.equipment.tier === 2) multiplier = 6.0; // Iron shovel: 2x * 3 = 6x
          }
            // Apply 1.5x multiplier for secret X tiles
            if (balancingMinigame.isSecretX) {
              multiplier *= 1.5;
            }
            money.amount += Math.round(
              balancingMinigame.baseReward * multiplier
            );
            const grassDef = tileDefinitions.find(
              (def) => def.name === 'grass'
            );
            if (
              grassDef &&
              balancingMinigame.tileRow !== null &&
              balancingMinigame.tileCol !== null
            ) {
            tileMap[balancingMinigame.tileRow][balancingMinigame.tileCol] = {
              name: grassDef.name,
                canvas: createTileCanvas(grassDef.draw),
            };
          }
          balancingMinigame.active = false;
        }
      }

      function updateBrushingMinigame(dtMs) {
        if (!brushingMinigame.active) return;

        const dt = dtMs / 1000; // Convert to seconds
        const spacePressed = pressed('Space');

        // Animate brush back and forth when spacebar is held
        if (spacePressed) {
          // Track time holding space
          brushingMinigame.timeHoldingSpace += dt;

          // Animate brush moving back and forth across the dirt
          const brushSpeed = 100; // pixels per second
            brushingMinigame.brushOffset +=
              brushSpeed * dt * brushingMinigame.brushDirection;

          // Reverse direction when reaching edges (60 pixels from center)
          const maxOffset = 60;
          if (brushingMinigame.brushOffset >= maxOffset) {
            brushingMinigame.brushOffset = maxOffset;
            brushingMinigame.brushDirection = -1; // Move left
          } else if (brushingMinigame.brushOffset <= -maxOffset) {
            brushingMinigame.brushOffset = -maxOffset;
            brushingMinigame.brushDirection = 1; // Move right
          }

          // Spawn dirt particles while brushing (only if there's still dirt)
          if (brushingMinigame.dirtLevel > 0 && Math.random() < 0.3) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            brushingMinigame.particles.push({
                x:
                  centerX +
                  brushingMinigame.brushOffset +
                  (Math.random() - 0.5) * 30,
              y: centerY + (Math.random() - 0.5) * 30,
                vx:
                  (Math.random() - 0.5) * 100 +
                  brushingMinigame.brushDirection * 30,
              vy: (Math.random() - 0.5) * 100 - 30, // Fly upward
              life: 1.0, // 0 = dead, 1.0 = fresh
                size: Math.random() * 3 + 2,
            });
          }

          // Brushing reduces dirt level (makes it cleaner)
          brushingMinigame.dirtLevel -= 0.2 * dt;
            brushingMinigame.dirtLevel = Math.max(
              0,
              brushingMinigame.dirtLevel
            );

          // After at least 5 seconds, dirt is cleaned
          if (brushingMinigame.timeHoldingSpace >= 5.0) {
            // Dirt is now clean
            brushingMinigame.dirtLevel = 0;

              // After the random trigger time (3-8 seconds), start red gradient transition
              if (
                brushingMinigame.timeHoldingSpace >=
                  brushingMinigame.redTriggerTime &&
                brushingMinigame.redness < 1.0
              ) {
              // Gradually increase redness over 1 second
                brushingMinigame.redness +=
                  dt / brushingMinigame.redTransitionTime;
                brushingMinigame.redness = Math.min(
                  1.0,
                  brushingMinigame.redness
                );
            }

            // Track time since turning red (only after fully red)
            if (brushingMinigame.redness >= 1.0) {
              brushingMinigame.timeSinceRed += dt;

              // If holding space too long after fully red, you break it (lose)
                if (
                  brushingMinigame.timeSinceRed >
                    brushingMinigame.perfectReleaseWindow &&
                  !brushingMinigame.broken
                ) {
                brushingMinigame.broken = true;
              }
            }
          }
        } else {
          // When not brushing, reset time counter
          brushingMinigame.timeHoldingSpace = 0;

          // Reset brush position to center when not holding space
          brushingMinigame.brushOffset = 0;
          brushingMinigame.brushDirection = 1;

          // If dirt is clean and red, releasing in the perfect window = success!
            if (
              brushingMinigame.dirtLevel <= 0 &&
              brushingMinigame.redness > 0 &&
              !brushingMinigame.completed &&
              !brushingMinigame.broken
            ) {
            // Check if released within the perfect timing window
              if (
                brushingMinigame.timeSinceRed <=
                brushingMinigame.perfectReleaseWindow
              ) {
              brushingMinigame.completed = true; // PERFECT! Maximum reward
            } else {
              brushingMinigame.broken = true; // Missed the window, failed
            }
          }

          // Reset redness when not brushing (dirt returns to normal)
          brushingMinigame.redness = 0;
          brushingMinigame.timeSinceRed = 0;

          // Dirt slowly returns if not fully cleaned
            if (
              brushingMinigame.dirtLevel < 1.0 &&
              !brushingMinigame.completed &&
              !brushingMinigame.broken
            ) {
            brushingMinigame.dirtLevel += 0.15 * dt;
              brushingMinigame.dirtLevel = Math.min(
                1.0,
                brushingMinigame.dirtLevel
              );
          }
        }

        // Update particles
        for (let i = brushingMinigame.particles.length - 1; i >= 0; i--) {
          const p = brushingMinigame.particles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 100 * dt; // Gravity
          p.life -= dt * 2; // Fade out over 0.5 seconds

          // Remove dead particles
          if (p.life <= 0) {
            brushingMinigame.particles.splice(i, 1);
          }
        }

        // End minigame if completed or broken
        if (brushingMinigame.completed || brushingMinigame.broken) {
          // Give reward based on performance
          let multiplier = brushingMinigame.completed ? 3.0 : 1.0; // 3x for perfect timing, 1x for failure
          if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier *= 1.5; // Simple shovel
            else if (inventory.equipment.tier === 2) multiplier *= 2.0; // Iron shovel
          }
            // Apply 1.5x multiplier for secret X tiles
            if (brushingMinigame.isSecretX) {
              multiplier *= 1.5;
            }
            money.amount += Math.round(
              brushingMinigame.baseReward * multiplier
            );

          // Convert tile to grass
            const grassDef = tileDefinitions.find(
              (def) => def.name === 'grass'
            );
            if (
              grassDef &&
              brushingMinigame.tileRow !== null &&
              brushingMinigame.tileCol !== null
            ) {
            tileMap[brushingMinigame.tileRow][brushingMinigame.tileCol] = {
              name: grassDef.name,
                canvas: createTileCanvas(grassDef.draw),
            };
          }

          brushingMinigame.active = false;
        }
      }

        // Handle player's answer in Declaration minigame
        function handleDeclarationAnswer(playerSaidReal) {
          if (declarationMinigame.answered) return; // Already answered

          declarationMinigame.answered = true;

          // Check if player was correct
          // Player said Real (true) and it's actually Real (not fake) = correct
          // Player said Fake (false) and it's actually Fake (isFake = true) = correct
          // Special case: If player calls a real document fake, no penalty (neutral)
          const isCorrect =
            (playerSaidReal && !declarationMinigame.isFake) ||
            (!playerSaidReal && declarationMinigame.isFake);

          // Check if player called a real document fake (neutral outcome)
          const calledRealFake = !playerSaidReal && !declarationMinigame.isFake;

          declarationMinigame.wasCorrect = isCorrect;

          // Calculate reward/penalty
          let actualReward = 0;
          if (isCorrect) {
            // Correct answer: +$50 with shovel multiplier and secret X multiplier
            let multiplier = 1.0;
            if (inventory.equipment) {
              if (inventory.equipment.tier === 1)
                multiplier = 1.5; // Simple shovel
              else if (inventory.equipment.tier === 2)
                multiplier = 2.0; // Iron shovel
              else if (inventory.equipment.tier === 3)
                multiplier = 2.5; // Steel shovel
              else if (inventory.equipment.tier === 4)
                multiplier = 3.0; // Diamond shovel
              else if (inventory.equipment.tier === 5) multiplier = 4.0; // Legendary shovel
            }
            // Apply 1.5x multiplier for secret X tiles
            if (declarationMinigame.isSecretX) {
              multiplier *= 1.5;
            }
            actualReward = Math.round(
              declarationMinigame.baseReward * multiplier
            );
            money.amount += actualReward;
          } else if (calledRealFake) {
            // Called a real document fake: no penalty, no reward (neutral)
            actualReward = 0;
          } else {
            // Wrong answer (called fake document real): -$30 (no shovel multiplier)
            actualReward = -declarationMinigame.penalty;
            money.amount -= declarationMinigame.penalty;
          }

          // Store actual reward for display
          declarationMinigame.actualReward = actualReward;

          // Check for game over (negative cash)
          if (money.amount < 0) {
            gameOver.active = true;
          }

          // Convert tile to grass
          const grassDef = tileDefinitions.find((def) => def.name === 'grass');
          if (
            grassDef &&
            declarationMinigame.tileRow !== null &&
            declarationMinigame.tileCol !== null
          ) {
            tileMap[declarationMinigame.tileRow][declarationMinigame.tileCol] =
              {
                name: grassDef.name,
                canvas: createTileCanvas(grassDef.draw),
              };
          }

          // Close minigame after a short delay to show result
          setTimeout(() => {
            declarationMinigame.active = false;
          }, 1000); // 1 second delay to show result
        }

        function updateDeclarationMinigame(dtMs) {
          if (!declarationMinigame.active) return;
          // Minigame logic is handled by key presses, no continuous updates needed
        }

      const treeSprite = (() => {
        const canvasEl = document.createElement('canvas');
        canvasEl.width = tileCell * 8;
        canvasEl.height = tileCell * 8;
        const c = canvasEl.getContext('2d');
        const treeLayout = [
            { x: 1, y: 0, color: '#0a3c0f' },
            { x: 2, y: 0, color: '#0a3c0f' },
            { x: 3, y: 0, color: '#0a3c0f' },
            { x: 4, y: 0, color: '#0a3c0f' },
            { x: 5, y: 0, color: '#0a3c0f' },
            { x: 0, y: 1, color: '#0a3c0f' },
            { x: 1, y: 1, color: '#075018' },
            { x: 2, y: 1, color: '#0a5f1f' },
            { x: 3, y: 1, color: '#0a5f1f' },
            { x: 4, y: 1, color: '#075018' },
            { x: 5, y: 1, color: '#075018' },
            { x: 6, y: 1, color: '#0a3c0f' },
            { x: 0, y: 2, color: '#0a3c0f' },
            { x: 1, y: 2, color: '#0a5f1f' },
            { x: 2, y: 2, color: '#0c6b24' },
            { x: 3, y: 2, color: '#0c6b24' },
            { x: 4, y: 2, color: '#0a5f1f' },
            { x: 5, y: 2, color: '#075018' },
            { x: 6, y: 2, color: '#0a3c0f' },
            { x: 0, y: 3, color: '#0a3c0f' },
            { x: 1, y: 3, color: '#0a5f1f' },
            { x: 2, y: 3, color: '#0c6b24' },
            { x: 3, y: 3, color: '#0c6b24' },
            { x: 4, y: 3, color: '#0a5f1f' },
            { x: 5, y: 3, color: '#075018' },
            { x: 6, y: 3, color: '#0a3c0f' },
            { x: 0, y: 4, color: '#0a3c0f' },
            { x: 1, y: 4, color: '#0a5f1f' },
            { x: 2, y: 4, color: '#0c6b24' },
            { x: 3, y: 4, color: '#0c6b24' },
            { x: 4, y: 4, color: '#0a5f1f' },
            { x: 5, y: 4, color: '#075018' },
            { x: 6, y: 4, color: '#0a3c0f' },
            { x: 1, y: 5, color: '#0a3c0f' },
            { x: 2, y: 5, color: '#0a5f1f' },
            { x: 3, y: 5, color: '#0a5f1f' },
            { x: 4, y: 5, color: '#075018' },
            { x: 5, y: 5, color: '#0a3c0f' },
            { x: 2, y: 6, color: '#0a3c0f' },
            { x: 3, y: 6, color: '#063310' },
            { x: 4, y: 6, color: '#0a3c0f' },
            { x: 2, y: 7, color: '#0a3c0f' },
            { x: 3, y: 7, color: '#063310' },
            { x: 4, y: 7, color: '#0a3c0f' },
        ];
        treeLayout.forEach(({ x, y, color }) => fillCell(c, x, y, color));
        return canvasEl;
      })();

      // Load shovel sprites from PNG images
      const shovelSprites = {};
      function loadShovelSprite(tier, filename) {
        const sprite = new Image();
        sprite.src = filename;
        sprite.imageSmoothingEnabled = false; // Pixelated rendering
        shovelSprites[tier] = sprite;
        return sprite;
      }

      // Load shovel sprites for each tier
      loadShovelSprite(1, 'assets/sprites/shovel.png'); // Simple shovel
      loadShovelSprite(2, 'assets/sprites/iron-shovel.png'); // Iron Shovel
      // Add more shovel sprites as needed for other tiers

      function drawFlora() {
        // Viewport culling: only draw trees visible on screen
        const halfCanvasW = canvas.width / 2;
        const halfCanvasH = canvas.height / 2;
        const viewLeft = camera.x - halfCanvasW;
        const viewTop = camera.y - halfCanvasH;
        const viewRight = camera.x + halfCanvasW;
        const viewBottom = camera.y + halfCanvasH;
        const padding = 120; // Extra padding to account for tree size
        const spriteHalfW = treeSprite.width / 2;
        const spriteHalfH = treeSprite.height / 2;
        const tileCell8 = tileCell * 8;

        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Set once outside loop

        for (let i = 0; i < flora.trees.length; i++) {
          const tree = flora.trees[i];
          const halfSize = tree.size / 2;

          // Skip trees outside viewport (optimized bounds check)
            if (
              tree.x + halfSize < viewLeft - padding ||
              tree.x - halfSize > viewRight + padding ||
              tree.y + halfSize < viewTop - padding ||
              tree.y - halfSize > viewBottom + padding
            ) {
            continue;
          }

          ctx.save();
          ctx.translate(Math.round(tree.x) + 0.5, Math.round(tree.y) + 0.5);
          ctx.rotate(tree.rotation);

          // Draw shadow
          const shadowRadius = tree.size * 0.45;
          ctx.beginPath();
            ctx.ellipse(
              0,
              tree.size * 0.4,
              shadowRadius,
              tree.size * 0.2,
              0,
              0,
              Math.PI * 2
            );
          ctx.fill();

          // Draw tree
          const scale = tree.size / tileCell8;
          ctx.scale(scale, scale);
          ctx.drawImage(treeSprite, -spriteHalfW, -spriteHalfH);
          ctx.restore();
        }

        ctx.restore();
      }

      function drawShopkeeper() {
        ctx.save();

        // Draw shopkeeper sprite
        if (shopkeeperSprite.complete && shopkeeperSprite.naturalWidth > 0) {
          const spriteWidth = 43; // Match player size
          const spriteHeight = 43;

          // Shopkeeper shadow
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
            ctx.ellipse(
              shopkeeper.x,
              shopkeeper.y + spriteHeight * 0.35,
              spriteWidth * 0.5,
              spriteHeight * 0.22,
              0,
              0,
              Math.PI * 2
            );
          ctx.fill();

          const px = Math.round(shopkeeper.x - spriteWidth / 2);
          const py = Math.round(shopkeeper.y - spriteHeight / 2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(shopkeeperSprite, px, py, spriteWidth, spriteHeight);
        } else {
          // Fallback while loading
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
            ctx.ellipse(
              shopkeeper.x,
              shopkeeper.y + shopkeeper.radius * 0.4,
              shopkeeper.radius * 0.6,
              shopkeeper.radius * 0.2,
              0,
              0,
              Math.PI * 2
            );
          ctx.fill();

          ctx.fillStyle = '#ffd700'; // Yellow/gold color
          ctx.strokeStyle = '#ffaa00';
          ctx.lineWidth = 2;
          ctx.beginPath();
            ctx.arc(
              shopkeeper.x,
              shopkeeper.y,
              shopkeeper.radius,
              0,
              Math.PI * 2
            );
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawOldGuy() {
        ctx.save();

        // Draw old guy sprite
        if (oldGuySprite.complete && oldGuySprite.naturalWidth > 0) {
          // Scale to match player size (43x43, 10% bigger than original 39x39)
          const spriteWidth = 43;
          const spriteHeight = 43;

          // Old guy shadow
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
            ctx.ellipse(
              oldGuy.x,
              oldGuy.y + spriteHeight * 0.35,
              spriteWidth * 0.5,
              spriteHeight * 0.22,
              0,
              0,
              Math.PI * 2
            );
          ctx.fill();

          const px = Math.round(oldGuy.x - spriteWidth / 2);
          const py = Math.round(oldGuy.y - spriteHeight / 2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(oldGuySprite, px, py, spriteWidth, spriteHeight);
        }

        ctx.restore();
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // World space: translate so that camera is centered
        ctx.save();
          ctx.translate(
            Math.round(canvas.width / 2 - camera.x),
            Math.round(canvas.height / 2 - camera.y)
          );

        drawTiles();
        drawGrid();
        drawFlora();

        // Shopkeeper NPC
        drawShopkeeper();

        // Old Guy NPC
        drawOldGuy();

        // Player shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
          ctx.ellipse(
            player.x,
            player.y + player.height * 0.35,
            player.width * 0.5,
            player.height * 0.22,
            0,
            0,
            Math.PI * 2
          );
        ctx.fill();

        // Player sprite - use back sprite when moving upward, walking sprites when moving
        const isMoving = Math.hypot(player.vx, player.vy) > 0.1;
        const isMovingUp = player.vy < -0.1; // Small threshold to prevent flickering
        let currentSprite;

          // Show crouch animation when active (semi-rapidly switches between crouch sprites)
          if (crouchAnimation.active) {
            // Switch between crouch sprites every 0.15 seconds (semi-rapid animation)
            const crouchFrame = Math.floor(crouchAnimation.timer / 0.15) % 2;
            currentSprite =
              crouchFrame === 0 ? playerSpriteCrouch1 : playerSpriteCrouch2;
          } else if (isMovingUp) {
          // Alternate between back walk sprites when moving up
          if (isMoving) {
            const walkFrame = Math.floor(walkAnimationFrame) % 2;
              currentSprite =
                walkFrame === 0 ? playerSpriteBackWalk1 : playerSpriteBackWalk2;
          } else {
            // Use idle back sprite when not moving but facing up
            currentSprite = playerSpriteBack;
          }
        } else if (isMoving) {
          // Alternate between walk sprites when moving
          const walkFrame = Math.floor(walkAnimationFrame) % 2;
            currentSprite =
              walkFrame === 0 ? playerSpriteWalk1 : playerSpriteWalk2;
        } else {
          // Use idle sprite when not moving
          currentSprite = playerSpriteIdle;
        }

        if (currentSprite.complete && currentSprite.naturalWidth > 0) {
          const px = Math.round(player.x - player.width / 2);
          const py = Math.round(player.y - player.height / 2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(currentSprite, px, py, player.width, player.height);
        } else {
          // Fallback while loading
          ctx.fillStyle = player.color;
          ctx.strokeStyle = player.outline;
          ctx.lineWidth = 2;
          ctx.beginPath();
            ctx.rect(
              Math.round(player.x - player.width / 2) + 0.5,
              Math.round(player.y - player.height / 2) + 0.5,
              player.width,
              player.height
            );
          ctx.fill();
          ctx.stroke();
        }

        // Direction indicator - small black arrow triangle
        const dirX = player.vx;
        const dirY = player.vy;
        const speedSq = dirX * dirX + dirY * dirY;
          if (speedSq > 0.04) {
            // 0.2^2 = 0.04
          const speed = Math.sqrt(speedSq);
          const nx = dirX / speed;
          const ny = dirY / speed;

          // Position arrow outside player bounds (player radius + offset)
          const playerRadius = Math.max(player.width, player.height) / 2;
          const arrowDistance = playerRadius + 12; // Distance from player center
          const arrowX = player.x + nx * arrowDistance;
          const arrowY = player.y + ny * arrowDistance;

          // Draw small black triangle arrow
          const arrowSize = 6; // Size of the arrow
          const angle = Math.atan2(ny, nx);

          ctx.save();
          ctx.fillStyle = '#000000'; // Black arrow
          ctx.translate(arrowX, arrowY);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(arrowSize, 0); // Tip of arrow
          ctx.lineTo(-arrowSize * 0.6, -arrowSize * 0.6); // Bottom left
          ctx.lineTo(-arrowSize * 0.6, arrowSize * 0.6); // Bottom right
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }

        // Optional: draw world bounds
        ctx.strokeStyle = 'rgba(139,111,71,0.25)'; // Brown world bounds
        ctx.lineWidth = 2;
        ctx.strokeRect(0.5, 0.5, world.width - 1, world.height - 1);

        // End world space
        ctx.restore();

          // Draw crouch animation particles (screen space)
          if (crouchAnimation.active && crouchAnimation.particles.length > 0) {
            ctx.save();
            for (const p of crouchAnimation.particles) {
              ctx.globalAlpha = p.life; // Fade out as life decreases
              ctx.fillStyle = '#8b4513'; // Brown dirt color
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }

        // UI: Stamina bar (top-left, screen space)
        const bar = {
          x: 16.5,
          y: 14.5,
          w: 220,
            h: 16,
        };
        // Background
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)'; // White UI borders
        ctx.fillStyle = 'rgba(10,20,14,0.8)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(bar.x, bar.y, bar.w, bar.h);
        ctx.fill();
        ctx.stroke();

        // Fill (use cached gradients)
        if (!staminaBarGradients) initStaminaGradients();
        const ratio = stamina.current / stamina.max;
        const fillWidth = Math.round(bar.w * ratio);
          ctx.fillStyle = stamina.exhausted
            ? staminaBarGradients.exhausted
            : staminaBarGradients.normal;
        ctx.beginPath();
        ctx.rect(bar.x + 1, bar.y + 1, Math.max(0, fillWidth - 2), bar.h - 2);
        ctx.fill();

        // UI: Money counter (top-right, screen space)
        ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        const moneyText = `$${money.amount}`;
        const moneyTextWidth = ctx.measureText(moneyText).width;
        const moneyX = canvas.width - 16.5;
        const moneyY = 14.5;

        // Money border sprite (centered on money text)
          if (
            moneyBorderSprite.complete &&
            moneyBorderSprite.naturalWidth > 0
          ) {
          // Calculate size to fully enclose the text with generous padding
          const borderPadding = 50; // Increased padding for better centering
          const borderWidth = moneyTextWidth + borderPadding;
          const borderHeight = 40; // Increased height to better center around text

          // Center the border on the money text
          // moneyX is the right edge of the text, so center is at moneyX - moneyTextWidth/2
          const textCenterX = moneyX - moneyTextWidth / 2;
          const borderX = textCenterX - borderWidth / 2 - 4; // Moved left by 4 pixels
          const textCenterY = moneyY + 8; // Approximate center of text vertically
          const borderY = textCenterY - borderHeight / 2 + 6; // Moved down by 6 pixels (was 4)

          ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
              moneyBorderSprite,
              borderX,
              borderY,
              borderWidth,
              borderHeight
            );
        } else {
          // Fallback while loading
          ctx.fillStyle = 'rgba(10,20,14,0.8)';
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
          ctx.lineWidth = 1;
          const moneyPadding = 8;
          const moneyHeight = 18;
          ctx.beginPath();
            ctx.rect(
              moneyX - moneyTextWidth - moneyPadding,
              moneyY,
              moneyTextWidth + moneyPadding,
              moneyHeight
            );
          ctx.fill();
          ctx.stroke();
        }

        // Money text (drawn on top of border, centered vertically)
        ctx.fillStyle = '#ffffff';
        ctx.fillText(moneyText, moneyX, moneyY + 8);

        // Draw balancing minigame
        if (balancingMinigame.active) {
          ctx.save();

          // Background overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Minigame panel (bigger to fit text)
          const panelWidth = 450;
          const panelHeight = 350;
          const panelX = (canvas.width - panelWidth) / 2;
          const panelY = (canvas.height - panelHeight) / 2;

          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

          ctx.strokeStyle = '#ffffff'; // White menu borders
          ctx.lineWidth = 3;
          ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Draw pot pole sprite (replaces drawn stick)
          const stickX = balancingMinigame.stickX;
            const stickBaseY = balancingMinigame.stickY + 25; // Bottom of stick
            const stickTipY = balancingMinigame.stickY - 25; // Top of stick (tip)
            const stickHeight = stickBaseY - stickTipY; // Height of stick area

            // Draw pole sprite centered at stick position
            if (potPoleSprite.complete && potPoleSprite.naturalWidth > 0) {
              ctx.imageSmoothingEnabled = false;
              // Draw pole sprite - 2x bigger in all directions
              const poleWidth = stickHeight * 0.6; // Double width: 30% * 2 = 60% of height
              const poleHeight = stickHeight * 2; // Double height
              // Center the larger pole on the original stick position
              const poleX = stickX - poleWidth / 2; // Center horizontally
              const poleY = stickY - poleHeight / 2; // Center vertically on stickY
              ctx.drawImage(potPoleSprite, poleX, poleY, poleWidth, poleHeight);
            } else {
              // Fallback: draw simple stick while sprite loads
          ctx.strokeStyle = '#8b4513'; // Brown
              ctx.lineWidth = 6;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(stickX, stickBaseY);
          ctx.lineTo(stickX, stickTipY);
          ctx.stroke();
          ctx.fillStyle = '#654321'; // Darker brown for tip
          ctx.beginPath();
          ctx.arc(stickX, stickTipY, 3, 0, Math.PI * 2);
          ctx.fill();
            }

            // Draw pot balancing on tip of stick - only if not breaking
            // Pot size varies by type: tall is taller, short is shorter
            let potSize = 100; // Base size for regular pot
            if (balancingMinigame.potType === 'tall') {
              potSize = 120; // Taller pot
            } else if (balancingMinigame.potType === 'short') {
              potSize = 80; // Shorter pot
            }

            // Lower the pot position (move it down to avoid text overlap)
            const potContactY = stickTipY + 30; // Pot contacts stick lower down

          if (!balancingMinigame.breaking) {
            ctx.save();
            // Translate to the contact point (where pot touches stick tip)
            ctx.translate(stickX, potContactY);
            // Rotate around the contact point
            ctx.rotate(balancingMinigame.potAngle);

              // Select the correct pot sprite based on type
              let currentPotSprite = potSprite;
              if (balancingMinigame.potType === 'tall') {
                currentPotSprite = potTallTanSprite;
              } else if (balancingMinigame.potType === 'short') {
                currentPotSprite = potShortGreySprite;
              }

            // Draw pot sprite from PNG, offset upward so bottom is at rotation point
              if (
                currentPotSprite.complete &&
                currentPotSprite.naturalWidth > 0
              ) {
              ctx.imageSmoothingEnabled = false;
              // Draw with bottom at origin (0, 0), so pot extends upward
                ctx.drawImage(
                  currentPotSprite,
                  -potSize / 2,
                  -potSize,
                  potSize,
                  potSize
                );
            } else {
                // Placeholder while loading (color varies by type)
                if (balancingMinigame.potType === 'tall') {
                  ctx.fillStyle = '#d2b48c'; // Tan color
                } else if (balancingMinigame.potType === 'short') {
                  ctx.fillStyle = '#808080'; // Grey color
                } else {
                  ctx.fillStyle = '#8b4513'; // Brown for regular
                }
              ctx.beginPath();
                ctx.ellipse(
                  0,
                  -potSize / 2,
                  potSize / 2,
                  potSize / 2.5,
                  0,
                  0,
                  Math.PI * 2
                );
              ctx.fill();
            }

            ctx.restore();
          }

          // Draw breaking pot pieces
            if (
              balancingMinigame.breaking &&
              balancingMinigame.pieces.length > 0
            ) {
            for (let i = 0; i < balancingMinigame.pieces.length; i++) {
              const piece = balancingMinigame.pieces[i];
              if (piece.opacity > 0) {
                ctx.save();
                ctx.globalAlpha = piece.opacity;
                ctx.translate(piece.x, piece.y);
                ctx.rotate(piece.rotation);

                // Draw pot piece (brown fragment)
                ctx.fillStyle = '#8b4513';
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.beginPath();
                  ctx.rect(
                    -piece.size / 2,
                    -piece.size / 2,
                    piece.size,
                    piece.size
                  );
                ctx.fill();
                ctx.stroke();

                ctx.restore();
              }
            }
          }

          // Timer text
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 72px ui-monospace, Menlo, Consolas, monospace'; // 3x bigger (24 * 3)
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
            const timeText = Math.ceil(
              balancingMinigame.timeRemaining
            ).toString();
          ctx.fillText(`Time: ${timeText}s`, canvas.width / 2, panelY + 20);

          // Instructions
          ctx.fillStyle = '#ffffff';
          ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
          ctx.textBaseline = 'bottom';
            ctx.fillText(
              'Use arrow keys to keep the pot from tipping!',
              canvas.width / 2,
              panelY + panelHeight - 20
            );

          ctx.restore();
        }

        // Draw brushing minigame
        if (brushingMinigame.active) {
          ctx.save();

          // Background overlay
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Minigame panel
          const panelWidth = 450;
          const panelHeight = 350;
          const panelX = (canvas.width - panelWidth) / 2;
          const panelY = (canvas.height - panelHeight) / 2;

          ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
          ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

          ctx.strokeStyle = '#ffffff'; // White menu borders
          ctx.lineWidth = 3;
          ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

          // Draw dirt sprite (in center, with red tint based on redness)
          const dirtSize = 150;
          const dirtX = canvas.width / 2;
          const dirtY = canvas.height / 2;

          if (dirtSprite.complete && dirtSprite.naturalWidth > 0) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;

            // Draw dirt sprite normally first
            ctx.globalAlpha = 1.0;
              ctx.drawImage(
                dirtSprite,
                dirtX - dirtSize / 2,
                dirtY - dirtSize / 2,
                dirtSize,
                dirtSize
              );

            // Apply red color tint using multiply blend mode (gradual transition)
            const redness = brushingMinigame.redness;
            if (redness > 0) {
              // Set blend mode to multiply for color tinting effect
              ctx.globalCompositeOperation = 'multiply';
              ctx.globalAlpha = redness; // Fade in the red over 1 second
              ctx.fillStyle = '#ff0000';
                ctx.fillRect(
                  dirtX - dirtSize / 2,
                  dirtY - dirtSize / 2,
                  dirtSize,
                  dirtSize
                );

              // Reset blend mode
              ctx.globalCompositeOperation = 'source-over';

              // Add a subtle glow when fully red
              if (redness >= 1.0) {
                const pulse = Math.sin(Date.now() / 150) * 0.2 + 0.8;
                ctx.globalAlpha = pulse * 0.15;
                ctx.fillStyle = '#ff3333';
                  ctx.fillRect(
                    dirtX - dirtSize / 2 - 5,
                    dirtY - dirtSize / 2 - 5,
                    dirtSize + 10,
                    dirtSize + 10
                  );
              }
            }

            ctx.restore();
          } else {
            // Fallback while loading
            const redness = brushingMinigame.redness;
            // Blend from brown to red based on redness value
            const r = Math.round(139 + (255 - 139) * redness);
            const g = Math.round(69 * (1 - redness));
            const b = Math.round(19 * (1 - redness));
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.beginPath();
              ctx.rect(
                dirtX - dirtSize / 2,
                dirtY - dirtSize / 2,
                dirtSize,
                dirtSize
              );
            ctx.fill();
          }

          // Draw brush sprite - now animated with brushOffset
          const brushSize = 80;
          const brushX = canvas.width / 2 + brushingMinigame.brushOffset; // Add offset for animation
          const brushY = brushingMinigame.brushY;

          if (brushSprite.complete && brushSprite.naturalWidth > 0) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
              ctx.drawImage(
                brushSprite,
                brushX - brushSize / 2,
                brushY - brushSize / 2,
                brushSize,
                brushSize
              );
            ctx.restore();
          } else {
            // Fallback while loading
            ctx.fillStyle = '#8b7355';
            ctx.beginPath();
              ctx.rect(
                brushX - brushSize / 2,
                brushY - brushSize / 2,
                brushSize,
                brushSize
              );
            ctx.fill();
          }

          // Draw particles
          for (const p of brushingMinigame.particles) {
            ctx.save();
            ctx.globalAlpha = p.life; // Fade out as life decreases
            ctx.fillStyle = '#8b4513'; // Brown dirt color
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }

          // Instructions
          ctx.fillStyle = '#ffffff';
          ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
            ctx.fillText(
              'Hold SPACE to brush the dirt clean!',
              canvas.width / 2,
              panelY + 20
            );

          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textBaseline = 'bottom';
            ctx.fillText(
              'When it turns RED, release SPACE quickly for max cash!',
              canvas.width / 2,
              panelY + panelHeight - 20
            );

            ctx.restore();
          }

          // Draw Declaration of Independence minigame
          if (declarationMinigame.active) {
            ctx.save();

            // Background overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Minigame panel
            const panelWidth = 700;
            const panelHeight = 500;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff'; // White menu borders
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(
              'Declaration of Independence - Authenticity Check',
              Math.round(canvas.width / 2),
              Math.round(panelY + 20)
            );

            // Divide panel into two columns
            const columnWidth = (panelWidth - 60) / 2; // Leave space for divider and padding
            const leftX = panelX + 20;
            const rightX = panelX + panelWidth / 2 + 10;
            const textY = panelY + 70;
            const textWidth = columnWidth - 20;

            // Left column label (Reference)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Reference',
              Math.round(leftX + columnWidth / 2),
              Math.round(textY - 25)
            );

            // Left column text (real excerpt)
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            // Enable better text rendering

            // Word wrap for left text
            const leftWords = declarationMinigame.realExcerpt.split(' ');
            let leftLine = '';
            let leftY = textY;
            for (let i = 0; i < leftWords.length; i++) {
              const testLine = leftLine + leftWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > textWidth && i > 0) {
                ctx.fillText(leftLine, Math.round(leftX), Math.round(leftY));
                leftLine = leftWords[i] + ' ';
                leftY += 24;
              } else {
                leftLine = testLine;
              }
            }
            ctx.fillText(leftLine, Math.round(leftX), Math.round(leftY));

            // Divider line
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelX + panelWidth / 2, panelY + 60);
            ctx.lineTo(panelX + panelWidth / 2, panelY + panelHeight - 100);
            ctx.stroke();

            // Right column label (Questionable)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(
              'Questionable authenticity',
              Math.round(rightX + columnWidth / 2),
              Math.round(textY - 25)
            );

            // Right column text (test excerpt)
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            // Enable better text rendering

            // Word wrap for right text
            const rightWords = declarationMinigame.testExcerpt.split(' ');
            let rightLine = '';
            let rightY = textY;
            for (let i = 0; i < rightWords.length; i++) {
              const testLine = rightLine + rightWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > textWidth && i > 0) {
                ctx.fillText(rightLine, Math.round(rightX), Math.round(rightY));
                rightLine = rightWords[i] + ' ';
                rightY += 24;
              } else {
                rightLine = testLine;
              }
            }
            ctx.fillText(rightLine, Math.round(rightX), Math.round(rightY));

            // Buttons
            if (!declarationMinigame.answered) {
              const buttonY = panelY + panelHeight - 80;
              const buttonWidth = 150;
              const buttonHeight = 40;
              const buttonSpacing = 20;
              const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
              const buttonStartX = canvas.width / 2 - totalButtonWidth / 2;

              // Display button (left) - brighter green
              const displayButtonX = buttonStartX;
              // Check if mouse is hovering over Display button
              const isHoveringDisplay =
                mouseX >= displayButtonX &&
                mouseX <= displayButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringDisplay
                ? 'rgba(0, 255, 0, 1.0)' // Even brighter green on hover
                : 'rgba(0, 200, 0, 0.9)'; // Brighter green
              ctx.fillRect(
                Math.round(displayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.strokeStyle = isHoveringDisplay ? '#ffff00' : '#ffffff'; // Yellow border on hover
              ctx.lineWidth = isHoveringDisplay ? 3 : 2; // Thicker border on hover
              ctx.strokeRect(
                Math.round(displayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'Display',
                Math.round(displayButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2)
              );

              // Throw away button (right) - brighter red
              const throwAwayButtonX =
                buttonStartX + buttonWidth + buttonSpacing;
              // Check if mouse is hovering over Throw away button
              const isHoveringThrowAway =
                mouseX >= throwAwayButtonX &&
                mouseX <= throwAwayButtonX + buttonWidth &&
                mouseY >= buttonY &&
                mouseY <= buttonY + buttonHeight;

              // Use brighter color when hovering
              ctx.fillStyle = isHoveringThrowAway
                ? 'rgba(255, 0, 0, 1.0)' // Even brighter red on hover
                : 'rgba(200, 0, 0, 0.9)'; // Brighter red
              ctx.fillRect(
                Math.round(throwAwayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.strokeStyle = isHoveringThrowAway ? '#ffff00' : '#ffffff'; // Yellow border on hover
              ctx.lineWidth = isHoveringThrowAway ? 3 : 2; // Thicker border on hover
              ctx.strokeRect(
                Math.round(throwAwayButtonX),
                Math.round(buttonY),
                buttonWidth,
                buttonHeight
              );
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 18px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                'Throw away',
                Math.round(throwAwayButtonX + buttonWidth / 2),
                Math.round(buttonY + buttonHeight / 2)
              );
            } else {
              // Show result with money gained/lost
              let resultText = '';
              let resultColor = '#ffffff';

              if (declarationMinigame.wasCorrect) {
                resultText = 'Correct!';
                resultColor = '#00ff00'; // Green
              } else if (declarationMinigame.actualReward === 0) {
                resultText = 'Incorrect! (No penalty)';
                resultColor = '#ffff00'; // Yellow for neutral
              } else {
                resultText = 'Incorrect!';
                resultColor = '#ff0000'; // Red
              }

              // Money text
              let moneyText = '';
              if (declarationMinigame.actualReward > 0) {
                moneyText = `+$${declarationMinigame.actualReward}`;
              } else if (declarationMinigame.actualReward < 0) {
                moneyText = `$${declarationMinigame.actualReward}`; // Already negative
              } else {
                moneyText = '$0';
              }

              ctx.fillStyle = resultColor;
              ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(
                resultText,
                Math.round(canvas.width / 2),
                Math.round(panelY + panelHeight - 60)
              );

              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 24px ui-monospace, Menlo, Consolas, monospace';
              ctx.fillText(
                moneyText,
                Math.round(canvas.width / 2),
                Math.round(panelY + panelHeight - 30)
              );
            }

            ctx.restore();
          }

          // Draw game over screen
          if (gameOver.active) {
            ctx.save();

            // Full screen overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Game over panel
            const panelWidth = 600;
            const panelHeight = 200;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = (canvas.height - panelHeight) / 2;

            ctx.fillStyle = 'rgba(139, 0, 0, 0.95)'; // Dark red background
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

            // Game over text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('GAME OVER', canvas.width / 2, panelY + 30);

            // Message
            ctx.font = '18px ui-monospace, Menlo, Consolas, monospace';
            ctx.textBaseline = 'middle';

            // Word wrap the message
            const messageWords = gameOver.message.split(' ');
            let messageLine = '';
            let messageY = panelY + 90;
            const messageMaxWidth = panelWidth - 40;

            for (let i = 0; i < messageWords.length; i++) {
              const testLine = messageLine + messageWords[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > messageMaxWidth && i > 0) {
                ctx.fillText(messageLine, canvas.width / 2, messageY);
                messageLine = messageWords[i] + ' ';
                messageY += 25;
              } else {
                messageLine = testLine;
              }
            }
            ctx.fillText(messageLine, canvas.width / 2, messageY);

            // Restart instruction
            ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textBaseline = 'bottom';
            ctx.fillText(
              'Press Spacebar to restart',
              canvas.width / 2,
              panelY + panelHeight - 20
            );

          ctx.restore();
        }

        // Draw inventory menu
        if (inventory.open) {
          drawInventory();
        }

        // Draw shop menu
        if (shop.open) {
          drawShopMenu();
        }

        // Draw dialogue textbox (RPG style at top of screen)
        if (tutorial.active || shopkeeper.dialogue || oldGuy.dialogue) {
          drawDialogueBox();
        }
      }

      function drawShopMenu() {
        ctx.save();

        const shopWidth = 400;
        const itemHeight = 50;
        const itemPadding = 10;
        const titleHeight = 40;
        const instructionsHeight = 25;
        const topPadding = 15;
        const bottomPadding = 15;
          const shopHeight =
            titleHeight +
            topPadding +
            shop.items.length * itemHeight +
            (shop.items.length - 1) * itemPadding +
            bottomPadding +
            instructionsHeight;
        const shopX = Math.round(canvas.width / 2 - shopWidth / 2) + 0.5;
        const shopY = Math.round(canvas.height / 2 - shopHeight / 2) + 0.5;

        // Background overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Shop panel background
        ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
        ctx.beginPath();
        ctx.rect(shopX, shopY, shopWidth, shopHeight);
        ctx.fill();

        // Shop panel border
        ctx.strokeStyle = '#ffffff'; // White borders
        ctx.lineWidth = 3;
        ctx.strokeRect(shopX, shopY, shopWidth, shopHeight);

        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Shop', shopX + shopWidth / 2, shopY + 12);

        // Draw shop items
        const startY = shopY + titleHeight + topPadding;
        for (let i = 0; i < shop.items.length; i++) {
          const item = shop.items[i];
          const itemY = startY + i * (itemHeight + itemPadding);
          const itemRectX = shopX + 20;
          const itemRectY = itemY;
          const itemRectW = shopWidth - 40;
          const itemRectH = itemHeight;

          // Check if player already owns this tier
            const alreadyOwned =
              inventory.equipment && inventory.equipment.tier === item.tier;

          // Item background
            ctx.fillStyle = alreadyOwned
              ? 'rgba(15, 30, 20, 0.6)'
              : 'rgba(20, 40, 30, 0.8)';
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; // White borders
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(itemRectX, itemRectY, itemRectW, itemRectH);
          ctx.fill();
          ctx.stroke();

          // Item name
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(item.name, itemRectX + 10, itemRectY + 6);

          // Item tier
          ctx.fillStyle = '#ffffff';
          ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText(`Tier ${item.tier}`, itemRectX + 10, itemRectY + 22);

          if (alreadyOwned) {
            // Show "Sold" for already owned items
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
              ctx.fillText(
                'SOLD',
                itemRectX + itemRectW - 10,
                itemRectY + itemRectH / 2
              );
          } else {
            // Price
            const priceText = `$${item.price}`;
            const canAfford = money.amount >= item.price;
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px ui-monospace, Menlo, Consolas, monospace';
            ctx.textAlign = 'right';
              ctx.fillText(
                priceText,
                itemRectX + itemRectW - 10,
                itemRectY + 14
              );

            // Buy button indicator
            if (canAfford) {
              ctx.fillStyle = '#ffffff';
              ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'right';
                ctx.fillText(
                  'Press ' + (i + 1) + ' to buy',
                  itemRectX + itemRectW - 10,
                  itemRectY + 32
                );
            } else {
              ctx.fillStyle = '#ffffff';
              ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
              ctx.textAlign = 'right';
                ctx.fillText(
                  'Cannot afford',
                  itemRectX + itemRectW - 10,
                  itemRectY + 32
                );
            }
          }
        }

        // Instructions
        ctx.fillStyle = '#ffffff';
        ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Press Spacebar to close | Press 1-5 to buy',
            shopX + shopWidth / 2,
            shopY + shopHeight - 10
          );

        ctx.restore();
      }

      function purchaseItem(itemIndex) {
        if (itemIndex < 0 || itemIndex >= shop.items.length) return;

        const item = shop.items[itemIndex];

        // Check if player already owns a shovel of this tier
        if (inventory.equipment && inventory.equipment.tier === item.tier) {
          return; // Already own this type of shovel
        }

        if (money.amount >= item.price) {
          money.amount -= item.price;
          // Get the appropriate sprite for this shovel tier
          let sprite = shovelSprites[item.tier];
          // If sprite not loaded yet, load it now
          if (!sprite) {
              const spriteName =
                'assets/sprites/' +
                item.name.toLowerCase().replace(/\s+/g, '-') +
                '.png';
            sprite = loadShovelSprite(item.tier, spriteName);
          }
          // Add shovel to equipment slot
          inventory.equipment = {
            name: item.name,
            tier: item.tier,
              sprite: sprite,
          };
        }
      }

      function drawDialogueBox() {
        ctx.save();

        const boxHeight = 100;
        const boxY = 0; // Top of screen instead of bottom
        const boxPadding = 20;
        const boxMargin = 20;
        const boxX = boxMargin;
        const boxWidth = canvas.width - boxMargin * 2;

        // Background with slight transparency
        ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
        ctx.beginPath();
        ctx.rect(boxX, boxY, boxWidth, boxHeight);
        ctx.fill();

        // Border
        ctx.strokeStyle = '#ffffff'; // White borders
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

        // Inner border for depth
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Lighter white for inner border
        ctx.lineWidth = 1;
        ctx.strokeRect(boxX + 2, boxY + 2, boxWidth - 4, boxHeight - 4);

        // Dialogue text
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';

        // Word wrap the dialogue text
        const maxWidth = boxWidth - boxPadding * 2;
          const dialogueText = tutorial.active
            ? tutorial.dialogue
            : shopkeeper.dialogue || oldGuy.dialogue || '';
        const words = dialogueText.split(' ');
        let line = '';
        let y = boxY + boxPadding;

        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + ' ';
          const metrics = ctx.measureText(testLine);
          const testWidth = metrics.width;

          if (testWidth > maxWidth && i > 0) {
            ctx.fillText(line, boxX + boxPadding, y);
            line = words[i] + ' ';
            y += 22; // Line height
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, boxX + boxPadding, y);

        // Draw help text in bottom right of textbox (only for tutorial)
        if (tutorial.active) {
            const helpText =
              'Press Spacebar to progress textboxes and talk to people';
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'bottom';
          // Move further down and to the right (reduce padding more)
          ctx.fillText(helpText, boxX + boxWidth - 10, boxY + boxHeight - 10);
        }

        ctx.restore();
      }

      function drawInventory() {
        ctx.save();

        // Artifacts panel dimensions
        const slotSize = 48;
        const slotSpacing = 4;
        const slotsPerRow = 5;
        const numRows = 3;
        const panelPadding = 24;
        const equipmentSlotSize = 64;
        const titleHeight = 40;
        const equipmentLabelHeight = 16;
        const equipmentSpacing = 20;
        const instructionsHeight = 30;

        // Calculate proper dimensions to fit all slots
          const slotsAreaWidth =
            slotsPerRow * slotSize + (slotsPerRow - 1) * slotSpacing;
          const slotsAreaHeight =
            numRows * slotSize + (numRows - 1) * slotSpacing;
        const inventoryWidth = slotsAreaWidth + panelPadding * 2;
          const inventoryHeight =
            titleHeight +
            equipmentSlotSize +
            equipmentLabelHeight +
            equipmentSpacing +
            slotsAreaHeight +
            panelPadding * 2 +
            instructionsHeight;

          const panelX =
            Math.round(canvas.width / 2 - inventoryWidth / 2) + 0.5;
          const panelY =
            Math.round(canvas.height / 2 - inventoryHeight / 2) + 0.5;

        // Background with semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Main panel background
        ctx.fillStyle = 'rgba(8, 16, 12, 0.95)';
        ctx.beginPath();
        ctx.rect(panelX, panelY, inventoryWidth, inventoryHeight);
        ctx.fill();

        // Panel border
        ctx.strokeStyle = '#ffffff'; // White borders
        ctx.lineWidth = 2;
        ctx.strokeRect(panelX, panelY, inventoryWidth, inventoryHeight);

        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
          ctx.fillText('Tools', panelX + inventoryWidth / 2, panelY + 12);

        // Equipment slot (at the top, centered)
          const equipmentX =
            panelX + inventoryWidth / 2 - equipmentSlotSize / 2;
        const equipmentY = panelY + titleHeight;
        ctx.fillStyle = 'rgba(20, 40, 30, 0.8)';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White with slight transparency
        ctx.lineWidth = 2;
        ctx.beginPath();
          ctx.rect(
            equipmentX,
            equipmentY,
            equipmentSlotSize,
            equipmentSlotSize
          );
        ctx.fill();
        ctx.stroke();

        // Draw equipment sprite if equipped
        if (inventory.equipment && inventory.equipment.sprite) {
          const sprite = inventory.equipment.sprite;
          // Only draw if image is loaded
          if (sprite.complete && sprite.naturalWidth > 0) {
            const spriteSize = equipmentSlotSize - 8; // Leave some padding
            const spriteX = equipmentX + (equipmentSlotSize - spriteSize) / 2;
            const spriteY = equipmentY + (equipmentSlotSize - spriteSize) / 2;
            ctx.save();
            ctx.imageSmoothingEnabled = false; // Pixelated rendering
            ctx.drawImage(sprite, spriteX, spriteY, spriteSize, spriteSize);
            ctx.restore();
          }
        }

        // Equipment label (below the equipment slot)
        ctx.fillStyle = '#ffffff';
        ctx.font = '11px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
          ctx.fillText(
            'Equipment',
            equipmentX + equipmentSlotSize / 2,
            equipmentY + equipmentSlotSize + 4
          );

        // Artifact slots grid (below equipment label)
        const slotsStartX = panelX + panelPadding;
          const slotsStartY =
            equipmentY +
            equipmentSlotSize +
            equipmentLabelHeight +
            equipmentSpacing;

        for (let row = 0; row < numRows; row++) {
          for (let col = 0; col < slotsPerRow; col++) {
            const slotIndex = row * slotsPerRow + col;
            const slotX = slotsStartX + col * (slotSize + slotSpacing);
            const slotY = slotsStartY + row * (slotSize + slotSpacing);

            // Slot background
            ctx.fillStyle = 'rgba(20, 40, 30, 0.8)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White borders
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.rect(slotX, slotY, slotSize, slotSize);
            ctx.fill();
            ctx.stroke();

            // Draw item if present (currently all slots are empty)
            if (inventory.slots[slotIndex]) {
              // Item rendering would go here when items are added
            }
          }
        }

        // Instructions
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
          ctx.fillText(
            'Press E to close',
            panelX + inventoryWidth / 2,
            panelY + inventoryHeight - 12
          );

        ctx.restore();
                    }

      let lastTime = performance.now();
      function loop(now) {
        const dt = Math.min(33, now - lastTime);
        lastTime = now;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    })();
    </script>
</body>
</html>
